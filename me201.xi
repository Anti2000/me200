all data in xi
transfer to the links
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

  STRATEGY: .
[GOD] .
[ME] .
[FAMELY] .
[BUSSINESS] .
[PASSWORD] .
[GIT] .
[PYTHON] .
[DART] .
[FLUTTER] .

 GOD: .

 ME: .
  animality: .
    self-actualization: .
     desire to become the most that one can be. .
    self-Esteem: .
     respect, self-esteem, recognition, strength, freedom. .
    love and belonging: .
     friendship, intimacy, famely, sense of connection. .
    safety and security: .
     personal security, employment, resources, health, property. .
    physiological need: .
     air, water, [food], shelter, sleep, clothing, reproduction. .
    food: .
    sx: .

  goals: .

  brain: .
    thinking circle: .
          001. the permorded deals.faster define the three deals for executing and doing it. .
          002. the base deals. define the three base deals for doing and doing it. .
          003. the important deals. define the three important deals and doing it. .
          004. Gods will. .
          005. english. .
          006. questions. .
          007. chess. .
          008. math. .
          009. repeat the base. .
          010. write program. .
          101. wash face. .
          102. straight up hair. .
          103. teethbrushing. .
          104. freshen up. .
          105. coffee. .
          106. teapot. .
          107. cough. .
          108. exersise. .
          109. Bible. .
          110. pray. .
          111. breakfast. .
          112. email. .
          113. plan. .
          114. question. .
          115. reading. .
          117. shoes. .
          118. dwelling order. .
          119. db_me. .
          120. dinner. .

    PASSWORD: .
    
          aliexpress https://seller.aliexpress.ru/  anatole.yakovlev@gmail.com  Asd25@# .
          avito novikov.timofey1952@gmail.com 8 995 839-59-17. firefox .
          avito 89096009912 . .
          avito .

    FOOD: .
     brain for brain: .
      spinach. .


  BUSSINESS .
    
    SANDBOX .

    INCUBATORS .

    CHILDHOSES .

    190.0 вагонка  22 штуки.
130.0 вагонка  12 шт.
144.0 вагонка 12 шт.
49.0 вагонка 10 шт.
49.5 вагонка 10 шт.
65.0 вагонка 6 шт.
17.5 вагонка 10 шт.
25.5 вагонка  11 шт.
39.5 вагонка  7 шт.
132.0 вагонка угол 2 шт.
116.0 вагонка угол 2 шт.
99.0 вагонка угол 2 шт.
83.0 вагонка угол 2 шт.
66.0 вагонка угол 2 шт.
50.0 вагонка угол 2 шт.
34.0 вагонка угол 2 шт.
18.0 вагонка угол 2 шт.
47.0 Рейка  4шт. 
41.5 рейка  6 шт.
30.0 рейка 2 шт.
100 40*40  6 шт.
95.0  угол 6 шт. 
183. 40*40 2 шт.
33.0 40*40 2 шт.
50.0 40*40 4 шт.
96.0 40*40 2 шт.
31.5 40*40 3 шт.
130.0 доска шпунтовая для пола.  17 шт.
Наличник 4 шт. По 2 метра.
ЦЕНА По комплекту с вагонкой стоимость будет 14250.  НА 23.07.2023

GIT: .
 sudo apt install git .
 git --version .
 sudo apt update .
 git init: initialisation of git .
 git config --global user.name "Your Name" .
 git config --global user.email "youremail@domain.com" .
 git config --list .
 git config --global core.editor "kate": install editor .
 git commit: make commit .
 nano: To make the commit you should write your commit message, then press ctrl+o to write your message, and then ctrl+x to exit that screen.
 git log: show history of commits .
 git branch: show whats branch .
 git branch updata_1: creating new branch(updata_1) .
 git checkout updata_1: swiching on new branch(updata_1)
 git checkout -b updata_1: create and swiching on new branch(updata_1) .
 git branh -D updata_1: delete branch .
 git add <>: add files in commit .
 git add.: add all in commit .
 git log --graph: show branchs(tree) .
 git merge <branch>: merging of branchs .
 git clone <https://github.com/Anti2000/car_parser.git> <car_parser> : make up clone from github to computor .
 git remote -v: show what is connect to computor.  .
 git remote add origin <https://github.com/Anti2000/example.git> add shotcut .
 git push origin master: add file to server  ??? .
 git pull origin main: update data from githup .
 https://stackoverflow.com/questions/1443210/updating-a-local-repository-with-changes-from-a-github-repository .
 git pull --rebase .
 Then I push the changes to a remote branch of the same name: .
 git push origin FixForBug .

  UBUNTU .
   linux commands: ls: List the contents of a folder. .
   ls -l : to see details like file size, permission, modified time, etc. .
   cd : Change the directory. .
   cd .. : go upper. .
   mkdir exemple: create directory. .
   rmdir exemple: delete directory. .
   lsb_release -a :know version of ubuntu. .
   cat <name file>> : open file. .
   cat < namefile : create file. .
   open Terminal in Linux: Using Shortcut(CTRL+ALT+T). .

  VC CODE .
   install vc code: .
   sudo snap install --classic code. .

FLUTTER .
  funcion main. .
 Every app requires the top-level main() function, where execution starts. .
 Functions that don’t explicitly return a value have the void return type. .
 To display text on the console, you can use the top-level print() function: .

| void main() {
|  print('Hello, World!');
| }

  Variables. .

 Even in type-safe Dart code, you can declare most variables without explicitly specifying their type using var. .
 Thanks to type inference, these variables’ types are determined by their initial values: .

| var name = 'Voyager I';
| var year = 1977;
| var antennaDiameter = 3.7;
| var flybyObjects = ['Jupiter', 'Saturn', 'Uranus', 'Neptune'];
| var image = {
|   'tags': ['saturn'],
|   'url': '//path/to/saturn.jpg'
| };

 Here’s an example of creating a variable and initializing it: .

| var name = 'Bob';

 Variables store references. The variable called name contains a reference to a String object with a value of “Bob”. .
 The type of the name variable is inferred to be String, but you can change that type by specifying it. .
 If an object isn’t restricted to a single type, specify the Object type (or dynamic if necessary). .

| Object name = 'Bob';

 Another option is to explicitly declare the type that would be inferred: .

| String name = 'Bob';

      Note: This page follows the style guide recommendation of using var, rather than type annotations, for local variables. .
    
    Null safety. .

The Dart language enforces sound null safety. .
 Null safety prevents an error that results from unintentional access of variables set to null. .
 The error is called a null dereference error. A null dereference error occurs when you access .
 a property or call a method on an expression that evaluates to null. .
 An exception to this rule is when null supports the property or method, like toString() or hashCode. .
 With null safety, the Dart compiler detects these potential errors at compile time. .
 For example, say you want to find the absolute value of an int variable i. .
 If i is null, calling i.abs() causes a null dereference error. In other languages, .
 trying this could lead to a runtime error, but Dart’s compiler prohibits these actions. .
 Therefore, Dart apps can’t cause runtime errors.

Null safety introduces three key changes: .
 When you specify a type for a variable, parameter, or another relevant component, .
 you can control whether the type allows null. To enable nullability, you add a ? .
 to the end of the type declaration. .
  String? name  // Nullable type. Can be `null` or string. .
  String name   // Non-nullable type. Cannot be `null` but can be string. .

 You must initialize variables before using them. Nullable variables default to null, .
 so they are initialized by default. Dart doesn’t set initial values to non-nullable types. .
 It forces you to set an initial value. Dart doesn’t allow you to observe an uninitialized variable. .
 This prevents you from accessing properties or calling methods where the receiver’s type can be null . .
 but null doesn’t support the method or property used. .
 You can’t access properties or call methods on an expression with a nullable type. The same exception applies where it’s a property or method that null supports like hashCode or toString(). .

 Sound null safety changes potential runtime errors into edit-time analysis errors. . 
 Null safety flags a non-null variable when it has been either: .

 Not initialized with a non-null value. .
 Assigned a null value. .

 This check allows you to fix these errors before deploying your app. .
 
  Default value. .

 Uninitialized variables that have a nullable type have an initial value of null. .
 Even variables with numeric types are initially null, because numbers—like everything else in Dart—are objects. .

| int? lineCount;
| assert(lineCount == null);

 Note: Production code ignores the assert() call. During development, on the other hand, .
 assert(condition) throws an exception if condition is false. For details, check out Assert. .

 With null safety, you must initialize the values of non-nullable variables before you use them: .

| int lineCount = 0;

 You don’t have to initialize a local variable where it’s declared, but you do need to assign it a value before it’s used. For example, the following code is valid because Dart can detect that lineCount is non-null by the time it’s passed to print(): .

| int lineCount;

| if (weLikeToCount) {
|  lineCount = countLines();
| } else {
|  lineCount = 0;
| }

| print(lineCount);

 Top-level and class variables are lazily initialized; the initialization code runs the first time the variable is used. .
  
  Late variables. .

 The late modifier has two use cases: .
 Declaring a non-nullable variable that’s initialized after its declaration. .
 Lazily initializing a variable. .

 Often Dart’s control flow analysis can detect when a non-nullable variable is set to a non-null value .
 before it’s used, but sometimes analysis fails. Two common cases are top-level variables and instance variables: .
 Dart often can’t determine whether they’re set, so it doesn’t try. .

 If you’re sure that a variable is set before it’s used, but Dart disagrees, .
 you can fix the error by marking the variable as late: .

| late String description;

| void main() {
|  description = 'Feijoada!';
|  print(description);
| }

 If you fail to initialize a late variable, a runtime error occurs when the variable is used. .
 When you mark a variable as late but initialize it at its declaration, .
 then the initializer runs the first time the variable is used. .
 This lazy initialization is handy in a couple of cases: .

 The variable might not be needed, and initializing it is costly. .
 You’re initializing an instance variable, and its initializer needs access to this. .

 In the following example, if the temperature variable is never used, .
 then the expensive readThermometer() function is never called: .

| // This is the program's only call to readThermometer().
| late String temperature = readThermometer(); // Lazily initialized.

 Final and const. .

 If you never intend to change a variable, use final or const, either instead of var or in addition to a type. .
 A final variable can be set only once; a const variable is a compile-time constant. (Const variables are implicitly final.) .

 Note: Instance variables can be final but not const. .

 Here’s an example of creating and setting a final variable: .

| final name = 'Bob'; // Without a type annotation
| final String nickname = 'Bobby';

 You can’t change the value of a final variable: .

| name = 'Alice'; // Error: a final variable can only be set once.

 Use const for variables that you want to be compile-time constants. If the const variable is at the class level, .
 mark it static const. Where you declare the variable, set the value to a compile-time constant such as a number .
 or string literal, a const variable, or the result of an arithmetic operation on constant numbers: .

| const bar = 1000000; // Unit of pressure (dynes/cm2)
| const double atm = 1.01325 * bar; // Standard atmosphere

 The const keyword isn’t just for declaring constant variables. You can also use it to create constant values, .
 as well as to declare constructors that create constant values. Any variable can have a constant value. .

| var foo = const [];
| final bar = const [];
| const baz = []; // Equivalent to `const []`

 You can omit const from the initializing expression of a const declaration, like for baz above. For details, .
 see DON’T use const redundantly. .

 You can change the value of a non-final, non-const variable, even if it used to have a const value: .

| foo = [1, 2, 3]; // Was const []

 You can’t change the value of a const variable: .

| baz = [42]; // Error: Constant variables can't be assigned a value.

You can define constants that use type checks and casts (is and as), collection if, and spread operators .
(... and ...?): .

| const Object i = 3; // Where i is a const Object with an int value...
| const list = [i as int]; // Use a typecast.
| const map = {if (i is int) i: 'int'}; // Use is and collection if.
| const set = {if (list is List<int>) ...list}; // ...and a spread.

 Note: Although a final object cannot be modified, its fields can be changed. In comparison, .
 a const object and its fields cannot be changed: they’re immutable. .

 For more information on using const to create constant values, see Lists, Maps, and Classes. .

  Operators. .

 Dart supports the operators shown in the following table. The table shows Dart’s operator associativity .
 and operator precedence from highest to lowest, which are an approximation of Dart’s operator relationships. .
 You can implement many of these operators as class members. .

| Description 	            Operator 	                                                    Associativity
| unary postfix 	          expr++    expr--    ()    []    ?[]    .    ?.    ! 	        None
| unary prefix 	            -expr    !expr    ~expr    ++expr    --expr      await expr   None
| multiplicative 	          *    /    %  ~/ 	                                            Left
| additive 	                +    - 	                                                      Left
| shift 	                  <<    >>    >>> 	                                            Left
| bitwise AND 	            & 	                                                          Left
| bitwise XOR 	            ^ 	                                                          Left
| bitwise OR 	              | 	                                                          Left
| relational and type test 	>=    >    <=    <    as    is    is! 	                      None
| equality 	                ==    !=    	                                                None
| logical AND 	            && 	                                                          Left
| logical OR              	|| 	                                                          Left
| if null 	                ?? 	                                                          Left
| conditional             	expr1 ? expr2 : expr3 	                                      Right
| cascade                  	..    ?.. 	                                                  Left
| assignment               	=    *=    /=   +=   -=   &=   ^=   etc. 	                    Right

 Warning: The previous table should only be used as a helpful guide. The notion of operator precedence and .
 associativity is an approximation of the truth found in the language grammar. You can find the authoritative .
 behavior of Dart’s operator relationships in the grammar defined in the Dart language specification. .

 When you use operators, you create expressions. Here are some examples of operator expressions: .

| a++
| a + b
| a = b
| a == b
| c ? a : b
| a is T

  Operator precedence example. .

 In the operator table, each operator has higher precedence than the operators in the rows that follow it. .
 For example, the multiplicative operator % has higher precedence than (and thus executes before) the equality. .
 operator ==, which has higher precedence than the logical AND operator &&. That precedence means that .
 the following two lines of code execute the same way: .

| // Parentheses improve readability.
| if ((n % i == 0) && (d % i == 0)) ...

| // Harder to read, but equivalent.
| if (n % i == 0 && d % i == 0) ...

 Warning: For operators that take two operands, the leftmost operand determines which method is used. .
 For example, if you have a Vector object and a Point object, then aVector + aPoint uses Vector addition (+). .
 

  Arithmetic operators. .

 Dart supports the usual arithmetic operators, as shown in the following table. .

| Operator 	Meaning
| + 	      Add
| - 	      Subtract
| -expr 	  Unary minus, also known as negation (reverse the sign of the expression)
| *        	Multiply
| /        	Divide
| ~/        Divide, returning an integer result
| %       	Get the remainder of an integer division (modulo)

 Example: .

| assert(2 + 3 == 5);
| assert(2 - 3 == -1);
| assert(2 * 3 == 6);
| assert(5 / 2 == 2.5); // Result is a double
| assert(5 ~/ 2 == 2); // Result is an int
| assert(5 % 2 == 1); // Remainder

| assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');

 Dart also supports both prefix and postfix increment and decrement operators. .

| Operator 	Meaning
| ++var    	var = var + 1 (expression value is var + 1)
| var++ 	  var = var + 1 (expression value is var)
| --var 	  var = var - 1 (expression value is var - 1)
| var-- 	  var = var - 1 (expression value is var)

 Example: .

| int a;
| int b;

| a = 0;
| b = ++a; // Increment a before b gets its value.
| assert(a == b); // 1 == 1

| a = 0;
| b = a++; // Increment a after b gets its value.
| assert(a != b); // 1 != 0

| a = 0;
| b = --a; // Decrement a before b gets its value.
| assert(a == b); // -1 == -1

| a = 0;
| b = a--; // Decrement a after b gets its value.
| assert(a != b); // -1 != 0

 Equality and relational operators. .

 The following table lists the meanings of equality and relational operators. .

| Operator 	Meaning
| ==       	Equal; see discussion below
| !=      	Not equal
| >        	Greater than
| <        	Less than
| >=      	Greater than or equal to
| <=      	Less than or equal to

 To test whether two objects x and y represent the same thing, use the == operator. .
 (In the rare case where you need to know whether two objects are the exact same object, .
 use the identical() function instead.) Here’s how the == operator works: .

 If x or y is null, return true if both are null, and false if only one is null. .

 Return the result of invoking the == method on x with the argument y. (That’s right, operators .
 such as == are methods that are invoked on their first operand. For details, see Operators.). .

 Here’s an example of using each of the equality and relational operators: .

| assert(2 == 2);
| assert(2 != 3);
| assert(3 > 2);
| assert(2 < 3);
| assert(3 >= 3);
| assert(2 <= 3);

  Type test operators. .

 The as, is, and is! operators are handy for checking types at runtime. .

| Operator 	Meaning
| as 	Typecast (also used to specify library prefixes)
| is 	True if the object has the specified type
| is! 	True if the object doesn’t have the specified type

 The result of obj is T is true if obj implements the interface specified by T. For example, obj is Object? .
 is always true. .

 Use the as operator to cast an object to a particular type if and only if you are sure that the object .
 is of that type. Example: .

| (employee as Person).firstName = 'Bob';

 If you aren’t sure that the object is of type T, then use is T to check the type before using the object. .

| if (employee is Person) {
|   // Type check
|   employee.firstName = 'Bob';
| }

 Note: The code isn’t equivalent. If employee is null or not a Person, the first example throws an exception; .
 the second does nothing. .

  Assignment operators. .

 As you’ve already seen, you can assign values using the = operator. To assign only if the assigned-to .
 variable is null, use the ??= operator. .

| // Assign value to a
| a = value;
| // Assign value to b if b is null; otherwise, b stays the same
| b ??= value;

 Compound assignment operators such as += combine an operation with an assignment. .
| = 	    *= 	    %= 	     >>>= 	   ^=
| += 	    /=    	<<=     	&=       |=
| -= 	    ~/=   	>>= 	  	 

 Here’s how compound assignment operators work: .

|                        	Compound assignment 	Equivalent expression
| For an operator op:   	a op= b              	a = a op b
| Example:              	a += b               	a = a + b

 The following example uses assignment and compound assignment operators: .

| var a = 2; // Assign using =
| a *= 3; // Assign and multiply: a = a * 3
| assert(a == 6);

  Logical operators. .

 You can invert or combine boolean expressions using the logical operators. .

| Operator 	Meaning
| !expr   	inverts the following expression (changes false to true, and vice versa)
| || 	      logical OR
| && 	      logical AND 

 Here’s an example of using the logical operators: .

| if (!done && (col == 0 || col == 3)) {
|   // ...Do something...
| }

  Bitwise and shift operators. .

 You can manipulate the individual bits of numbers in Dart. Usually, you’d use these bitwise and shift .
 operators with integers. .

| Operator 	Meaning
|  &       	AND
|  | 	      OR
|  ^ 	      XOR
|  ~expr 	  Unary bitwise complement (0s become 1s; 1s become 0s)
|  << 	    Shift left
|  >> 	    Shift right
|  >>> 	    Unsigned shift right

 Note: The behavior of bitwise operations with large or negative operands might differ between platforms. .
 To learn more, check out Bitwise operations platform differences. .

 Here’s an example of using bitwise and shift operators: .

| final value = 0x22;
| final bitmask = 0x0f;

| assert((value & bitmask) == 0x02); // AND
| assert((value & ~bitmask) == 0x20); // AND NOT
| assert((value | bitmask) == 0x2f); // OR
| assert((value ^ bitmask) == 0x2d); // XOR

| assert((value << 4) == 0x220); // Shift left
| assert((value >> 4) == 0x02); // Shift right

| // Shift right example that results in different behavior on web
| // because the operand value changes when masked to 32 bits:
| assert((-value >> 4) == -0x03);

| assert((value >>> 4) == 0x02); // Unsigned shift right
| assert((-value >>> 4) > 0); // Unsigned shift right

 Version note: The >>> operator (known as triple-shift or unsigned shift) requires a language version of at .
 least 2.14. .

  Conditional expressions. .

 Dart has two operators that let you concisely evaluate expressions that might otherwise require if-else .
 statements: .

| condition ? expr1 : expr2
 If condition is true, evaluates expr1 (and returns its value); otherwise, evaluates and returns the value .
 of expr2. .

| expr1 ?? expr2
 If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2. .

 When you need to assign a value based on a boolean expression, consider using ? and : .
| var visibility = isPublic ? 'public' : 'private';

 If the boolean expression tests for null, consider using ??. .

| String playerName(String? name) => name ?? 'Guest';

 The previous example could have been written at least two other ways, but not as succinctly: .

| // Slightly longer version uses ?: operator.
| String playerName(String? name) => name != null ? name : 'Guest';

| // Very long version uses if-else statement.
| String playerName(String? name) {
|   if (name != null) {
|     return name;
|   } else {
|     return 'Guest';
|   }
| }

  Cascade notation. .

 Cascades (.., ?..) allow you to make a sequence of operations on the same object. In addition to accessing .
 instance members, you can also call instance methods on that same object. This often saves you the step of .
 creating a temporary variable and allows you to write more fluid code. .

 Consider the following code: .

| var paint = Paint()
|   ..color = Colors.black
|   ..strokeCap = StrokeCap.round
|   ..strokeWidth = 5.0;

 The constructor, Paint(), returns a Paint object. The code that follows the cascade notation operates .
 on this object, ignoring any values that might be returned. .

 The previous example is equivalent to this code: .

| var paint = Paint();
| paint.color = Colors.black;
| paint.strokeCap = StrokeCap.round;
| paint.strokeWidth = 5.0;

 If the object that the cascade operates on can be null, then use a null-shorting cascade (?..) .
 for the first operation. Starting with ?.. guarantees that none of the cascade operations are .
 attempted on that null object. .

| querySelector('#confirm') // Get an object.
|   ?..text = 'Confirm' // Use its members.
|   ..classes.add('important')
|   ..onClick.listen((e) => window.alert('Confirmed!'))
|   ..scrollIntoView();

 Version note: The ?.. syntax requires a language version of at least 2.12. .

 The previous code is equivalent to the following: .

| var button = querySelector('#confirm');
| button?.text = 'Confirm';
| button?.classes.add('important');
| button?.onClick.listen((e) => window.alert('Confirmed!'));
| button?.scrollIntoView();

You can also nest cascades. For example: .

| final addressBook = (AddressBookBuilder()
|       ..name = 'jenny'
|       ..email = 'jenny@example.com'
|       ..phone = (PhoneNumberBuilder()
|             ..number = '415-555-0100'
|             ..label = 'home')
|           .build())
|     .build();

 Be careful to construct your cascade on a function that returns an actual object. For example, .
 the following code fails: .

| var sb = StringBuffer();
| sb.write('foo')
|   ..write('bar'); // Error: method 'write' isn't defined for 'void'.

 The sb.write() call returns void, and you can’t construct a cascade on void. .

 Note: Strictly speaking, the “double dot” notation for cascades isn’t an operator. .
 It’s just part of the Dart syntax. .
 
  Other operators. .

 You’ve seen most of the remaining operators in other examples: .

| Operator 	Name                   	      Meaning
|   ()     	Function application 	        Represents a function call
|   [] 	    Subscript access 	            Represents a call to the overridable [] operator; example: fooList[1] passes the int 1 to fooList to access the element at index 1
|   ?[] 	  Conditional subscript access 	Like [], but the leftmost operand can be null; example: fooList?[1] passes the int 1 to fooList to access the element at index 1 unless fooList is null (in which case the expression evaluates to null)
|   . 	    Member access               	Refers to a property of an expression; example: foo.bar selects property bar from expression foo
|   ?. 	    Conditional member access   	Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)
|   ! 	    Null assertion operator 	     Casts an expression to its underlying non-nullable type, throwing a runtime exception if the cast fails; example: foo!.bar asserts foo is non-null and selects the property bar, unless foo is null in which case a runtime exception is thrown


Comments

Dart supports single-line comments, multi-line comments, and documentation comments.
Single-line comments

A single-line comment begins with //. Everything between // and the end of line is ignored by the Dart compiler.

void main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}

Multi-line comments

A multi-line comment begins with /* and ends with */. Everything between /* and */ is ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). Multi-line comments can nest.

void main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}

Documentation comments

Documentation comments are multi-line or single-line comments that begin with /// or /**. Using /// on consecutive lines has the same effect as a multi-line doc comment.

Inside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level variables, functions, and parameters. The names in brackets are resolved in the lexical scope of the documented program element.

Here is an example of documentation comments with references to other classes and arguments:

/// A domesticated South American camelid (Lama glama).
///
/// Andean cultures have used llamas as meat and pack
/// animals since pre-Hispanic times.
///
/// Just like any other animal, llamas need to eat,
/// so don't forget to [feed] them some [Food].
class Llama {
  String? name;

  /// Feeds your llama [food].
  ///
  /// The typical llama eats one bale of hay per week.
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}

In the class’s generated documentation, [feed] becomes a link to the docs for the feed method, and [Food] becomes a link to the docs for the Food class.

To parse Dart code and generate HTML documentation, you can use Dart’s documentation generation tool, dart doc. For an example of generated documentation, see the Dart API documentation. For advice on how to structure your comments, see Effective Dart: Documentation.
 
 Metadata

Use metadata to give additional information about your code. A metadata annotation begins with the character @, followed by either a reference to a compile-time constant (such as deprecated) or a call to a constant constructor.

Three annotations are available to all Dart code: @Deprecated, @deprecated, and @override. For examples of using @override, see Extending a class. Here’s an example of using the @Deprecated annotation:

class Television {
  /// Use [turnOn] to turn the power on instead.
  @Deprecated('Use turnOn instead')
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {...}
  // ···
}

You can define your own metadata annotations. Here’s an example of defining a @Todo annotation that takes two arguments:

class Todo {
  final String who;
  final String what;

  const Todo(this.who, this.what);
}

And here’s an example of using that @Todo annotation:

@Todo('Dash', 'Implement this function')
void doSomething() {
  print('Do something');
}

Metadata can appear before a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive. You can retrieve metadata at runtime using reflection.
 
  Control flow statements. .

 Dart supports the usual control flow statements: .

| if (year >= 2001) {
|   print('21st century');
| } else if (year >= 1901) {
|   print('20th century');
| }

| for (final object in flybyObjects) {
|   print(object);
| }

| for (int month = 1; month <= 12; month++) {
|   print(month);
| }

| while (year < 2016) {
|   year += 1;
| }

  Functions. .
 We recommend specifying the types of each function’s arguments and return value: .

| int fibonacci(int n) {
|   if (n == 0 || n == 1) return n;
|   return fibonacci(n - 1) + fibonacci(n - 2);
| }

| var result = fibonacci(20);

 A shorthand => (arrow) syntax is handy for functions that contain a single statement. .
 This syntax is especially useful when passing anonymous functions as arguments: .
 
 | flybyObjects.where((name) => name.contains('turn')).forEach(print);

 Besides showing an anonymous function (the argument to where()), this code shows that you can use a function as an argument: .
 the top-level print() function is an argument to forEach(). .

 Loops

This page shows how you can control the flow of your Dart code using loops and supporting statements:

    for loops
    while and do while loops
    break and continue

You can also manipulate control flow in Dart using:

    Branching, like if and switch
    Exceptions, like try, catch, and throw

For loops

You can iterate with the standard for loop. For example:

var message = StringBuffer('Dart is fun');
for (var i = 0; i < 5; i++) {
  message.write('!');
}

Closures inside of Dart’s for loops capture the value of the index. This avoids a common pitfall found in JavaScript. For example, consider:

var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}

for (final c in callbacks) {
  c();
}

The output is 0 and then 1, as expected. In contrast, the example would print 2 and then 2 in JavaScript.

Sometimes you might not need to know the current iteration counter when iterating over an Iterable type, like List or Set. In that case, use the for-in loop for cleaner code:

for (final candidate in candidates) {
  candidate.interview();
}

To process the values obtained from the iterable, you can also use a pattern in a for-in loop:

for (final Candidate(:name, :yearsExperience) in candidates) {
  print('$name has $yearsExperience of experience.');
}

Tip: To practice using for-in, follow the Iterable collections codelab.

Iterable classes also have a forEach() method as another option:

var collection = [1, 2, 3];
collection.forEach(print); // 1 2 3

While and do-while

A while loop evaluates the condition before the loop:

while (!isDone()) {
  doSomething();
}

A do-while loop evaluates the condition after the loop:

do {
  printLine();
} while (!atEndOfPage());

Break and continue

Use break to stop looping:

while (true) {
  if (shutDownRequested()) break;
  processIncomingRequests();
}

Use continue to skip to the next loop iteration:

for (int i = 0; i < candidates.length; i++) {
  var candidate = candidates[i];
  if (candidate.yearsExperience < 5) {
    continue;
  }
  candidate.interview();
}

If you’re using an Iterable such as a list or set, how you write the previous example might differ:

candidates
    .where((c) => c.yearsExperience >= 5)
    .forEach((c) => c.interview());

Branches

This page shows how you can control the flow of your Dart code using branches:

    if statements and elements
    if-case statements and elements
    switch statements and expressions

You can also manipulate control flow in Dart using:

    Loops, like for and while
    Exceptions, like try, catch, and throw

If

Dart supports if statements with optional else clauses. The condition in parentheses after if must be an expression that evaluates to a boolean:

if (isRaining()) {
  you.bringRainCoat();
} else if (isSnowing()) {
  you.wearJacket();
} else {
  car.putTopDown();
}

To learn how to use if in an expression context, check out Conditional expressions.
If-case

Dart if statements support case clauses followed by a pattern:

if (pair case [int x, int y]) return Point(x, y);

If the pattern matches the value, then the branch executes with any variables the pattern defines in scope.

In the previous example, the list pattern [int x, int y] matches the value pair, so the branch return Point(x, y) executes with the variables that the pattern defined, x and y.

Otherwise, control flow progresses to the else branch to execute, if there is one:

if (pair case [int x, int y]) {
  print('Was coordinate array $x,$y');
} else {
  throw FormatException('Invalid coordinates.');
}

The if-case statement provides a way to match and destructure against a single pattern. To test a value against multiple patterns, use switch.

Version note: Case clauses in if statements require a language version of at least 3.0.

Switch statements

A switch statement evaluates a value expression against a series of cases. Each case clause is a pattern for the value to match against. You can use any kind of pattern for a case.

When the value matches a case’s pattern, the case body executes. Non-empty case clauses jump to the end of the switch after completion. They do not require a break statement. Other valid ways to end a non-empty case clause are a continue, throw, or return statement.

Use a default or wildcard _ clause to execute code when no case clause matches:

var command = 'OPEN';
switch (command) {
  case 'CLOSED':
    executeClosed();
  case 'PENDING':
    executePending();
  case 'APPROVED':
    executeApproved();
  case 'DENIED':
    executeDenied();
  case 'OPEN':
    executeOpen();
  default:
    executeUnknown();
}

Empty cases fall through to the next case. For an empty case that does not fall through, use break for its body. For non-sequential fall-through, you can use a continue statement and a label:

switch (command) {
  case 'OPEN':
    executeOpen();
    continue newCase; // Continues executing at the newCase label.

  case 'DENIED': // Empty case falls through.
  case 'CLOSED':
    executeClosed(); // Runs for both DENIED and CLOSED,

  newCase:
  case 'PENDING':
    executeNowClosed(); // Runs for both OPEN and PENDING.
}

You can use logical-or patterns to allow cases to share a body or a guard. To learn more about patterns and case clauses, check out the patterns documentation on Switch statements and expressions.
Switch expressions

A switch expression produces a value based on the expression body of whichever case matches. You can use a switch expression wherever Dart allows expressions, except at the start of an expression statement. For example:

var x = switch (y) { ... };

print(switch (x) { ... });

return switch (x) { ... };

If you want to use a switch at the start of an expression statement, use a switch statement.

Switch expressions allow you to rewrite a switch statement like this:

// Where slash, star, comma, semicolon, etc., are constant variables...
switch (charCode) {
  case slash || star || plus || minus: // Logical-or pattern
    token = operator(charCode);
  case comma || semicolon: // Logical-or pattern
    token = punctuation(charCode);
  case >= digit0 && <= digit9: // Relational and logical-and patterns
    token = number();
  default:
    throw FormatException('Invalid');
}

Into an expression, like this:

token = switch (charCode) {
  slash || star || plus || minus => operator(charCode),
  comma || semicolon => punctuation(charCode),
  >= digit0 && <= digit9 => number(),
  _ => throw FormatException('Invalid')
};

The syntax of a switch expression differs from switch statement syntax:

    Cases do not start with the case keyword.
    A case body is a single expression instead of a series of statements.
    Each case must have a body; there is no implicit fallthrough for empty cases.
    Case patterns are separated from their bodies using => instead of :.
    Cases are separated by , (and an optional trailing , is allowed).
    Default cases can only use _, instead of allowing both default and _.

Version note: Switch expressions require a language version of at least 3.0.
Exhaustiveness checking

Exhaustiveness checking is a feature that reports a compile-time error if it’s possible for a value to enter a switch but not match any of the cases.

// Non-exhaustive switch on bool?, missing case to match null possibility:
switch (nullableBool) {
  case true:
    print('yes');
  case false:
    print('no');
}

A default case (default or _) covers all possible values that can flow through a switch. This makes a switch on any type exhaustive.

Enums and sealed types are particularly useful for switches because, even without a default case, their possible values are known and fully enumerable. Use the sealed modifier on a class to enable exhaustiveness checking when switching over subtypes of that class:

sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
      Square(length: var l) => l * l,
      Circle(radius: var r) => math.pi * r * r
    };

If anyone were to add a new subclass of Shape, this switch expression would be incomplete. Exhaustiveness checking would inform you of the missing subtype. This allows you to use Dart in a somewhat functional algebraic datatype style.

Guard clause

To set an optional guard clause after a case clause, use the keyword when. A guard clause can follow if case, and both switch statements and expressions.

switch (pair) {
  case (int a, int b) when a > b:
    print('First element greater');
  case (int a, int b):
    print('First element not greater');
}

Guards evaluate an arbitrary boolean expression after matching. This allows you to add further constraints on whether a case body should execute. When the guard clause evaluates to false, execution proceeds to the next case rather than exiting the entire switch.

  Comments. .

 Dart comments usually start with //. .

| // This is a normal, one-line comment.

| /// This is a documentation comment, used to document libraries,
| /// classes, and their members. Tools like IDEs and dartdoc treat
| /// doc comments specially.

| /* Comments like these are also supported. */

  Imports. .

 To access APIs defined in other libraries, use import. .

| // Importing core libraries
| import 'dart:math';

| // Importing libraries from external packages
| import 'package:test/test.dart';

| // Importing files
| import 'path/to/my_other_file.dart';

  Classes. .

 Here’s an example of a class with three properties, two constructors, and a method. .
 One of the properties can’t be set directly, so it’s defined using a getter method (instead of a variable). .
 The method uses string interpolation to print variables’ string equivalents inside of string literals. .

| class Spacecraft {
|   String name;
|   DateTime? launchDate;

|   // Read-only non-final property
|   int? get launchYear => launchDate?.year;
| 
|   // Constructor, with syntactic sugar for assignment to members.
|   Spacecraft(this.name, this.launchDate) {
|   // Initialization code goes here.
|   }

|   // Named constructor that forwards to the default one.
|   Spacecraft.unlaunched(String name) : this(name, null);

|   // Method.
|   void describe() {
|     print('Spacecraft: $name');
|     // Type promotion doesn't work on getters.
|     var launchDate = this.launchDate;
|     if (launchDate != null) {
|       int years = DateTime.now().difference(launchDate).inDays ~/ 365;
|       print('Launched: $launchYear ($years years ago)');
|     } else {
|       print('Unlaunched');
|     }
|   }
| }

 You might use the Spacecraft class like this: .

| var voyager = Spacecraft('Voyager I', DateTime(1977, 9, 5));
| voyager.describe();

| var voyager3 = Spacecraft.unlaunched('Voyager III');
| voyager3.describe();

  Enums. .

 Enums are a way of enumerating a predefined set of values or instances in a way which ensures .
 that there cannot be any other instances of that type. .

 Here is an example of a simple enum that defines a simple list of predefined planet types: .

| enum PlanetType { terrestrial, gas, ice }

 Here is an example of an enhanced enum declaration of a class describing planets, .
 with a defined set of constant instances, namely the planets of our own solar system. .

| /// Enum that enumerates the different planets in our solar system
| /// and some of their properties.
| enum Planet {
|   mercury(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   venus(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   // ···
|   uranus(planetType: PlanetType.ice, moons: 27, hasRings: true),
|   neptune(planetType: PlanetType.ice, moons: 14, hasRings: true);

|   /// A constant generating constructor
|   const Planet(
|       {required this.planetType, required this.moons, required this.hasRings});

|   /// All instance variables are final
|   final PlanetType planetType;
|   final int moons;
|   final bool hasRings;

|   /// Enhanced enums support getters and other methods
|   bool get isGiant =>
|       planetType == PlanetType.gas || planetType == PlanetType.ice;
| }

 You might use the Planet enum like this: .

| final yourPlanet = Planet.earth;

| if (!yourPlanet.isGiant) {
|   print('Your planet is not a "giant planet".');
| }

..
  Inheritance. .

 Dart has single inheritance. .

| class Orbiter extends Spacecraft {
|   double altitude;

|   Orbiter(super.name, DateTime super.launchDate, this.altitude);
| }


Read more about extending classes, the optional @override annotation, and more.

  Mixins. .

 Mixins are a way of reusing code in multiple class hierarchies. The following is a mixin declaration: .

| mixin Piloted {
|   int astronauts = 1;

|   void describeCrew() {
|     print('Number of astronauts: $astronauts');
|   }
| }

 To add a mixin’s capabilities to a class, just extend the class with the mixin. .

| class PilotedCraft extends Spacecraft with Piloted {
|   // ···
| }

 PilotedCraft now has the astronauts field as well as the describeCrew() method. .

.....Read more about mixins.

  Interfaces and abstract classes. .

 All classes implicitly define an interface. Therefore, you can implement any class. .

| class MockSpaceship implements Spacecraft {
|   // ···
| }

....Read more about implicit interfaces, or about the explicit interface keyword.

 You can create an abstract class to be extended (or implemented) by a concrete class. .
 Abstract classes can contain abstract methods (with empty bodies). .

| abstract class Describable {
|   void describe();

|   void describeWithEmphasis() {
|     print('=========');
|     describe();
|     print('=========');
|   }
| }

 Any class extending Describable has the describeWithEmphasis() method, .
 which calls the extender’s implementation of describe(). .

.....Read more about abstract classes and methods.
  
  Async. .

 Avoid callback hell and make your code much more readable by using async and await. .

| const oneSecond = Duration(seconds: 1);
| // ···
| Future<void> printWithDelay(String message) async {
|   await Future.delayed(oneSecond);
|   print(message);
| }

 The method above is equivalent to: .

| Future<void> printWithDelay(String message) {
|   return Future.delayed(oneSecond).then((_) {
|     print(message);
|   });
| }

 As the next example shows, async and await help make asynchronous code easy to read. .

| Future<void> createDescriptions(Iterable<String> objects) async {
|   for (final object in objects) {
|     try {
|       var file = File('$object.txt');
|       if (await file.exists()) {
|         var modified = await file.lastModified();
|         print(
|             'File for $object already exists. It was modified on $modified.');
|         continue;
|       }
|       await file.create();
|       await file.writeAsString('Start describing $object in this file.');
|     } on IOException catch (e) {
|       print('Cannot create description for $object: $e');
|     }
|   }
| }

 You can also use async*, which gives you a nice, readable way to build streams. .

| Stream<String> report(Spacecraft craft, Iterable<String> objects) async* {
|   for (final object in objects) {
|     await Future.delayed(oneSecond);
|     yield '${craft.name} flies by $object';
|   }
| }

....Read more about asynchrony support, including async functions, Future, Stream, and the asynchronous loop (await for).

  Exceptions. .

 To raise an exception, use throw: .

| if (astronauts == 0) {
|   throw StateError('No astronauts.');
| }

 To catch an exception, use a try statement with on or catch (or both): .

| Future<void> describeFlybyObjects(List<String> flybyObjects) async {
|   try {
|     for (final object in flybyObjects) {
|       var description = await File('$object.txt').readAsString();
|       print(description);
|     }
|   } on IOException catch (e) {
|     print('Could not describe object: $e');
|   } finally {
|     flybyObjects.clear();
|   }
| }

 Note that the code above is asynchronous; try works for both synchronous code and code in an async function. .

...Read more about exceptions, including stack traces, rethrow, and the difference between Error and Exception.
  Important concepts. .

As you continue to learn about the Dart language, keep these facts and concepts in mind: .

    Everything you can place in a variable is an object, and every object is an instance of a class. .
    Even numbers, functions, and null are objects. With the exception of null (if you enable sound null safety), .
    all objects inherit from the Object class. .

    Version note: Null safety was introduced in Dart 2.12. Using null safety requires a language version of at least 2.12. .
    Although Dart is strongly typed, type annotations are optional because Dart can infer types. In var number = 101, number is inferred to be of type int. .
    If you enable null safety, variables can’t contain null unless you say they can. You can make a variable nullable by putting a question mark (?) at the end of its type. For example, a variable of type int? might be an integer, or it might be null. .
    If you know that an expression never evaluates to null but Dart disagrees, you can add ! to assert that it isn’t null (and to throw an exception if it is). An example: int x = nullableButNotNullInt! .
    When you want to explicitly say that any type is allowed, use the type Object? (if you’ve enabled null safety), .
    Object, or—if you must defer type checking until runtime—the special type dynamic. .
    Dart supports generic types, like List<int> (a list of integers) or List<Object> (a list of objects of any type). .
    Dart supports top-level functions (such as main()), as well as functions tied to a class or object .
    (static and instance methods, respectively). You can also create functions within functions (nested or local functions). .
    Similarly, Dart supports top-level variables, as well as variables tied to a class or object (static and instance variables). .
    Instance variables are sometimes known as fields or properties. .
    Unlike Java, Dart doesn’t have the keywords public, protected, and private. If an identifier starts with an underscore (_), .
    it’s private to its library. For details, see Libraries and imports. .
    Identifiers can start with a letter or underscore (_), followed by any combination of those characters plus digits. .
    Dart has both expressions (which have runtime values) and statements (which don’t). For example, .
    the conditional expression condition ? expr1 : expr2 has a value of expr1 or expr2. Compare that to an if-else statement, .
    which has no value. A statement often contains one or more expressions, but an expression can’t directly contain a statement. .

    Dart tools can report two kinds of problems: warnings and errors. Warnings are just indications that your code might not work, .
    but they don’t prevent your program from executing. Errors can be either compile-time or run-time. A compile-time error .
    prevents the code from executing at all; a run-time error results in an exception being raised while the code executes. .

...Additional resources

...More code samples are in the the library tour and the Dart API reference,. This site’s code follows the conventions in
...the Dart style guide.
