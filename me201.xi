all data in xi
transfer to the links
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

  STRATEGY: .
[GOD] .
[ME] .
[FAMELY] .
[BUSSINESS] .
[PASSWORD] .
[GIT] .
[PYTHON] .
[DART] .
[FLUTTER] .

 GOD: .

 ME: .
  animality: .
    self-actualization: .
     desire to become the most that one can be. .
    self-Esteem: .
     respect, self-esteem, recognition, strength, freedom. .
    love and belonging: .
     friendship, intimacy, famely, sense of connection. .
    safety and security: .
     personal security, employment, resources, health, property. .
    physiological need: .
     air, water, [food], shelter, sleep, clothing, reproduction. .
    food: .
    sx: .

  goals: .

  brain: .
    thinking circle: .
          001. the permorded deals.faster define the three deals for executing and doing it. .
          002. the base deals. define the three base deals for doing and doing it. .
          003. the important deals. define the three important deals and doing it. .
          004. Gods will. .
          005. english. .
          006. questions. .
          007. chess. .
          008. math. .
          009. repeat the base. .
          010. write program. .
          101. wash face. .
          102. straight up hair. .
          103. teethbrushing. .
          104. freshen up. .
          105. coffee. .
          106. teapot. .
          107. cough. .
          108. exersise. .
          109. Bible. .
          110. pray. .
          111. breakfast. .
          112. email. .
          113. plan. .
          114. question. .
          115. reading. .
          117. shoes. .
          118. dwelling order. .
          119. db_me. .
          120. dinner. .

    PASSWORD: .
    
          aliexpress https://seller.aliexpress.ru/  anatole.yakovlev@gmail.com  Asd25@# .
          avito novikov.timofey1952@gmail.com 8 995 839-59-17. firefox .
          avito 89096009912 . .
          avito .

    FOOD: .
     brain for brain: .
      spinach. .


  BUSSINESS .
    
    SANDBOX .

    INCUBATORS .

    CHILDHOSES .

    190.0 вагонка  22 штуки.
130.0 вагонка  12 шт.
144.0 вагонка 12 шт.
49.0 вагонка 10 шт.
49.5 вагонка 10 шт.
65.0 вагонка 6 шт.
17.5 вагонка 10 шт.
25.5 вагонка  11 шт.
39.5 вагонка  7 шт.
132.0 вагонка угол 2 шт.
116.0 вагонка угол 2 шт.
99.0 вагонка угол 2 шт.
83.0 вагонка угол 2 шт.
66.0 вагонка угол 2 шт.
50.0 вагонка угол 2 шт.
34.0 вагонка угол 2 шт.
18.0 вагонка угол 2 шт.
47.0 Рейка  4шт. 
41.5 рейка  6 шт.
30.0 рейка 2 шт.
100 40*40  6 шт.
95.0  угол 6 шт. 
183. 40*40 2 шт.
33.0 40*40 2 шт.
50.0 40*40 4 шт.
96.0 40*40 2 шт.
31.5 40*40 3 шт.
130.0 доска шпунтовая для пола.  17 шт.
Наличник 4 шт. По 2 метра.
ЦЕНА По комплекту с вагонкой стоимость будет 14250.  НА 23.07.2023

GIT: .
 sudo apt install git .
 git --version .
 sudo apt update .
 git init: initialisation of git .
 git config --global user.name "Your Name" .
 git config --global user.email "youremail@domain.com" .
 git config --list .
 git config --global core.editor "kate": install editor .
 git commit: make commit .
 nano: To make the commit you should write your commit message, then press ctrl+o to write your message, and then ctrl+x to exit that screen.
 git log: show history of commits .
 git branch: show whats branch .
 git branch updata_1: creating new branch(updata_1) .
 git checkout updata_1: swiching on new branch(updata_1)
 git checkout -b updata_1: create and swiching on new branch(updata_1) .
 git branh -D updata_1: delete branch .
 git add <>: add files in commit .
 git add.: add all in commit .
 git log --graph: show branchs(tree) .
 git merge <branch>: merging of branchs .
 git clone <https://github.com/Anti2000/car_parser.git> <car_parser> : make up clone from github to computor .
 git remote -v: show what is connect to computor.  .
 git remote add origin <https://github.com/Anti2000/example.git> add shotcut .
 git push origin master: add file to server  ??? .
 git pull origin main: update data from githup .
 https://stackoverflow.com/questions/1443210/updating-a-local-repository-with-changes-from-a-github-repository .
 git pull --rebase .
 Then I push the changes to a remote branch of the same name: .
 git push origin FixForBug .

  UBUNTU .
   linux commands: ls: List the contents of a folder. .
   ls -l : to see details like file size, permission, modified time, etc. .
   cd : Change the directory. .
   cd .. : go upper. .
   mkdir exemple: create directory. .
   rmdir exemple: delete directory. .
   lsb_release -a :know version of ubuntu. .
   cat <name file>> : open file. .
   cat < namefile : create file. .
   open Terminal in Linux: Using Shortcut(CTRL+ALT+T). .

  VC CODE .
   install vc code: .
   sudo snap install --classic code. .

FLUTTER .
  funcion main. .
 Every app requires the top-level main() function, where execution starts. .
 Functions that don’t explicitly return a value have the void return type. .
 To display text on the console, you can use the top-level print() function: .

| void main() {
|  print('Hello, World!');
| }

  Variables. .

 Even in type-safe Dart code, you can declare most variables without explicitly specifying their type using var. .
 Thanks to type inference, these variables’ types are determined by their initial values: .

| var name = 'Voyager I';
| var year = 1977;
| var antennaDiameter = 3.7;
| var flybyObjects = ['Jupiter', 'Saturn', 'Uranus', 'Neptune'];
| var image = {
|   'tags': ['saturn'],
|   'url': '//path/to/saturn.jpg'
| };

 Here’s an example of creating a variable and initializing it: .

| var name = 'Bob';

 Variables store references. The variable called name contains a reference to a String object with a value of “Bob”. .
 The type of the name variable is inferred to be String, but you can change that type by specifying it. .
 If an object isn’t restricted to a single type, specify the Object type (or dynamic if necessary). .

| Object name = 'Bob';

 Another option is to explicitly declare the type that would be inferred: .

| String name = 'Bob';

      Note: This page follows the style guide recommendation of using var, rather than type annotations, for local variables. .
    
    Null safety. .

The Dart language enforces sound null safety. .
 Null safety prevents an error that results from unintentional access of variables set to null. .
 The error is called a null dereference error. A null dereference error occurs when you access .
 a property or call a method on an expression that evaluates to null. .
 An exception to this rule is when null supports the property or method, like toString() or hashCode. .
 With null safety, the Dart compiler detects these potential errors at compile time. .
 For example, say you want to find the absolute value of an int variable i. .
 If i is null, calling i.abs() causes a null dereference error. In other languages, .
 trying this could lead to a runtime error, but Dart’s compiler prohibits these actions. .
 Therefore, Dart apps can’t cause runtime errors.

Null safety introduces three key changes: .
 When you specify a type for a variable, parameter, or another relevant component, .
 you can control whether the type allows null. To enable nullability, you add a ? .
 to the end of the type declaration. .
  String? name  // Nullable type. Can be `null` or string. .
  String name   // Non-nullable type. Cannot be `null` but can be string. .

 You must initialize variables before using them. Nullable variables default to null, .
 so they are initialized by default. Dart doesn’t set initial values to non-nullable types. .
 It forces you to set an initial value. Dart doesn’t allow you to observe an uninitialized variable. .
 This prevents you from accessing properties or calling methods where the receiver’s type can be null . .
 but null doesn’t support the method or property used. .
 You can’t access properties or call methods on an expression with a nullable type. The same exception applies where it’s a property or method that null supports like hashCode or toString(). .

 Sound null safety changes potential runtime errors into edit-time analysis errors. . 
 Null safety flags a non-null variable when it has been either: .

 Not initialized with a non-null value. .
 Assigned a null value. .

 This check allows you to fix these errors before deploying your app. .
 
  Default value. .

 Uninitialized variables that have a nullable type have an initial value of null. .
 Even variables with numeric types are initially null, because numbers—like everything else in Dart—are objects. .

| int? lineCount;
| assert(lineCount == null);

 Note: Production code ignores the assert() call. During development, on the other hand, .
 assert(condition) throws an exception if condition is false. For details, check out Assert. .

 With null safety, you must initialize the values of non-nullable variables before you use them: .

| int lineCount = 0;

 You don’t have to initialize a local variable where it’s declared, but you do need to assign it a value before it’s used. For example, the following code is valid because Dart can detect that lineCount is non-null by the time it’s passed to print(): .

| int lineCount;

| if (weLikeToCount) {
|  lineCount = countLines();
| } else {
|  lineCount = 0;
| }

| print(lineCount);

 Top-level and class variables are lazily initialized; the initialization code runs the first time the variable is used. .
  
  Late variables. .

 The late modifier has two use cases: .
 Declaring a non-nullable variable that’s initialized after its declaration. .
 Lazily initializing a variable. .

 Often Dart’s control flow analysis can detect when a non-nullable variable is set to a non-null value .
 before it’s used, but sometimes analysis fails. Two common cases are top-level variables and instance variables: .
 Dart often can’t determine whether they’re set, so it doesn’t try. .

 If you’re sure that a variable is set before it’s used, but Dart disagrees, .
 you can fix the error by marking the variable as late: .

| late String description;

| void main() {
|  description = 'Feijoada!';
|  print(description);
| }

 If you fail to initialize a late variable, a runtime error occurs when the variable is used. .
 When you mark a variable as late but initialize it at its declaration, .
 then the initializer runs the first time the variable is used. .
 This lazy initialization is handy in a couple of cases: .

 The variable might not be needed, and initializing it is costly. .
 You’re initializing an instance variable, and its initializer needs access to this. .

 In the following example, if the temperature variable is never used, .
 then the expensive readThermometer() function is never called: .

| // This is the program's only call to readThermometer().
| late String temperature = readThermometer(); // Lazily initialized.

 Final and const. .

 If you never intend to change a variable, use final or const, either instead of var or in addition to a type. .
 A final variable can be set only once; a const variable is a compile-time constant. (Const variables are implicitly final.) .

 Note: Instance variables can be final but not const. .

 Here’s an example of creating and setting a final variable: .

| final name = 'Bob'; // Without a type annotation
| final String nickname = 'Bobby';

 You can’t change the value of a final variable: .

| name = 'Alice'; // Error: a final variable can only be set once.

 Use const for variables that you want to be compile-time constants. If the const variable is at the class level, .
 mark it static const. Where you declare the variable, set the value to a compile-time constant such as a number .
 or string literal, a const variable, or the result of an arithmetic operation on constant numbers: .

| const bar = 1000000; // Unit of pressure (dynes/cm2)
| const double atm = 1.01325 * bar; // Standard atmosphere

 The const keyword isn’t just for declaring constant variables. You can also use it to create constant values, .
 as well as to declare constructors that create constant values. Any variable can have a constant value. .

| var foo = const [];
| final bar = const [];
| const baz = []; // Equivalent to `const []`

 You can omit const from the initializing expression of a const declaration, like for baz above. For details, .
 see DON’T use const redundantly. .

 You can change the value of a non-final, non-const variable, even if it used to have a const value: .

| foo = [1, 2, 3]; // Was const []

 You can’t change the value of a const variable: .

| baz = [42]; // Error: Constant variables can't be assigned a value.

You can define constants that use type checks and casts (is and as), collection if, and spread operators .
(... and ...?): .

| const Object i = 3; // Where i is a const Object with an int value...
| const list = [i as int]; // Use a typecast.
| const map = {if (i is int) i: 'int'}; // Use is and collection if.
| const set = {if (list is List<int>) ...list}; // ...and a spread.

 Note: Although a final object cannot be modified, its fields can be changed. In comparison, .
 a const object and its fields cannot be changed: they’re immutable. .

 For more information on using const to create constant values, see Lists, Maps, and Classes. .

  Operators. .

 Dart supports the operators shown in the following table. The table shows Dart’s operator associativity .
 and operator precedence from highest to lowest, which are an approximation of Dart’s operator relationships. .
 You can implement many of these operators as class members. .

| Description 	            Operator 	                                                    Associativity
| unary postfix 	          expr++    expr--    ()    []    ?[]    .    ?.    ! 	        None
| unary prefix 	            -expr    !expr    ~expr    ++expr    --expr      await expr   None
| multiplicative 	          *    /    %  ~/ 	                                            Left
| additive 	                +    - 	                                                      Left
| shift 	                  <<    >>    >>> 	                                            Left
| bitwise AND 	            & 	                                                          Left
| bitwise XOR 	            ^ 	                                                          Left
| bitwise OR 	              | 	                                                          Left
| relational and type test 	>=    >    <=    <    as    is    is! 	                      None
| equality 	                ==    !=    	                                                None
| logical AND 	            && 	                                                          Left
| logical OR              	|| 	                                                          Left
| if null 	                ?? 	                                                          Left
| conditional             	expr1 ? expr2 : expr3 	                                      Right
| cascade                  	..    ?.. 	                                                  Left
| assignment               	=    *=    /=   +=   -=   &=   ^=   etc. 	                    Right

 Warning: The previous table should only be used as a helpful guide. The notion of operator precedence and .
 associativity is an approximation of the truth found in the language grammar. You can find the authoritative .
 behavior of Dart’s operator relationships in the grammar defined in the Dart language specification. .

 When you use operators, you create expressions. Here are some examples of operator expressions: .

| a++
| a + b
| a = b
| a == b
| c ? a : b
| a is T

  Operator precedence example. .

 In the operator table, each operator has higher precedence than the operators in the rows that follow it. .
 For example, the multiplicative operator % has higher precedence than (and thus executes before) the equality. .
 operator ==, which has higher precedence than the logical AND operator &&. That precedence means that .
 the following two lines of code execute the same way: .

| // Parentheses improve readability.
| if ((n % i == 0) && (d % i == 0)) ...

| // Harder to read, but equivalent.
| if (n % i == 0 && d % i == 0) ...

 Warning: For operators that take two operands, the leftmost operand determines which method is used. .
 For example, if you have a Vector object and a Point object, then aVector + aPoint uses Vector addition (+). .
 

  Arithmetic operators. .

 Dart supports the usual arithmetic operators, as shown in the following table. .

| Operator 	Meaning
| + 	      Add
| - 	      Subtract
| -expr 	  Unary minus, also known as negation (reverse the sign of the expression)
| *        	Multiply
| /        	Divide
| ~/        Divide, returning an integer result
| %       	Get the remainder of an integer division (modulo)

 Example: .

| assert(2 + 3 == 5);
| assert(2 - 3 == -1);
| assert(2 * 3 == 6);
| assert(5 / 2 == 2.5); // Result is a double
| assert(5 ~/ 2 == 2); // Result is an int
| assert(5 % 2 == 1); // Remainder

| assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');

 Dart also supports both prefix and postfix increment and decrement operators. .

| Operator 	Meaning
| ++var    	var = var + 1 (expression value is var + 1)
| var++ 	  var = var + 1 (expression value is var)
| --var 	  var = var - 1 (expression value is var - 1)
| var-- 	  var = var - 1 (expression value is var)

 Example: .

| int a;
| int b;

| a = 0;
| b = ++a; // Increment a before b gets its value.
| assert(a == b); // 1 == 1

| a = 0;
| b = a++; // Increment a after b gets its value.
| assert(a != b); // 1 != 0

| a = 0;
| b = --a; // Decrement a before b gets its value.
| assert(a == b); // -1 == -1

| a = 0;
| b = a--; // Decrement a after b gets its value.
| assert(a != b); // -1 != 0

 Equality and relational operators. .

 The following table lists the meanings of equality and relational operators. .

| Operator 	Meaning
| ==       	Equal; see discussion below
| !=      	Not equal
| >        	Greater than
| <        	Less than
| >=      	Greater than or equal to
| <=      	Less than or equal to

 To test whether two objects x and y represent the same thing, use the == operator. .
 (In the rare case where you need to know whether two objects are the exact same object, .
 use the identical() function instead.) Here’s how the == operator works: .

 If x or y is null, return true if both are null, and false if only one is null. .

 Return the result of invoking the == method on x with the argument y. (That’s right, operators .
 such as == are methods that are invoked on their first operand. For details, see Operators.). .

 Here’s an example of using each of the equality and relational operators: .

| assert(2 == 2);
| assert(2 != 3);
| assert(3 > 2);
| assert(2 < 3);
| assert(3 >= 3);
| assert(2 <= 3);

  Type test operators. .

 The as, is, and is! operators are handy for checking types at runtime. .

| Operator 	Meaning
| as 	Typecast (also used to specify library prefixes)
| is 	True if the object has the specified type
| is! 	True if the object doesn’t have the specified type

 The result of obj is T is true if obj implements the interface specified by T. For example, obj is Object? .
 is always true. .

 Use the as operator to cast an object to a particular type if and only if you are sure that the object .
 is of that type. Example: .

| (employee as Person).firstName = 'Bob';

 If you aren’t sure that the object is of type T, then use is T to check the type before using the object. .

| if (employee is Person) {
|   // Type check
|   employee.firstName = 'Bob';
| }

 Note: The code isn’t equivalent. If employee is null or not a Person, the first example throws an exception; .
 the second does nothing. .

  Assignment operators. .

 As you’ve already seen, you can assign values using the = operator. To assign only if the assigned-to .
 variable is null, use the ??= operator. .

| // Assign value to a
| a = value;
| // Assign value to b if b is null; otherwise, b stays the same
| b ??= value;

 Compound assignment operators such as += combine an operation with an assignment. .
| = 	    *= 	    %= 	     >>>= 	   ^=
| += 	    /=    	<<=     	&=       |=
| -= 	    ~/=   	>>= 	  	 

 Here’s how compound assignment operators work: .

|                        	Compound assignment 	Equivalent expression
| For an operator op:   	a op= b              	a = a op b
| Example:              	a += b               	a = a + b

 The following example uses assignment and compound assignment operators: .

| var a = 2; // Assign using =
| a *= 3; // Assign and multiply: a = a * 3
| assert(a == 6);

  Logical operators. .

 You can invert or combine boolean expressions using the logical operators. .

| Operator 	Meaning
| !expr   	inverts the following expression (changes false to true, and vice versa)
| || 	      logical OR
| && 	      logical AND 

 Here’s an example of using the logical operators: .

| if (!done && (col == 0 || col == 3)) {
|   // ...Do something...
| }

  Bitwise and shift operators. .

 You can manipulate the individual bits of numbers in Dart. Usually, you’d use these bitwise and shift .
 operators with integers. .

| Operator 	Meaning
|  &       	AND
|  | 	      OR
|  ^ 	      XOR
|  ~expr 	  Unary bitwise complement (0s become 1s; 1s become 0s)
|  << 	    Shift left
|  >> 	    Shift right
|  >>> 	    Unsigned shift right

 Note: The behavior of bitwise operations with large or negative operands might differ between platforms. .
 To learn more, check out Bitwise operations platform differences. .

 Here’s an example of using bitwise and shift operators: .

| final value = 0x22;
| final bitmask = 0x0f;

| assert((value & bitmask) == 0x02); // AND
| assert((value & ~bitmask) == 0x20); // AND NOT
| assert((value | bitmask) == 0x2f); // OR
| assert((value ^ bitmask) == 0x2d); // XOR

| assert((value << 4) == 0x220); // Shift left
| assert((value >> 4) == 0x02); // Shift right

| // Shift right example that results in different behavior on web
| // because the operand value changes when masked to 32 bits:
| assert((-value >> 4) == -0x03);

| assert((value >>> 4) == 0x02); // Unsigned shift right
| assert((-value >>> 4) > 0); // Unsigned shift right

 Version note: The >>> operator (known as triple-shift or unsigned shift) requires a language version of at .
 least 2.14. .

  Conditional expressions. .

 Dart has two operators that let you concisely evaluate expressions that might otherwise require if-else .
 statements: .

| condition ? expr1 : expr2
 If condition is true, evaluates expr1 (and returns its value); otherwise, evaluates and returns the value .
 of expr2. .

| expr1 ?? expr2
 If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2. .

 When you need to assign a value based on a boolean expression, consider using ? and : .
| var visibility = isPublic ? 'public' : 'private';

 If the boolean expression tests for null, consider using ??. .

| String playerName(String? name) => name ?? 'Guest';

 The previous example could have been written at least two other ways, but not as succinctly: .

| // Slightly longer version uses ?: operator.
| String playerName(String? name) => name != null ? name : 'Guest';

| // Very long version uses if-else statement.
| String playerName(String? name) {
|   if (name != null) {
|     return name;
|   } else {
|     return 'Guest';
|   }
| }

  Cascade notation. .

 Cascades (.., ?..) allow you to make a sequence of operations on the same object. In addition to accessing .
 instance members, you can also call instance methods on that same object. This often saves you the step of .
 creating a temporary variable and allows you to write more fluid code. .

 Consider the following code: .

| var paint = Paint()
|   ..color = Colors.black
|   ..strokeCap = StrokeCap.round
|   ..strokeWidth = 5.0;

 The constructor, Paint(), returns a Paint object. The code that follows the cascade notation operates .
 on this object, ignoring any values that might be returned. .

 The previous example is equivalent to this code: .

| var paint = Paint();
| paint.color = Colors.black;
| paint.strokeCap = StrokeCap.round;
| paint.strokeWidth = 5.0;

 If the object that the cascade operates on can be null, then use a null-shorting cascade (?..) .
 for the first operation. Starting with ?.. guarantees that none of the cascade operations are .
 attempted on that null object. .

| querySelector('#confirm') // Get an object.
|   ?..text = 'Confirm' // Use its members.
|   ..classes.add('important')
|   ..onClick.listen((e) => window.alert('Confirmed!'))
|   ..scrollIntoView();

 Version note: The ?.. syntax requires a language version of at least 2.12. .

 The previous code is equivalent to the following: .

| var button = querySelector('#confirm');
| button?.text = 'Confirm';
| button?.classes.add('important');
| button?.onClick.listen((e) => window.alert('Confirmed!'));
| button?.scrollIntoView();

You can also nest cascades. For example: .

| final addressBook = (AddressBookBuilder()
|       ..name = 'jenny'
|       ..email = 'jenny@example.com'
|       ..phone = (PhoneNumberBuilder()
|             ..number = '415-555-0100'
|             ..label = 'home')
|           .build())
|     .build();

 Be careful to construct your cascade on a function that returns an actual object. For example, .
 the following code fails: .

| var sb = StringBuffer();
| sb.write('foo')
|   ..write('bar'); // Error: method 'write' isn't defined for 'void'.

 The sb.write() call returns void, and you can’t construct a cascade on void. .

 Note: Strictly speaking, the “double dot” notation for cascades isn’t an operator. .
 It’s just part of the Dart syntax. .
 
  Other operators. .

 You’ve seen most of the remaining operators in other examples: .

| Operator 	Name                   	      Meaning
|   ()     	Function application 	        Represents a function call
|   [] 	    Subscript access 	            Represents a call to the overridable [] operator; example: fooList[1] passes the int 1 to fooList to access the element at index 1
|   ?[] 	  Conditional subscript access 	Like [], but the leftmost operand can be null; example: fooList?[1] passes the int 1 to fooList to access the element at index 1 unless fooList is null (in which case the expression evaluates to null)
|   . 	    Member access               	Refers to a property of an expression; example: foo.bar selects property bar from expression foo
|   ?. 	    Conditional member access   	Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)
|   ! 	    Null assertion operator 	     Casts an expression to its underlying non-nullable type, throwing a runtime exception if the cast fails; example: foo!.bar asserts foo is non-null and selects the property bar, unless foo is null in which case a runtime exception is thrown


Comments

Dart supports single-line comments, multi-line comments, and documentation comments.
Single-line comments

A single-line comment begins with //. Everything between // and the end of line is ignored by the Dart compiler.

void main() {
  // TODO: refactor into an AbstractLlamaGreetingFactory?
  print('Welcome to my Llama farm!');
}

Multi-line comments

A multi-line comment begins with /* and ends with */. Everything between /* and */ is ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). Multi-line comments can nest.

void main() {
  /*
   * This is a lot of work. Consider raising chickens.

  Llama larry = Llama();
  larry.feed();
  larry.exercise();
  larry.clean();
   */
}

Documentation comments

Documentation comments are multi-line or single-line comments that begin with /// or /**. Using /// on consecutive lines has the same effect as a multi-line doc comment.

Inside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level variables, functions, and parameters. The names in brackets are resolved in the lexical scope of the documented program element.

Here is an example of documentation comments with references to other classes and arguments:

/// A domesticated South American camelid (Lama glama).
///
/// Andean cultures have used llamas as meat and pack
/// animals since pre-Hispanic times.
///
/// Just like any other animal, llamas need to eat,
/// so don't forget to [feed] them some [Food].
class Llama {
  String? name;

  /// Feeds your llama [food].
  ///
  /// The typical llama eats one bale of hay per week.
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}

In the class’s generated documentation, [feed] becomes a link to the docs for the feed method, and [Food] becomes a link to the docs for the Food class.

To parse Dart code and generate HTML documentation, you can use Dart’s documentation generation tool, dart doc. For an example of generated documentation, see the Dart API documentation. For advice on how to structure your comments, see Effective Dart: Documentation.
 
 Metadata

Use metadata to give additional information about your code. A metadata annotation begins with the character @, followed by either a reference to a compile-time constant (such as deprecated) or a call to a constant constructor.

Three annotations are available to all Dart code: @Deprecated, @deprecated, and @override. For examples of using @override, see Extending a class. Here’s an example of using the @Deprecated annotation:

class Television {
  /// Use [turnOn] to turn the power on instead.
  @Deprecated('Use turnOn instead')
  void activate() {
    turnOn();
  }

  /// Turns the TV's power on.
  void turnOn() {...}
  // ···
}

You can define your own metadata annotations. Here’s an example of defining a @Todo annotation that takes two arguments:

class Todo {
  final String who;
  final String what;

  const Todo(this.who, this.what);
}

And here’s an example of using that @Todo annotation:

@Todo('Dash', 'Implement this function')
void doSomething() {
  print('Do something');
}

Metadata can appear before a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive. You can retrieve metadata at runtime using reflection.
 
Libraries & imports

The import and library directives can help you create a modular and shareable code base. Libraries not only provide APIs, but are a unit of privacy: identifiers that start with an underscore (_) are visible only inside the library. Every Dart file (plus its parts) is a library, even if it doesn’t use a library directive.

Libraries can be distributed using packages.

If you’re curious why Dart uses underscores instead of access modifier keywords like public or private, see SDK issue 33383.
Using libraries

Use import to specify how a namespace from one library is used in the scope of another library.

For example, Dart web apps generally use the dart:html library, which they can import like this:

import 'dart:html';

The only required argument to import is a URI specifying the library. For built-in libraries, the URI has the special dart: scheme. For other libraries, you can use a file system path or the package: scheme. The package: scheme specifies libraries provided by a package manager such as the pub tool. For example:

import 'package:test/test.dart';

Note: URI stands for uniform resource identifier. URLs (uniform resource locators) are a common kind of URI.
Specifying a library prefix

If you import two libraries that have conflicting identifiers, then you can specify a prefix for one or both libraries. For example, if library1 and library2 both have an Element class, then you might have code like this:

import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;

// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();

Importing only part of a library

If you want to use only part of a library, you can selectively import the library. For example:

// Import only foo.
import 'package:lib1/lib1.dart' show foo;

// Import all names EXCEPT foo.
import 'package:lib2/lib2.dart' hide foo;

Lazily loading a library

Deferred loading (also called lazy loading) allows a web app to load a library on demand, if and when the library is needed. Here are some cases when you might use deferred loading:

    To reduce a web app’s initial startup time.
    To perform A/B testing—trying out alternative implementations of an algorithm, for example.
    To load rarely used functionality, such as optional screens and dialogs.

Only dart compile js supports deferred loading. Flutter and the Dart VM don’t support deferred loading. To learn more, see issue #33118 and issue #27776.

To lazily load a library, you must first import it using deferred as.

import 'package:greetings/hello.dart' deferred as hello;

When you need the library, invoke loadLibrary() using the library’s identifier.

Future<void> greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}

In the preceding code, the await keyword pauses execution until the library is loaded. For more information about async and await, see asynchrony support.

You can invoke loadLibrary() multiple times on a library without problems. The library is loaded only once.

Keep in mind the following when you use deferred loading:

    A deferred library’s constants aren’t constants in the importing file. Remember, these constants don’t exist until the deferred library is loaded.
    You can’t use types from a deferred library in the importing file. Instead, consider moving interface types to a library imported by both the deferred library and the importing file.
    Dart implicitly inserts loadLibrary() into the namespace that you define using deferred as namespace. The loadLibrary() function returns a Future.

The library directive

To specify library-level doc comments or metadata annotations, attach them to a library declaration at the start of the file.

/// A really great test library.
@TestOn('browser')
library;


Keywords

The following table lists the words that the Dart language treats specially.
abstract 2 	else 	import 2 	show 1
as 2 	enum 	in 	static 2
assert 	export 2 	interface 2 	super
async 1 	extends 	is 	switch
await 3 	extension 2 	late 2 	sync 1
base 2 	external 2 	library 2 	this
break 	factory 2 	mixin 2 	throw
case 	false 	new 	true
catch 	final (variable) 	null 	try
class 	final (class) 2 	on 1 	typedef 2
const 	finally 	operator 2 	var
continue 	for 	part 2 	void
covariant 2 	Function 2 	required 2 	when
default 	get 2 	rethrow 	while
deferred 2 	hide 1 	return 	with
do 	if 	sealed 2 	yield 3
dynamic 2 	implements 2 	set 2 	 

Avoid using these words as identifiers. However, if necessary, the keywords marked with superscripts can be identifiers:

    Words with the superscript 1 are contextual keywords, which have meaning only in specific places. They’re valid identifiers everywhere.

    Words with the superscript 2 are built-in identifiers. These keywords are valid identifiers in most places, but they can’t be used as class or type names, or as import prefixes.

    Words with the superscript 3 are limited reserved words related to asynchrony support. You can’t use await or yield as an identifier in any function body marked with async, async*, or sync*.

All other words in the table are reserved words, which can’t be identifiers.


Built-in types

The Dart language has special support for the following:

    Numbers (int, double)
    Strings (String)
    Booleans (bool)
    Records ((value1, value2))
    Lists (List, also known as arrays)
    Sets (Set)
    Maps (Map)
    Runes (Runes; often replaced by the characters API)
    Symbols (Symbol)
    The value null (Null)

This support includes the ability to create objects using literals. For example, 'this is a string' is a string literal, and true is a boolean literal.

Because every variable in Dart refers to an object—an instance of a class—you can usually use constructors to initialize variables. Some of the built-in types have their own constructors. For example, you can use the Map() constructor to create a map.

Some other types also have special roles in the Dart language:

    Object: The superclass of all Dart classes except Null.
    Enum: The superclass of all enums.
    Future and Stream: Used in asynchrony support.
    Iterable: Used in for-in loops and in synchronous generator functions.
    Never: Indicates that an expression can never successfully finish evaluating. Most often used for functions that always throw an exception.
    dynamic: Indicates that you want to disable static checking. Usually you should use Object or Object? instead.
    void: Indicates that a value is never used. Often used as a return type.

The Object, Object?, Null, and Never classes have special roles in the class hierarchy. Learn about these roles in Understanding null safety.
Numbers

Dart numbers come in two flavors:

int

    Integer values no larger than 64 bits, depending on the platform. On native platforms, values can be from -263 to 263 - 1. On the web, integer values are represented as JavaScript numbers (64-bit floating-point values with no fractional part) and can be from -253 to 253 - 1.
double

    64-bit (double-precision) floating-point numbers, as specified by the IEEE 754 standard.

Both int and double are subtypes of num. The num type includes basic operators such as +, -, /, and *, and is also where you’ll find abs(), ceil(), and floor(), among other methods. (Bitwise operators, such as >>, are defined in the int class.) If num and its subtypes don’t have what you’re looking for, the dart:math library might.

Integers are numbers without a decimal point. Here are some examples of defining integer literals:

var x = 1;
var hex = 0xDEADBEEF;

If a number includes a decimal, it is a double. Here are some examples of defining double literals:

var y = 1.1;
var exponents = 1.42e5;

You can also declare a variable as a num. If you do this, the variable can have both integer and double values.

num x = 1; // x can have both int and double values
x += 2.5;

Integer literals are automatically converted to doubles when necessary:

double z = 1; // Equivalent to double z = 1.0.

Here’s how you turn a string into a number, or vice versa:

// String -> int
var one = int.parse('1');
assert(one == 1);

// String -> double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -> String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -> String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');

The int type specifies the traditional bitwise shift (<<, >>, >>>), complement (~), AND (&), OR (|), and XOR (^) operators, which are useful for manipulating and masking flags in bit fields. For example:

assert((3 << 1) == 6); // 0011 << 1 == 0110
assert((3 | 4) == 7); // 0011 | 0100 == 0111
assert((3 & 4) == 0); // 0011 & 0100 == 0000

For more examples, see the bitwise and shift operator section.

Literal numbers are compile-time constants. Many arithmetic expressions are also compile-time constants, as long as their operands are compile-time constants that evaluate to numbers.

const msPerSecond = 1000;
const secondsUntilRetry = 5;
const msUntilRetry = secondsUntilRetry * msPerSecond;

For more information, see Numbers in Dart.
Strings

A Dart string (String object) holds a sequence of UTF-16 code units. You can use either single or double quotes to create a string:

var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";

You can put the value of an expression inside a string by using ${expression}. If the expression is an identifier, you can skip the {}. To get the string corresponding to an object, Dart calls the object’s toString() method.

var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
    'Dart has string interpolation, '
        'which is very handy.');
assert('That deserves all caps. '
        '${s.toUpperCase()} is very handy!' ==
    'That deserves all caps. '
        'STRING INTERPOLATION is very handy!');

Note: The == operator tests whether two objects are equivalent. Two strings are equivalent if they contain the same sequence of code units.

You can concatenate strings using adjacent string literals or the + operator:

var s1 = 'String '
    'concatenation'
    " works even over line breaks.";
assert(s1 ==
    'String concatenation works even over '
        'line breaks.');

var s2 = 'The + operator ' + 'works, as well.';
assert(s2 == 'The + operator works, as well.');

Another way to create a multi-line string: use a triple quote with either single or double quotation marks:

var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";

You can create a “raw” string by prefixing it with r:

var s = r'In a raw string, not even \n gets special treatment.';

See Runes and grapheme clusters for details on how to express Unicode characters in a string.

Literal strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value.

// These work in a const string.
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'a constant string';

// These do NOT work in a const string.
var aNum = 0;
var aBool = true;
var aString = 'a string';
const aConstList = [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString';
// const invalidConstString = '$aNum $aBool $aString $aConstList';

For more information on using strings, check out Strings and regular expressions.
Booleans

To represent boolean values, Dart has a type named bool. Only two objects have type bool: the boolean literals true and false, which are both compile-time constants.

Dart’s type safety means that you can’t use code like if (nonbooleanValue) or assert (nonbooleanValue). Instead, explicitly check for values, like this:

// Check for an empty string.
var fullName = '';
assert(fullName.isEmpty);

// Check for zero.
var hitPoints = 0;
assert(hitPoints <= 0);

// Check for null.
var unicorn = null;
assert(unicorn == null);

// Check for NaN.
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);

Runes and grapheme clusters

In Dart, runes expose the Unicode code points of a string. You can use the characters package to view or manipulate user-perceived characters, also known as Unicode (extended) grapheme clusters.

Unicode defines a unique numeric value for each letter, digit, and symbol used in all of the world’s writing systems. Because a Dart string is a sequence of UTF-16 code units, expressing Unicode code points within a string requires special syntax. The usual way to express a Unicode code point is \uXXXX, where XXXX is a 4-digit hexadecimal value. For example, the heart character (♥) is \u2665. To specify more or less than 4 hex digits, place the value in curly brackets. For example, the laughing emoji (😆) is \u{1f606}.

If you need to read or write individual Unicode characters, use the characters getter defined on String by the characters package. The returned Characters object is the string as a sequence of grapheme clusters. Here’s an example of using the characters API:

import 'package:characters/characters.dart';

void main() {
  var hi = 'Hi 🇩🇰';
  print(hi);
  print('The end of the string: ${hi.substring(hi.length - 1)}');
  print('The last character: ${hi.characters.last}');
}

The output, depending on your environment, looks something like this:

 dart run bin/main.dart
Hi 🇩🇰
The end of the string: ???
The last character: 🇩🇰

For details on using the characters package to manipulate strings, see the example and API reference for the characters package.
Symbols

A Symbol object represents an operator or identifier declared in a Dart program. You might never need to use symbols, but they’re invaluable for APIs that refer to identifiers by name, because minification changes identifier names but not identifier symbols.

To get the symbol for an identifier, use a symbol literal, which is just # followed by the identifier:

#radix
#bar

Symbol literals are compile-time constants.

  Control flow statements. .

 Dart supports the usual control flow statements: .

| if (year >= 2001) {
|   print('21st century');
| } else if (year >= 1901) {
|   print('20th century');
| }

| for (final object in flybyObjects) {
|   print(object);
| }

| for (int month = 1; month <= 12; month++) {
|   print(month);
| }

| while (year < 2016) {
|   year += 1;
| }

  Functions. .
 We recommend specifying the types of each function’s arguments and return value: .

| int fibonacci(int n) {
|   if (n == 0 || n == 1) return n;
|   return fibonacci(n - 1) + fibonacci(n - 2);
| }

| var result = fibonacci(20);

 A shorthand => (arrow) syntax is handy for functions that contain a single statement. .
 This syntax is especially useful when passing anonymous functions as arguments: .
 
 | flybyObjects.where((name) => name.contains('turn')).forEach(print);

 Besides showing an anonymous function (the argument to where()), this code shows that you can use a function as an argument: .
 the top-level print() function is an argument to forEach(). .

  Loops. .

 This page shows how you can control the flow of your Dart code using loops and supporting statements: .

for loops .
while and do while loops .
break and continue .

 You can also manipulate control flow in Dart using: .

Branching, like if and switch .
Exceptions, like try, catch, and throw. .

  For loops. .

 You can iterate with the standard for loop. For example: .

| var message = StringBuffer('Dart is fun');
| for (var i = 0; i < 5; i++) {
|  message.write('!');
| }

 Closures inside of Dart’s for loops capture the value of the index. This avoids a common pitfall .
 found in JavaScript. For example, consider: .

| var callbacks = [];
| for (var i = 0; i < 2; i++) {
|   callbacks.add(() => print(i));
| }

| for (final c in callbacks) {
|   c();
| }

 The output is 0 and then 1, as expected. In contrast, the example would print 2 and then 2 in JavaScript. .

 Sometimes you might not need to know the current iteration counter when iterating over an Iterable type, .
 like List or Set. In that case, use the for-in loop for cleaner code: .

| for (final candidate in candidates) {
|   candidate.interview();
| }

 To process the values obtained from the iterable, you can also use a pattern in a for-in loop: .

| for (final Candidate(:name, :yearsExperience) in candidates) {
|   print('$name has $yearsExperience of experience.');
| }

 Tip: To practice using for-in, follow the Iterable collections codelab. .

 Iterable classes also have a forEach() method as another option: .

| var collection = [1, 2, 3];
| collection.forEach(print); // 1 2 3

  While and do-while. .

 A while loop evaluates the condition before the loop: .

| while (!isDone()) {
|   doSomething();
| }

 A do-while loop evaluates the condition after the loop: .

| do {
|   printLine();
| } while (!atEndOfPage());

 Break and continue. .

 Use break to stop looping: .

| while (true) {
|   if (shutDownRequested()) break;
|   processIncomingRequests();
| }

 Use continue to skip to the next loop iteration: .

| for (int i = 0; i < candidates.length; i++) {
|   var candidate = candidates[i];
|   if (candidate.yearsExperience < 5) {
|     continue;
|   }
|   candidate.interview();
| }

 If you’re using an Iterable such as a list or set, how you write the previous example might differ: .

| candidates
|     .where((c) => c.yearsExperience >= 5)
|     .forEach((c) => c.interview());

  Branches. .

 This page shows how you can control the flow of your Dart code using branches: .

if statements and elements .
if-case statements and elements .
switch statements and expressions .

 You can also manipulate control flow in Dart using: .

Loops, like for and while .
Exceptions, like try, catch, and throw .

  If. .

 Dart supports if statements with optional else clauses. The condition in parentheses after .
 if must be an expression that evaluates to a boolean: .

| if (isRaining()) {
|   you.bringRainCoat();
| } else if (isSnowing()) {
|   you.wearJacket();
| } else {
|   car.putTopDown();
| }

 To learn how to use if in an expression context, check out Conditional expressions. .

  If-case. .

 Dart if statements support case clauses followed by a pattern: .

| if (pair case [int x, int y]) return Point(x, y);

 If the pattern matches the value, then the branch executes with any variables the pattern defines in scope. .

 In the previous example, the list pattern [int x, int y] matches the value pair, .
 so the branch return Point(x, y) executes with the variables that the pattern defined, x and y. .

 Otherwise, control flow progresses to the else branch to execute, if there is one: .

| if (pair case [int x, int y]) {
|   print('Was coordinate array $x,$y');
| } else {
|   throw FormatException('Invalid coordinates.');
| }

 The if-case statement provides a way to match and destructure against a single pattern. .
 To test a value against multiple patterns, use switch. .

 Version note: Case clauses in if statements require a language version of at least 3.0. .

  Switch statements. .

 A switch statement evaluates a value expression against a series of cases. .
 Each case clause is a pattern for the value to match against. You can use any kind of pattern for a case. .

 When the value matches a case’s pattern, the case body executes. .Non-empty case clauses jump to the end .
 of the switch after completion. They do not require a break statement. Other valid ways to end .
 a non-empty case clause are a continue, throw, or return statement. .
 
 Use a default or wildcard _ clause to execute code when no case clause matches: .

| var command = 'OPEN';
| switch (command) {
|   case 'CLOSED':
|     executeClosed();
|   case 'PENDING':
|     executePending();
|   case 'APPROVED':
|     executeApproved();
|   case 'DENIED':
|     executeDenied();
|   case 'OPEN':
|     executeOpen();
|   default:
|     executeUnknown();
| }

 Empty cases fall through to the next case. For an empty case that does not fall through, .
 use break for its body. For non-sequential fall-through, you can use a continue statement and a label: .

| switch (command) {
|   case 'OPEN':
|     executeOpen();
|     continue newCase; // Continues executing at the newCase label.
| 
|   case 'DENIED': // Empty case falls through.
|   case 'CLOSED':
|     executeClosed(); // Runs for both DENIED and CLOSED,
| 
|   newCase:
|   case 'PENDING':
|     executeNowClosed(); // Runs for both OPEN and PENDING.
| }

 You can use logical-or patterns to allow cases to share a body or a guard. To learn more about patterns .
 and case clauses, check out the patterns documentation on Switch statements and expressions. .

  Switch expressions. .

 A switch expression produces a value based on the expression body of whichever case matches. .
 You can use a switch expression wherever Dart allows expressions, except at the start of an .
 expression statement. For example: .

| var x = switch (y) { ... };
| 
| print(switch (x) { ... });
| 
| return switch (x) { ... };

 If you want to use a switch at the start of an expression statement, use a switch statement. .

 Switch expressions allow you to rewrite a switch statement like this: .

| // Where slash, star, comma, semicolon, etc., are constant variables...
| switch (charCode) {
|   case slash || star || plus || minus: // Logical-or pattern
|     token = operator(charCode);
|   case comma || semicolon: // Logical-or pattern
|     token = punctuation(charCode);
|   case >= digit0 && <= digit9: // Relational and logical-and patterns
|     token = number();
|   default:
|     throw FormatException('Invalid');
| }

 Into an expression, like this: .

| token = switch (charCode) {
|   slash || star || plus || minus => operator(charCode),
|   comma || semicolon => punctuation(charCode),
|   >= digit0 && <= digit9 => number(),
|   _ => throw FormatException('Invalid')
| };

 The syntax of a switch expression differs from switch statement syntax: .

Cases do not start with the case keyword. .
A case body is a single expression instead of a series of statements. .
Each case must have a body; there is no implicit fallthrough for empty cases. .
Case patterns are separated from their bodies using => instead of :. .
Cases are separated by , (and an optional trailing , is allowed). .
Default cases can only use _, instead of allowing both default and _. .

 Version note: Switch expressions require a language version of at least 3.0. .

  Exhaustiveness checking. .

 Exhaustiveness checking is a feature that reports a compile-time error if it’s possible .
 for a value to enter a switch but not match any of the cases. .

| // Non-exhaustive switch on bool?, missing case to match null possibility:
| switch (nullableBool) {
|   case true:
|     print('yes');
|   case false:
|     print('no');
| }

 A default case (default or _) covers all possible values that can flow through a switch. .
 This makes a switch on any type exhaustive. .

 Enums and sealed types are particularly useful for switches because, even without a default case, .
 their possible values are known and fully enumerable. Use the sealed modifier on a class to enable .
 exhaustiveness checking when switching over subtypes of that class: .

| sealed class Shape {}

| class Square implements Shape {
|   final double length;
|   Square(this.length);
| }

| class Circle implements Shape {
|   final double radius;
|   Circle(this.radius);
| }

| double calculateArea(Shape shape) => switch (shape) {
|       Square(length: var l) => l * l,
|       Circle(radius: var r) => math.pi * r * r
|     };

 If anyone were to add a new subclass of Shape, this switch expression would be incomplete. .
 Exhaustiveness checking would inform you of the missing subtype. This allows you to use Dart .
 in a somewhat functional algebraic datatype style. .

  Guard clause. .

 To set an optional guard clause after a case clause, use the keyword when. A guard clause can follow if case, .
 and both switch statements and expressions. .

| switch (pair) {
|   case (int a, int b) when a > b:
|     print('First element greater');
|   case (int a, int b):
|     print('First element not greater');
| }

 Guards evaluate an arbitrary boolean expression after matching. This allows you to add further constraints .
 on whether a case body should execute. When the guard clause evaluates to false, execution proceeds .
 to the next case rather than exiting the entire switch. .

  Comments. .

 Dart comments usually start with //. .

| // This is a normal, one-line comment.

| /// This is a documentation comment, used to document libraries,
| /// classes, and their members. Tools like IDEs and dartdoc treat
| /// doc comments specially.

| /* Comments like these are also supported. */

  Imports. .

 To access APIs defined in other libraries, use import. .

| // Importing core libraries
| import 'dart:math';

| // Importing libraries from external packages
| import 'package:test/test.dart';

| // Importing files
| import 'path/to/my_other_file.dart';

  Classes. .

 Here’s an example of a class with three properties, two constructors, and a method. .
 One of the properties can’t be set directly, so it’s defined using a getter method (instead of a variable). .
 The method uses string interpolation to print variables’ string equivalents inside of string literals. .

| class Spacecraft {
|   String name;
|   DateTime? launchDate;

|   // Read-only non-final property
|   int? get launchYear => launchDate?.year;
| 
|   // Constructor, with syntactic sugar for assignment to members.
|   Spacecraft(this.name, this.launchDate) {
|   // Initialization code goes here.
|   }

|   // Named constructor that forwards to the default one.
|   Spacecraft.unlaunched(String name) : this(name, null);

|   // Method.
|   void describe() {
|     print('Spacecraft: $name');
|     // Type promotion doesn't work on getters.
|     var launchDate = this.launchDate;
|     if (launchDate != null) {
|       int years = DateTime.now().difference(launchDate).inDays ~/ 365;
|       print('Launched: $launchYear ($years years ago)');
|     } else {
|       print('Unlaunched');
|     }
|   }
| }

 You might use the Spacecraft class like this: .

| var voyager = Spacecraft('Voyager I', DateTime(1977, 9, 5));
| voyager.describe();

| var voyager3 = Spacecraft.unlaunched('Voyager III');
| voyager3.describe();

  Enums. .

 Enums are a way of enumerating a predefined set of values or instances in a way which ensures .
 that there cannot be any other instances of that type. .

 Here is an example of a simple enum that defines a simple list of predefined planet types: .

| enum PlanetType { terrestrial, gas, ice }

 Here is an example of an enhanced enum declaration of a class describing planets, .
 with a defined set of constant instances, namely the planets of our own solar system. .

| /// Enum that enumerates the different planets in our solar system
| /// and some of their properties.
| enum Planet {
|   mercury(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   venus(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   // ···
|   uranus(planetType: PlanetType.ice, moons: 27, hasRings: true),
|   neptune(planetType: PlanetType.ice, moons: 14, hasRings: true);

|   /// A constant generating constructor
|   const Planet(
|       {required this.planetType, required this.moons, required this.hasRings});

|   /// All instance variables are final
|   final PlanetType planetType;
|   final int moons;
|   final bool hasRings;

|   /// Enhanced enums support getters and other methods
|   bool get isGiant =>
|       planetType == PlanetType.gas || planetType == PlanetType.ice;
| }

 You might use the Planet enum like this: .

| final yourPlanet = Planet.earth;

| if (!yourPlanet.isGiant) {
|   print('Your planet is not a "giant planet".');
| }

..
  Inheritance. .

 Dart has single inheritance. .

| class Orbiter extends Spacecraft {
|   double altitude;

|   Orbiter(super.name, DateTime super.launchDate, this.altitude);
| }


Read more about extending classes, the optional @override annotation, and more.

  Mixins. .

 Mixins are a way of reusing code in multiple class hierarchies. The following is a mixin declaration: .

| mixin Piloted {
|   int astronauts = 1;

|   void describeCrew() {
|     print('Number of astronauts: $astronauts');
|   }
| }

 To add a mixin’s capabilities to a class, just extend the class with the mixin. .

| class PilotedCraft extends Spacecraft with Piloted {
|   // ···
| }

 PilotedCraft now has the astronauts field as well as the describeCrew() method. .

.....Read more about mixins.

  Interfaces and abstract classes. .

 All classes implicitly define an interface. Therefore, you can implement any class. .

| class MockSpaceship implements Spacecraft {
|   // ···
| }

....Read more about implicit interfaces, or about the explicit interface keyword.

 You can create an abstract class to be extended (or implemented) by a concrete class. .
 Abstract classes can contain abstract methods (with empty bodies). .

| abstract class Describable {
|   void describe();

|   void describeWithEmphasis() {
|     print('=========');
|     describe();
|     print('=========');
|   }
| }

 Any class extending Describable has the describeWithEmphasis() method, .
 which calls the extender’s implementation of describe(). .

.....Read more about abstract classes and methods.
  
  Async. .

 Avoid callback hell and make your code much more readable by using async and await. .

| const oneSecond = Duration(seconds: 1);
| // ···
| Future<void> printWithDelay(String message) async {
|   await Future.delayed(oneSecond);
|   print(message);
| }

 The method above is equivalent to: .

| Future<void> printWithDelay(String message) {
|   return Future.delayed(oneSecond).then((_) {
|     print(message);
|   });
| }

 As the next example shows, async and await help make asynchronous code easy to read. .

| Future<void> createDescriptions(Iterable<String> objects) async {
|   for (final object in objects) {
|     try {
|       var file = File('$object.txt');
|       if (await file.exists()) {
|         var modified = await file.lastModified();
|         print(
|             'File for $object already exists. It was modified on $modified.');
|         continue;
|       }
|       await file.create();
|       await file.writeAsString('Start describing $object in this file.');
|     } on IOException catch (e) {
|       print('Cannot create description for $object: $e');
|     }
|   }
| }

 You can also use async*, which gives you a nice, readable way to build streams. .

| Stream<String> report(Spacecraft craft, Iterable<String> objects) async* {
|   for (final object in objects) {
|     await Future.delayed(oneSecond);
|     yield '${craft.name} flies by $object';
|   }
| }

....Read more about asynchrony support, including async functions, Future, Stream, and the asynchronous loop (await for).

  Exceptions. .

 To raise an exception, use throw: .

| if (astronauts == 0) {
|   throw StateError('No astronauts.');
| }

 To catch an exception, use a try statement with on or catch (or both): .

| Future<void> describeFlybyObjects(List<String> flybyObjects) async {
|   try {
|     for (final object in flybyObjects) {
|       var description = await File('$object.txt').readAsString();
|       print(description);
|     }
|   } on IOException catch (e) {
|     print('Could not describe object: $e');
|   } finally {
|     flybyObjects.clear();
|   }
| }

 Note that the code above is asynchronous; try works for both synchronous code and code in an async function. .

...Read more about exceptions, including stack traces, rethrow, and the difference between Error and Exception.
  Important concepts. .

As you continue to learn about the Dart language, keep these facts and concepts in mind: .

    Everything you can place in a variable is an object, and every object is an instance of a class. .
    Even numbers, functions, and null are objects. With the exception of null (if you enable sound null safety), .
    all objects inherit from the Object class. .

    Version note: Null safety was introduced in Dart 2.12. Using null safety requires a language version of at least 2.12. .
    Although Dart is strongly typed, type annotations are optional because Dart can infer types. In var number = 101, number is inferred to be of type int. .
    If you enable null safety, variables can’t contain null unless you say they can. You can make a variable nullable by putting a question mark (?) at the end of its type. For example, a variable of type int? might be an integer, or it might be null. .
    If you know that an expression never evaluates to null but Dart disagrees, you can add ! to assert that it isn’t null (and to throw an exception if it is). An example: int x = nullableButNotNullInt! .
    When you want to explicitly say that any type is allowed, use the type Object? (if you’ve enabled null safety), .
    Object, or—if you must defer type checking until runtime—the special type dynamic. .
    Dart supports generic types, like List<int> (a list of integers) or List<Object> (a list of objects of any type). .
    Dart supports top-level functions (such as main()), as well as functions tied to a class or object .
    (static and instance methods, respectively). You can also create functions within functions (nested or local functions). .
    Similarly, Dart supports top-level variables, as well as variables tied to a class or object (static and instance variables). .
    Instance variables are sometimes known as fields or properties. .
    Unlike Java, Dart doesn’t have the keywords public, protected, and private. If an identifier starts with an underscore (_), .
    it’s private to its library. For details, see Libraries and imports. .
    Identifiers can start with a letter or underscore (_), followed by any combination of those characters plus digits. .
    Dart has both expressions (which have runtime values) and statements (which don’t). For example, .
    the conditional expression condition ? expr1 : expr2 has a value of expr1 or expr2. Compare that to an if-else statement, .
    which has no value. A statement often contains one or more expressions, but an expression can’t directly contain a statement. .

    Dart tools can report two kinds of problems: warnings and errors. Warnings are just indications that your code might not work, .
    but they don’t prevent your program from executing. Errors can be either compile-time or run-time. A compile-time error .
    prevents the code from executing at all; a run-time error results in an exception being raised while the code executes. .

...Additional resources

...More code samples are in the the library tour and the Dart API reference,. This site’s code follows the conventions in
...the Dart style guide.
