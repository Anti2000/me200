2023-09-26 06:28:26.602297
2023-09-26 06:27:48.880882
2023-09-26 06:26:46.315056
2023-09-26 00:17:31.619352
2023-09-26 00:17:19.538628
2023-09-26 00:17:01.745448
2023-09-26 00:16:49.259114
2023-09-26 00:16:35.970792
2023-09-26 00:13:06.433772
2023-09-26 00:11:20.893491
THE REPAIR OF FLAT. .

test
direction: .

espenses
2. adnryu: 35.
3. shkafu 20. 
4. adnryu 70.
5. –û–±–æ–∏ 20
6. door 50.


520
70+250=320 

buyins: .
1. magnits. now .
3. –ü–ª–∞—Å—Ç–∏–∫–æ–≤—ã–µ —Å–µ–Ω–≤–∏—á–ø–∞–Ω–µ–ª–∏ 50*150 8 —à—Ç, 50*210 1—à—Ç.. 
4. –£–≥–æ–ª–∫–∏ 10*10 5 —à—Ç –ø–æ 3 –º–µ—Ç—Ä–∞. 
5. –ü–ª–∞—Å—Ç–∏–∫–æ–≤–∞—è –ø—ç—à–∫–∏ 6 —à—Ç. –ü–æ 3 –º–µ—Ç—Ä–∞. 
6. –õ—é–∫ —Å–∫—Ä—ã—Ç–æ–≥–æ –º–æ–Ω—Ç–∞–∂–∞. wait jobs to bath 
7. –û–±–æ–∏. now. .
8. –ü–ª–∏–Ω—Ç—É—Å–∞. .
10. –ü–æ–ª–∏—Å—Ç–∏—Ä–æ–ª—å–Ω—É—é. 2–º–º 20 –∫–≤–∞. 35–∫–≤. 3 –º–º. 
11. –í—Ö–æ–¥–Ω—ã–µ –¥–≤–µ—Ä–∏. 20.
12. buy kvarqvinil. ??now .
13. sill. now. .
14. buy infokransiu panels. now. .
15. podlojka 1. now .
16. podlojka 2. now. .
17. folga. 3. now.
18. kran in kitchen. .
19. kran in bath. .
22 . svetilniki .

total questions: .
1. count money. everymoment .
2. prepair credis cards. .
3. carry out things. now. .
4. carry in things. now .
5. make up electrica in flat. now .
6. make up seals in shit. .


walls: .
1. check results. now. .
2. know about sill. now .
3. door. .
4. gruntovka. .
5. oboi buy. .
6. stick oboi. .


–ù–∞–ª–∏–≤–Ω–æ–π floor. .
2. speak with jober. . now. .
3. export other thing. now . .
4. define day. .


warm floor. .
1. know about posible and not. now .
2. buy kvarqvinil. ??now .
3. sill. now. .
4. buy infokransiu panels. now. .
5. podlojka 1. now .
6. podlojka 2. now. .
7. folga. 3. now .


BATH: .
1. carry plitka. now. .
2. take the size. .
3. luchok choose. .


santehnika: .
1. ask order in bath. .


mebel: .
1. sofa. now .
2. bed. now .
3. bedboards .


doors: .
1. doors. choose and buy. now.
2. ask about date. now .

kitchen: .
1. buy osmos. .
2. buy kran. .


–ü—ã–ª—å–Ω–∏–∫
–í–µ—Å–µ–Ω–Ω–∏–π.
–ì—Ä–∞–Ω–∞—Ç–∞
–•–æ–º—É—Ç
–†—É–ª–µ–≤–∞—è —Ä–µ–π–∫–∞( —Ä–µ–π–∫–∞56)
89228444424 –í–∏—Ç–∞–ª–∏–∫ repair
–û—Ç–∫—Ä—ã—Ç–∏–µ


–†–µ–º–µ–Ω—å –ì–†–ú. –ü–æ–ª–Ω—ã–π –∫–æ–º–ø–ª–µ–∫—Ç.
–°–∞–ª—å–Ω–∏–∫ —Ä–∞—Å–ø—Ä–µ–¥–≤–∞–ª–∞, –∫–æ–ª–µ–Ω–≤–∞–ª–∞,
–ü–æ–º–ø–∞.
–†—É–ª–µ–≤–∞—è —Ä–µ–π–∫–∞.(4000)
–°–∞–ª—å–Ω–∏–∫ –∫–æ—Ä–æ–±–∫–∏.
–°–∞–ª–µ–Ω–µ–Ω–±–ª–æ–∫–∏ –ø–µ—Ä–µ–¥–Ω–∏—Ö —Ä—ã—á–∞–≥–æ–≤. 
–®–∫–æ–¥–∞ –±–µ—Å—Ç.



–¢—É–π–≥—É–Ω–æ–≤ –ß–∞–∫ –ß–∞–∫.
Brain food:
Spinach 
80 35
–í957–∫–∫156

314409

–ù–∏–∫–æ–ª–∞–π —Å—Ç–∏–±—É–Ω–æ–≤. –î–≤–∏–≥–∞—Ç–µ–ª—å –ø–µ—Ä–µ–¥ –º–æ—Å—Ç–æ–º .





–†—Ö–∞666
+79960787468

455196
4361
39

Section one of American fair tales. This is % livbres waks% recording. All % recording to public on % domain. For more information and valunture please visit % org. Recording by mark ris. American fair tales by Elfrand born .a box and robbits no more intended a long to live afternoon  by happens everyone call afteway reasen one one others this is women sister long driver paper is officer uzre what mind she answered 
7536*

–£—Ä–∞–ª–±–∏

–ò–Ω—Å—Ç–∞–ª–ª—è—Ü–∏—è.
–ú–æ–π–∫–∞. 



–ü–µ—Å–æ—á–Ω–∏—Ü–∞ "–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä"  –∫–∞–∂–¥—ã–π —Ä–µ–±—ë–Ω–æ–∫ –±—ã–ª –±—ã —Ä–∞–¥ –ø–æ–ª—É—á–∏—Ç—å —Ç–∞–∫–æ–π –ø–æ–¥–∞—Ä–æ–∫!!!üòä 
üåø–†–∞–∑–º–µ—Ä 120*120 
üåø –≠–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ —á–∏—Å—Ç—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª
üåø–†–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã —Å –∫—Ä—ã—à–µ–π –∏ –±–µ–∑, —Å –ø–æ–∫—Ä–∞—Å–∫–æ–π –∏ –±–µ–∑ –ø–æ–∫—Ä–∞—Å–∫–∏!!! 
üåø–î–æ—Å—Ç–∞–≤–∫–∞ –µ—Å—Ç—å 
üåø–†–∞–∑–±–∏—Ä–∞–µ—Ç—Å—è –∏ –ª–µ–≥–∫–æ —Å–æ–±–∏—Ä–∞—Ç—å—Å—è –¥–ª—è –ø–µ—Ä–µ–≤–æ–∑–∫–∏ –Ω–∞ –ª–µ–≥–∫–æ–≤–æ–º –∞–≤—Ç–æ–º–æ–±–∏–ª–µ!!! 
üåø –ú–´ –í–°–ï–ì–î–ê –†–ê–î–´ –ù–û–í–´–ú –ö–õ–ò–ï–ù–¢–ê–ú. 
üåø –•–æ—Ä–æ—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ –æ—Ç –≤—Ä–µ–¥–∏—Ç–µ–ª–µ–π –¥–æ–º–∞—à–Ω–µ–≥–æ –æ–±–∏—Ç–∞–Ω–∏—è.  –î–ª—è –æ–ø—Ç–æ–≤—ã—Ö –∑–∞–∫—É–ø–æ–∫ –∏ –¥–µ—Ç—Å–∫–∏—Ö —Å–∞–¥–æ–≤, –¥–µ–π—Å—Ç–≤—É–µ—Ç —Å–∫–∏–¥–∫–∞.

–ï—Å—Ç—å —Å–±–æ—Ä–∫–∞ –∏ –¥–æ—Å—Ç–∞–≤–∫–∞. –ë—ã–≤–∞—é –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü–∏—à–∏—Ç–µ –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ. 
–î–µ—Ç—Å–∫–∞—è –ø–µ—Å–æ—á–Ω–∏—Ü–∞ 120 —Å–º —Å –∫—Ä—ã—à–∫–æ–π —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–µ—Ä (—Å–∫–∞–º–µ–π–∫–∏) –∏–∑ –¥–µ—Ä–µ–≤–∞. –ù–µ –æ–∫—Ä–∞—à–µ–Ω–Ω–∞—è.

–†–∞–∑–º–µ—Ä—ã 1,2 –º*1,2 –º*0,2 –º. –ò–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –∏–∑ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞. –¢–æ–ª—â–∏–Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ 20 –º–º. –î–æ—Å–∫–∞: –°–æ—Å–Ω–∞. –®–ª–∏—Ñ–æ–≤–∞–Ω–Ω–∞—è. 

–ê–∫—Ç–∏–≤–Ω—ã–µ –∏–≥—Ä—ã –Ω–∞ —Å–≤–µ–∂–µ–º –≤–æ–∑–¥—É—Ö–µ –ø–æ–ª–µ–∑–Ω—ã –¥–ª—è –º–∞–ª—ã—à–µ–π, –ø–µ—Å–æ–∫ —Ä–∞–∑–≤–∏–≤–∞–µ—Ç –º–µ–ª–∫—É—é –º–æ—Ç–æ—Ä–∏–∫—É –∏ —Ñ–∞–Ω—Ç–∞–∑–∏—é. –ü–æ–¥–∞—Ä–∏—Ç–µ —Ä–µ–±–µ–Ω–∫—É –ø–µ—Å–æ—á–Ω–∏—Ü—É —Å –∫—Ä—ã—à–∫–æ–π! –î–µ—Ä–µ–≤—è–Ω–Ω–∞—è —É–ª–∏—á–Ω–∞—è –ø–µ—Å–æ—á–Ω–∏—Ü–∞ –∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∞ –∏–∑ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–π —Å–æ—Å–Ω—ã.

–°–∫–ª–∞–¥–Ω–∞—è –∫—Ä—ã—à–∫–∞ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Å–∫–∞–º–µ–π–∫–∏ —Å–æ —Å–ø–∏–Ω–∫–∞–º–∏, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –º–∞–ª–µ–Ω—å–∫–∏—Ö –¥–µ—Ç–µ–π –≤–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã —Å –ø–µ—Å–∫–æ–º. –ú–∞–ª—ã—à –±—É–¥–µ—Ç –∏–≥—Ä–∞—Ç—å –≤ —Ä–∞–∑–≤–∏–≤–∞—é—â–∏–µ –∏–≥—Ä—ã –≤–º–µ—Å—Ç–µ —Å –º–∞–º–æ–π, —Å –ø–∞–ø–æ–π, —Å –¥—Ä—É–∑—å—è–º–∏. –†–∞—Å–∫—Ä—ã–ª–∏ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É, –ø–æ–ª—É—á–∏–ª–∏ —Å—Ç–æ–ª–∏–∫, —Ä–∞–∑–º–µ—Å—Ç–∏–ª–∏ –∏–≥—Ä—É—à–∫–∏ –¥–ª—è –ø–µ—Å–∫–∞.

–ö—Ä—ã—à–∫–∞ –∑–∞—â–∏—â–∞–µ—Ç –ø–µ—Å–æ–∫ –æ—Ç –≥—Ä—è–∑–∏, –ª–∏—Å—Ç—å–µ–≤ –∏ –∂–∏–≤–æ—Ç–Ω—ã—Ö. –ö—Ä—ã—à–∫–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è –≤ –¥–≤–µ —Å–∫–∞–º–µ–π–∫–∏. –í–∞–º –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –≤–∫—É—Å –≤—ã–±—Ä–∞—Ç—å –∞–Ω—Ç–∏—Å–µ–ø—Ç–∏–∫ –∏ –∫—Ä–∞—Å–∫—É.

–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –ø–µ—Å–æ—á–Ω–∏—Ü—ã —Å –∫—Ä—ã—à–∫–æ–π - –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ—Å–µ—â–µ–Ω–∏—è –∫–æ—à–µ–∫, —Å–æ–±–∞–∫, –¥—Ä—É–≥–∏—Ö –∂–∏–≤–æ—Ç–Ω—ã—Ö; –æ—Ç –º—É—Å–æ—Ä–∞, –ª–∏—Å—Ç—å–µ–≤. –ü–µ—Å–æ—á–Ω–∏—Ü–∞ –∏–∑ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –¥–∞—á–∏, –∑–∞–≥–æ—Ä–æ–¥–Ω–æ–≥–æ –¥–æ–º–∞, –∏–ª–∏ –¥–∞–∂–µ –¥–µ—Ç—Å–∫–æ–≥–æ —Å–∞–¥–∞.

–î–ª—è –Ω–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø–µ—Å–æ—á–Ω–∏—Ü—ã, –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è 350 –∫–≥. 9 –º–µ—à–∫–æ–≤ –ø–æ 40 –∫–≥.

–í–µ—Å –ø–µ—Å–æ—á–Ω–∏—Ü—ã: 22 –∫–≥. –ü–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤ —Ä–∞–∑–æ–±—Ä–∞–Ω–Ω–æ–º –≤–∏–¥–µ, —É–º–µ—â–∞–µ—Ç—Å—è –ª–µ–≥–∫–æ –≤ –ª–µ–≥–∫–æ–≤–æ–º –∞–≤—Ç–æ–º–æ–±–∏–ª–µ..

–î–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å –ø–µ—Å–æ—á–Ω–∏—Ü—ã –∏–∑ –¥–µ—Ä–µ–≤–∞ –¥–ª—è –¥–µ—Ç–µ–π –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –±–ª–∞–≥–æ—É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –∏–≥—Ä–æ–≤—ã—Ö –ø–ª–æ—â–∞–¥–æ–∫ –ø–∞—Ä–∫–æ–≤, –¥–≤–æ—Ä–æ–≤, –¥–µ—Ç—Å–∞–¥–æ–≤.

–ü–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è —Ä–∞–∑–±–æ—Ä–Ω–æ–π(–±–µ–∑ –æ—Ç–≤–µ—Ä—Å—Ç–∏–π). –õ–µ–≥–∫–æ —É–º–µ—â–∞–µ—Ç—Å—è –≤ –ª–µ–≥–∫–æ–≤–æ–º –∞–≤—Ç–æ–º–æ–±–∏–ª–µ.




all data in xi
transfer to the links
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

  STRATEGY: .
[GOD] .
[ME] .
[FAMELY] .
[BUSSINESS] .
[PASSWORD] .
[GIT] .
[PYTHON] .
[DART] .
[FLUTTER] .

 GOD: .

 ME: .
  animality: .
    self-actualization: .
     desire to become the most that one can be. .
    self-Esteem: .
     respect, self-esteem, recognition, strength, freedom. .
    love and belonging: .
     friendship, intimacy, famely, sense of connection. .
    safety and security: .
     personal security, employment, resources, health, property. .
    physiological need: .
     air, water, [food], shelter, sleep, clothing, reproduction. .
    food: .
    sx: .

  goals: .

  brain: .
    thinking circle: .
          001. the permorded deals.faster define the three deals for executing and doing it. .
          002. the base deals. define the three base deals for doing and doing it. .
          003. the important deals. define the three important deals and doing it. .
          004. Gods will. .
          005. english. .
          006. questions. .
          007. chess. .
          008. math. .
          009. repeat the base. .
          010. write program. .
          101. wash face. .
          102. straight up hair. .
          103. teethbrushing. .
          104. freshen up. .
          105. coffee. .
          106. teapot. .
          107. cough. .
          108. exersise. .
          109. Bible. .
          110. pray. .
          111. breakfast. .
          112. email. .
          113. plan. .
          114. question. .
          115. reading. .
          117. shoes. .
          118. dwelling order. .
          119. db_me. .
          120. dinner. .

    PASSWORD: .
    
          aliexpress https://seller.aliexpress.ru/  anatole.yakovlev@gmail.com  Asd25@# .
          avito novikov.timofey1952@gmail.com 8 995 839-59-17. firefox .
          avito 89096009912 chrome. .
          avito yandex app avito antiohy@mail.ru 89953518343 iXu-JsY-6aq-aF2 . .
          exist 89096009912 . .
          Yandex alisa light anatolij.novikov2016@ya.ru .

    FOOD: .
     brain for brain: .
      spinach. .

  BUSSINESS .

    SANDBOX .

type of sandbox: .

sandbox without holes only materials.  .
    INCUBATORS .

    CHILDHOSES .

    190.0 –≤–∞–≥–æ–Ω–∫–∞  22 —à—Ç—É–∫–∏.
130.0 –≤–∞–≥–æ–Ω–∫–∞  12 —à—Ç.
144.0 –≤–∞–≥–æ–Ω–∫–∞ 12 —à—Ç.
49.0 –≤–∞–≥–æ–Ω–∫–∞ 10 —à—Ç.
49.5 –≤–∞–≥–æ–Ω–∫–∞ 10 —à—Ç.
65.0 –≤–∞–≥–æ–Ω–∫–∞ 6 —à—Ç.
17.5 –≤–∞–≥–æ–Ω–∫–∞ 10 —à—Ç.
25.5 –≤–∞–≥–æ–Ω–∫–∞  11 —à—Ç.
39.5 –≤–∞–≥–æ–Ω–∫–∞  7 —à—Ç.
132.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
116.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
99.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
83.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
66.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
50.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
34.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
18.0 –≤–∞–≥–æ–Ω–∫–∞ —É–≥–æ–ª 2 —à—Ç.
47.0 –†–µ–π–∫–∞  4—à—Ç. 
41.5 —Ä–µ–π–∫–∞  6 —à—Ç.
30.0 —Ä–µ–π–∫–∞ 2 —à—Ç.
100 40*40  6 —à—Ç.
95.0  —É–≥–æ–ª 6 —à—Ç. 
183. 40*40 2 —à—Ç.
33.0 40*40 2 —à—Ç.
50.0 40*40 4 —à—Ç.
96.0 40*40 2 —à—Ç.
31.5 40*40 3 —à—Ç.
130.0 –¥–æ—Å–∫–∞ —à–ø—É–Ω—Ç–æ–≤–∞—è –¥–ª—è –ø–æ–ª–∞.  17 —à—Ç.
–ù–∞–ª–∏—á–Ω–∏–∫ 4 —à—Ç. –ü–æ 2 –º–µ—Ç—Ä–∞.
–¶–ï–ù–ê –ü–æ –∫–æ–º–ø–ª–µ–∫—Ç—É —Å –≤–∞–≥–æ–Ω–∫–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å –±—É–¥–µ—Ç 14250.  –ù–ê 23.07.2023

GIT: .
 sudo apt install git .
 git --version .
 sudo apt update .
 git init: initialisation of git .
 git config --global user.name "Your Name" .
 git config --global user.email "youremail@domain.com" .
 git config --list .
 git config --global core.editor "kate": install editor .
 git commit: make commit .
 nano: To make the commit you should write your commit message, then press ctrl+o to write your message, and then ctrl+x to exit that screen.
 git log: show history of commits .
 git branch: show whats branch .
 git branch updata_1: creating new branch(updata_1) .
 git checkout updata_1: swiching on new branch(updata_1)
 git checkout -b updata_1: create and swiching on new branch(updata_1) .
 git branh -D updata_1: delete branch .
 git add <>: add files in commit .
 git add.: add all in commit .
 git log --graph: show branchs(tree) .
 git merge <branch>: merging of branchs .
 git clone <https://github.com/Anti2000/car_parser.git> <car_parser> : make up clone from github to computor .
 git remote -v: show what is connect to computor.  .
 git remote add origin <https://github.com/Anti2000/example.git> add shotcut .
 git push origin master: add file to server  ??? .
 git pull origin main: update data from githup .
 https://stackoverflow.com/questions/1443210/updating-a-local-repository-with-changes-from-a-github-repository .
 git pull --rebase .
 Then I push the changes to a remote branch of the same name: .
 git push origin FixForBug .

  UBUNTU .
   linux commands: ls: List the contents of a folder. .
   ls -l : to see details like file size, permission, modified time, etc. .
   cd : Change the directory. .
   cd .. : go upper. .
   mkdir exemple: create directory. .
   rmdir exemple: delete directory. .
   lsb_release -a :know version of ubuntu. .
   cat <name file>> : open file. .
   cat < namefile : create file. .
   open Terminal in Linux: Using Shortcut(CTRL+ALT+T). .

  VC CODE .
   install vc code: .
   sudo snap install --classic code. .

FLUTTER .
  funcion main. .
 Every app requires the top-level main() function, where execution starts. .
 Functions that don‚Äôt explicitly return a value have the void return type. .
 To display text on the console, you can use the top-level print() function: .

| void main() {
|  print('Hello, World!');
| }

  Variables. .

 Even in type-safe Dart code, you can declare most variables without explicitly specifying their type using var. .
 Thanks to type inference, these variables‚Äô types are determined by their initial values: .

| var name = 'Voyager I';
| var year = 1977;
| var antennaDiameter = 3.7;
| var flybyObjects = ['Jupiter', 'Saturn', 'Uranus', 'Neptune'];
| var image = {
|   'tags': ['saturn'],
|   'url': '//path/to/saturn.jpg'
| };

 Here‚Äôs an example of creating a variable and initializing it: .

| var name = 'Bob';

 Variables store references. The variable called name contains a reference to a String object with a value of ‚ÄúBob‚Äù. .
 The type of the name variable is inferred to be String, but you can change that type by specifying it. .
 If an object isn‚Äôt restricted to a single type, specify the Object type (or dynamic if necessary). .

| Object name = 'Bob';

 Another option is to explicitly declare the type that would be inferred: .

| String name = 'Bob';

      Note: This page follows the style guide recommendation of using var, rather than type annotations, for local variables. .
    
    Null safety. .

The Dart language enforces sound null safety. .
 Null safety prevents an error that results from unintentional access of variables set to null. .
 The error is called a null dereference error. A null dereference error occurs when you access .
 a property or call a method on an expression that evaluates to null. .
 An exception to this rule is when null supports the property or method, like toString() or hashCode. .
 With null safety, the Dart compiler detects these potential errors at compile time. .
 For example, say you want to find the absolute value of an int variable i. .
 If i is null, calling i.abs() causes a null dereference error. In other languages, .
 trying this could lead to a runtime error, but Dart‚Äôs compiler prohibits these actions. .
 Therefore, Dart apps can‚Äôt cause runtime errors.

Null safety introduces three key changes: .
 When you specify a type for a variable, parameter, or another relevant component, .
 you can control whether the type allows null. To enable nullability, you add a ? .
 to the end of the type declaration. .
  String? name  // Nullable type. Can be `null` or string. .
  String name   // Non-nullable type. Cannot be `null` but can be string. .

 You must initialize variables before using them. Nullable variables default to null, .
 so they are initialized by default. Dart doesn‚Äôt set initial values to non-nullable types. .
 It forces you to set an initial value. Dart doesn‚Äôt allow you to observe an uninitialized variable. .
 This prevents you from accessing properties or calling methods where the receiver‚Äôs type can be null . .
 but null doesn‚Äôt support the method or property used. .
 You can‚Äôt access properties or call methods on an expression with a nullable type. The same exception applies where it‚Äôs a property or method that null supports like hashCode or toString(). .

 Sound null safety changes potential runtime errors into edit-time analysis errors. . 
 Null safety flags a non-null variable when it has been either: .

 Not initialized with a non-null value. .
 Assigned a null value. .

 This check allows you to fix these errors before deploying your app. .
 
  Default value. .

 Uninitialized variables that have a nullable type have an initial value of null. .
 Even variables with numeric types are initially null, because numbers‚Äîlike everything else in Dart‚Äîare objects. .

| int? lineCount;
| assert(lineCount == null);

 Note: Production code ignores the assert() call. During development, on the other hand, .
 assert(condition) throws an exception if condition is false. For details, check out Assert. .

 With null safety, you must initialize the values of non-nullable variables before you use them: .

| int lineCount = 0;

 You don‚Äôt have to initialize a local variable where it‚Äôs declared, but you do need to assign it a value before it‚Äôs used. For example, the following code is valid because Dart can detect that lineCount is non-null by the time it‚Äôs passed to print(): .

| int lineCount;

| if (weLikeToCount) {
|  lineCount = countLines();
| } else {
|  lineCount = 0;
| }

| print(lineCount);

 Top-level and class variables are lazily initialized; the initialization code runs the first time the variable is used. .
  
  Late variables. .

 The late modifier has two use cases: .
 Declaring a non-nullable variable that‚Äôs initialized after its declaration. .
 Lazily initializing a variable. .

 Often Dart‚Äôs control flow analysis can detect when a non-nullable variable is set to a non-null value .
 before it‚Äôs used, but sometimes analysis fails. Two common cases are top-level variables and instance variables: .
 Dart often can‚Äôt determine whether they‚Äôre set, so it doesn‚Äôt try. .

 If you‚Äôre sure that a variable is set before it‚Äôs used, but Dart disagrees, .
 you can fix the error by marking the variable as late: .

| late String description;

| void main() {
|  description = 'Feijoada!';
|  print(description);
| }

 If you fail to initialize a late variable, a runtime error occurs when the variable is used. .
 When you mark a variable as late but initialize it at its declaration, .
 then the initializer runs the first time the variable is used. .
 This lazy initialization is handy in a couple of cases: .

 The variable might not be needed, and initializing it is costly. .
 You‚Äôre initializing an instance variable, and its initializer needs access to this. .

 In the following example, if the temperature variable is never used, .
 then the expensive readThermometer() function is never called: .

| // This is the program's only call to readThermometer().
| late String temperature = readThermometer(); // Lazily initialized.

 Final and const. .

 If you never intend to change a variable, use final or const, either instead of var or in addition to a type. .
 A final variable can be set only once; a const variable is a compile-time constant. (Const variables are implicitly final.) .

 Note: Instance variables can be final but not const. .

 Here‚Äôs an example of creating and setting a final variable: .

| final name = 'Bob'; // Without a type annotation
| final String nickname = 'Bobby';

 You can‚Äôt change the value of a final variable: .

| name = 'Alice'; // Error: a final variable can only be set once.

 Use const for variables that you want to be compile-time constants. If the const variable is at the class level, .
 mark it static const. Where you declare the variable, set the value to a compile-time constant such as a number .
 or string literal, a const variable, or the result of an arithmetic operation on constant numbers: .

| const bar = 1000000; // Unit of pressure (dynes/cm2)
| const double atm = 1.01325 * bar; // Standard atmosphere

 The const keyword isn‚Äôt just for declaring constant variables. You can also use it to create constant values, .
 as well as to declare constructors that create constant values. Any variable can have a constant value. .

| var foo = const [];
| final bar = const [];
| const baz = []; // Equivalent to `const []`

 You can omit const from the initializing expression of a const declaration, like for baz above. For details, .
 see DON‚ÄôT use const redundantly. .

 You can change the value of a non-final, non-const variable, even if it used to have a const value: .

| foo = [1, 2, 3]; // Was const []

 You can‚Äôt change the value of a const variable: .

| baz = [42]; // Error: Constant variables can't be assigned a value.

You can define constants that use type checks and casts (is and as), collection if, and spread operators .
(... and ...?): .

| const Object i = 3; // Where i is a const Object with an int value...
| const list = [i as int]; // Use a typecast.
| const map = {if (i is int) i: 'int'}; // Use is and collection if.
| const set = {if (list is List<int>) ...list}; // ...and a spread.

 Note: Although a final object cannot be modified, its fields can be changed. In comparison, .
 a const object and its fields cannot be changed: they‚Äôre immutable. .

 For more information on using const to create constant values, see Lists, Maps, and Classes. .

  Operators. .

 Dart supports the operators shown in the following table. The table shows Dart‚Äôs operator associativity .
 and operator precedence from highest to lowest, which are an approximation of Dart‚Äôs operator relationships. .
 You can implement many of these operators as class members. .

| Description 	            Operator 	                                                    Associativity
| unary postfix 	          expr++    expr--    ()    []    ?[]    .    ?.    ! 	        None
| unary prefix 	            -expr    !expr    ~expr    ++expr    --expr      await expr   None
| multiplicative 	          *    /    %  ~/ 	                                            Left
| additive 	                +    - 	                                                      Left
| shift 	                  <<    >>    >>> 	                                            Left
| bitwise AND 	            & 	                                                          Left
| bitwise XOR 	            ^ 	                                                          Left
| bitwise OR 	              | 	                                                          Left
| relational and type test 	>=    >    <=    <    as    is    is! 	                      None
| equality 	                ==    !=    	                                                None
| logical AND 	            && 	                                                          Left
| logical OR              	|| 	                                                          Left
| if null 	                ?? 	                                                          Left
| conditional             	expr1 ? expr2 : expr3 	                                      Right
| cascade                  	..    ?.. 	                                                  Left
| assignment               	=    *=    /=   +=   -=   &=   ^=   etc. 	                    Right

 Warning: The previous table should only be used as a helpful guide. The notion of operator precedence and .
 associativity is an approximation of the truth found in the language grammar. You can find the authoritative .
 behavior of Dart‚Äôs operator relationships in the grammar defined in the Dart language specification. .

 When you use operators, you create expressions. Here are some examples of operator expressions: .

| a++
| a + b
| a = b
| a == b
| c ? a : b
| a is T

  Operator precedence example. .

 In the operator table, each operator has higher precedence than the operators in the rows that follow it. .
 For example, the multiplicative operator % has higher precedence than (and thus executes before) the equality. .
 operator ==, which has higher precedence than the logical AND operator &&. That precedence means that .
 the following two lines of code execute the same way: .

| // Parentheses improve readability.
| if ((n % i == 0) && (d % i == 0)) ...

| // Harder to read, but equivalent.
| if (n % i == 0 && d % i == 0) ...

 Warning: For operators that take two operands, the leftmost operand determines which method is used. .
 For example, if you have a Vector object and a Point object, then aVector + aPoint uses Vector addition (+). .
 

  Arithmetic operators. .

 Dart supports the usual arithmetic operators, as shown in the following table. .

| Operator 	Meaning
| + 	      Add
| - 	      Subtract
| -expr 	  Unary minus, also known as negation (reverse the sign of the expression)
| *        	Multiply
| /        	Divide
| ~/        Divide, returning an integer result
| %       	Get the remainder of an integer division (modulo)

 Example: .

| assert(2 + 3 == 5);
| assert(2 - 3 == -1);
| assert(2 * 3 == 6);
| assert(5 / 2 == 2.5); // Result is a double
| assert(5 ~/ 2 == 2); // Result is an int
| assert(5 % 2 == 1); // Remainder

| assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');

 Dart also supports both prefix and postfix increment and decrement operators. .

| Operator 	Meaning
| ++var    	var = var + 1 (expression value is var + 1)
| var++ 	  var = var + 1 (expression value is var)
| --var 	  var = var - 1 (expression value is var - 1)
| var-- 	  var = var - 1 (expression value is var)

 Example: .

| int a;
| int b;

| a = 0;
| b = ++a; // Increment a before b gets its value.
| assert(a == b); // 1 == 1

| a = 0;
| b = a++; // Increment a after b gets its value.
| assert(a != b); // 1 != 0

| a = 0;
| b = --a; // Decrement a before b gets its value.
| assert(a == b); // -1 == -1

| a = 0;
| b = a--; // Decrement a after b gets its value.
| assert(a != b); // -1 != 0

 Equality and relational operators. .

 The following table lists the meanings of equality and relational operators. .

| Operator 	Meaning
| ==       	Equal; see discussion below
| !=      	Not equal
| >        	Greater than
| <        	Less than
| >=      	Greater than or equal to
| <=      	Less than or equal to

 To test whether two objects x and y represent the same thing, use the == operator. .
 (In the rare case where you need to know whether two objects are the exact same object, .
 use the identical() function instead.) Here‚Äôs how the == operator works: .

 If x or y is null, return true if both are null, and false if only one is null. .

 Return the result of invoking the == method on x with the argument y. (That‚Äôs right, operators .
 such as == are methods that are invoked on their first operand. For details, see Operators.). .

 Here‚Äôs an example of using each of the equality and relational operators: .

| assert(2 == 2);
| assert(2 != 3);
| assert(3 > 2);
| assert(2 < 3);
| assert(3 >= 3);
| assert(2 <= 3);

  Type test operators. .

 The as, is, and is! operators are handy for checking types at runtime. .

| Operator 	Meaning
| as 	Typecast (also used to specify library prefixes)
| is 	True if the object has the specified type
| is! 	True if the object doesn‚Äôt have the specified type

 The result of obj is T is true if obj implements the interface specified by T. For example, obj is Object? .
 is always true. .

 Use the as operator to cast an object to a particular type if and only if you are sure that the object .
 is of that type. Example: .

| (employee as Person).firstName = 'Bob';

 If you aren‚Äôt sure that the object is of type T, then use is T to check the type before using the object. .

| if (employee is Person) {
|   // Type check
|   employee.firstName = 'Bob';
| }

 Note: The code isn‚Äôt equivalent. If employee is null or not a Person, the first example throws an exception; .
 the second does nothing. .

  Assignment operators. .

 As you‚Äôve already seen, you can assign values using the = operator. To assign only if the assigned-to .
 variable is null, use the ??= operator. .

| // Assign value to a
| a = value;
| // Assign value to b if b is null; otherwise, b stays the same
| b ??= value;

 Compound assignment operators such as += combine an operation with an assignment. .
| = 	    *= 	    %= 	     >>>= 	   ^=
| += 	    /=    	<<=     	&=       |=
| -= 	    ~/=   	>>= 	  	 

 Here‚Äôs how compound assignment operators work: .

|                        	Compound assignment 	Equivalent expression
| For an operator op:   	a op= b              	a = a op b
| Example:              	a += b               	a = a + b

 The following example uses assignment and compound assignment operators: .

| var a = 2; // Assign using =
| a *= 3; // Assign and multiply: a = a * 3
| assert(a == 6);

  Logical operators. .

 You can invert or combine boolean expressions using the logical operators. .

| Operator 	Meaning
| !expr   	inverts the following expression (changes false to true, and vice versa)
| || 	      logical OR
| && 	      logical AND 

 Here‚Äôs an example of using the logical operators: .

| if (!done && (col == 0 || col == 3)) {
|   // ...Do something...
| }

  Bitwise and shift operators. .

 You can manipulate the individual bits of numbers in Dart. Usually, you‚Äôd use these bitwise and shift .
 operators with integers. .

| Operator 	Meaning
|  &       	AND
|  | 	      OR
|  ^ 	      XOR
|  ~expr 	  Unary bitwise complement (0s become 1s; 1s become 0s)
|  << 	    Shift left
|  >> 	    Shift right
|  >>> 	    Unsigned shift right

 Note: The behavior of bitwise operations with large or negative operands might differ between platforms. .
 To learn more, check out Bitwise operations platform differences. .

 Here‚Äôs an example of using bitwise and shift operators: .

| final value = 0x22;
| final bitmask = 0x0f;

| assert((value & bitmask) == 0x02); // AND
| assert((value & ~bitmask) == 0x20); // AND NOT
| assert((value | bitmask) == 0x2f); // OR
| assert((value ^ bitmask) == 0x2d); // XOR

| assert((value << 4) == 0x220); // Shift left
| assert((value >> 4) == 0x02); // Shift right

| // Shift right example that results in different behavior on web
| // because the operand value changes when masked to 32 bits:
| assert((-value >> 4) == -0x03);

| assert((value >>> 4) == 0x02); // Unsigned shift right
| assert((-value >>> 4) > 0); // Unsigned shift right

 Version note: The >>> operator (known as triple-shift or unsigned shift) requires a language version of at .
 least 2.14. .

  Conditional expressions. .

 Dart has two operators that let you concisely evaluate expressions that might otherwise require if-else .
 statements: .

| condition ? expr1 : expr2
 If condition is true, evaluates expr1 (and returns its value); otherwise, evaluates and returns the value .
 of expr2. .

| expr1 ?? expr2
 If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2. .

 When you need to assign a value based on a boolean expression, consider using ? and : .
| var visibility = isPublic ? 'public' : 'private';

 If the boolean expression tests for null, consider using ??. .

| String playerName(String? name) => name ?? 'Guest';

 The previous example could have been written at least two other ways, but not as succinctly: .

| // Slightly longer version uses ?: operator.
| String playerName(String? name) => name != null ? name : 'Guest';

| // Very long version uses if-else statement.
| String playerName(String? name) {
|   if (name != null) {
|     return name;
|   } else {
|     return 'Guest';
|   }
| }

  Cascade notation. .

 Cascades (.., ?..) allow you to make a sequence of operations on the same object. In addition to accessing .
 instance members, you can also call instance methods on that same object. This often saves you the step of .
 creating a temporary variable and allows you to write more fluid code. .

 Consider the following code: .

| var paint = Paint()
|   ..color = Colors.black
|   ..strokeCap = StrokeCap.round
|   ..strokeWidth = 5.0;

 The constructor, Paint(), returns a Paint object. The code that follows the cascade notation operates .
 on this object, ignoring any values that might be returned. .

 The previous example is equivalent to this code: .

| var paint = Paint();
| paint.color = Colors.black;
| paint.strokeCap = StrokeCap.round;
| paint.strokeWidth = 5.0;

 If the object that the cascade operates on can be null, then use a null-shorting cascade (?..) .
 for the first operation. Starting with ?.. guarantees that none of the cascade operations are .
 attempted on that null object. .

| querySelector('#confirm') // Get an object.
|   ?..text = 'Confirm' // Use its members.
|   ..classes.add('important')
|   ..onClick.listen((e) => window.alert('Confirmed!'))
|   ..scrollIntoView();

 Version note: The ?.. syntax requires a language version of at least 2.12. .

 The previous code is equivalent to the following: .

| var button = querySelector('#confirm');
| button?.text = 'Confirm';
| button?.classes.add('important');
| button?.onClick.listen((e) => window.alert('Confirmed!'));
| button?.scrollIntoView();

You can also nest cascades. For example: .

| final addressBook = (AddressBookBuilder()
|       ..name = 'jenny'
|       ..email = 'jenny@example.com'
|       ..phone = (PhoneNumberBuilder()
|             ..number = '415-555-0100'
|             ..label = 'home')
|           .build())
|     .build();

 Be careful to construct your cascade on a function that returns an actual object. For example, .
 the following code fails: .

| var sb = StringBuffer();
| sb.write('foo')
|   ..write('bar'); // Error: method 'write' isn't defined for 'void'.

 The sb.write() call returns void, and you can‚Äôt construct a cascade on void. .

 Note: Strictly speaking, the ‚Äúdouble dot‚Äù notation for cascades isn‚Äôt an operator. .
 It‚Äôs just part of the Dart syntax. .
 
  Other operators. .

 You‚Äôve seen most of the remaining operators in other examples: .

| Operator 	Name                   	      Meaning
|   ()     	Function application 	        Represents a function call
|   [] 	    Subscript access 	            Represents a call to the overridable [] operator; example: fooList[1] passes the int 1 to fooList to access the element at index 1
|   ?[] 	  Conditional subscript access 	Like [], but the leftmost operand can be null; example: fooList?[1] passes the int 1 to fooList to access the element at index 1 unless fooList is null (in which case the expression evaluates to null)
|   . 	    Member access               	Refers to a property of an expression; example: foo.bar selects property bar from expression foo
|   ?. 	    Conditional member access   	Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)
|   ! 	    Null assertion operator 	     Casts an expression to its underlying non-nullable type, throwing a runtime exception if the cast fails; example: foo!.bar asserts foo is non-null and selects the property bar, unless foo is null in which case a runtime exception is thrown


  Comments. .

 Dart supports single-line comments, multi-line comments, and documentation comments. .
    Single-line comments. .

A single-line comment begins with //. Everything between // and the end of line .
is ignored by the Dart compiler. .

| void main() {
|   // TODO: refactor into an AbstractLlamaGreetingFactory?
|   print('Welcome to my Llama farm!');
| }

    Multi-line comments. .

 A multi-line comment begins with /* and ends with */. Everything between /* and */ is .
 ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). .
 Multi-line comments can nest. .

| void main() {
|   /*
|    * This is a lot of work. Consider raising chickens.

|   Llama larry = Llama();
|   larry.feed();
|   larry.exercise();
|   larry.clean();
|    */
| }

    Documentation comments. .

 Documentation comments are multi-line or single-line comments that begin with /// or /**. .
 Using /// on consecutive lines has the same effect as a multi-line doc comment. .

 Inside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. .
 Using brackets, you can refer to classes, methods, fields, top-level variables, functions, .
 and parameters. The names in brackets are resolved in the lexical scope of the documented program element. .

 Here is an example of documentation comments with references to other classes and arguments: .

| /// A domesticated South American camelid (Lama glama).
| ///
| /// Andean cultures have used llamas as meat and pack
| /// animals since pre-Hispanic times.
| ///
| /// Just like any other animal, llamas need to eat,
| /// so don't forget to [feed] them some [Food].
| class Llama {
|   String? name;

|   /// Feeds your llama [food].
|   ///
|   /// The typical llama eats one bale of hay per week.
|   void feed(Food food) {
|     // ...
|   }
| 
|   /// Exercises your llama with an [activity] for
|   /// [timeLimit] minutes.
|   void exercise(Activity activity, int timeLimit) {
|     // ...
|   }
| }

 In the class‚Äôs generated documentation, [feed] becomes a link to the docs for the feed method, .
 and [Food] becomes a link to the docs for the Food class. .

 To parse Dart code and generate HTML documentation, you can use Dart‚Äôs documentation .
 generation tool, dart doc. For an example of generated documentation, see the Dart API .
 documentation. For advice on how to structure your comments, see Effective Dart: Documentation. .
 
  Metadata. .

 Use metadata to give additional information about your code. A metadata annotation .
 begins with the character @, followed by either a reference to a compile-time constant .
 (such as deprecated) or a call to a constant constructor. .

 Three annotations are available to all Dart code: @Deprecated, @deprecated, and @override. .
 For examples of using @override, see Extending a class. Here‚Äôs an example of using .
 the @Deprecated annotation: .

| class Television {
|   /// Use [turnOn] to turn the power on instead.
|   @Deprecated('Use turnOn instead')
|   void activate() {
|     turnOn();
|   }

|   /// Turns the TV's power on.
|   void turnOn() {...}
|   // ¬∑¬∑¬∑
| }

 You can define your own metadata annotations. Here‚Äôs an example of defining a @Todo annotation that .
 takes two arguments: .

| class Todo {
|   final String who;
|   final String what;
| 
|   const Todo(this.who, this.what);
| }

 And here‚Äôs an example of using that @Todo annotation: .

| @Todo('Dash', 'Implement this function')
| void doSomething() {
|   print('Do something');
| }

 Metadata can appear before a library, class, typedef, type parameter, constructor, factory, .
 function, field, parameter, or variable declaration and before an import or export directive. .
 You can retrieve metadata at runtime using reflection. .
 
  Libraries & imports. .

 The import and library directives can help you create a modular and shareable code base. .
 Libraries not only provide APIs, but are a unit of privacy: identifiers that start with .
 an underscore (_) are visible only inside the library. Every Dart file (plus its parts) .
 is a library, even if it doesn‚Äôt use a library directive. .

 Libraries can be distributed using packages. .

 If you‚Äôre curious why Dart uses underscores instead of access modifier keywords like .
 public or private, see SDK issue 33383. .

    Using libraries. .

 Use import to specify how a namespace from one library is used in the scope of another library. .

 For example, Dart web apps generally use the dart:html library, which they can import like this: .

| import 'dart:html';

 The only required argument to import is a URI specifying the library. For built-in libraries, .
 the URI has the special dart: scheme. For other libraries, you can use a file system path or .
 the package: scheme. The package: scheme specifies libraries provided by a package manager such .
 as the pub tool. For example: .

| import 'package:test/test.dart';

 Note: URI stands for uniform resource identifier. URLs (uniform resource locators) are a common kind of URI. .

    Specifying a library prefix. .

 If you import two libraries that have conflicting identifiers, then you can specify a prefix .
 for one or both libraries. For example, if library1 and library2 both have an Element class, .
 then you might have code like this: .

| import 'package:lib1/lib1.dart'; 
| import 'package:lib2/lib2.dart' as lib2;

| // Uses Element from lib1.
| Element element1 = Element();

| // Uses Element from lib2.
| lib2.Element element2 = lib2.Element();

| Importing only part of a library

 If you want to use only part of a library, you can selectively import the library. For example: .

| // Import only foo.
| import 'package:lib1/lib1.dart' show foo;

| // Import all names EXCEPT foo.
| import 'package:lib2/lib2.dart' hide foo;

 Lazily loading a library. .

 Deferred loading (also called lazy loading) allows a web app to load a library on demand, .
 if and when the library is needed. Here are some cases when you might use deferred loading: .

To reduce a web app‚Äôs initial startup time. .
To perform A/B testing‚Äîtrying out alternative implementations of an algorithm, for example. .
To load rarely used functionality, such as optional screens and dialogs. .

 Only dart compile js supports deferred loading. Flutter and the Dart VM don‚Äôt support deferred loading. .
 To learn more, see issue #33118 and issue #27776. .

 To lazily load a library, you must first import it using deferred as. .

| import 'package:greetings/hello.dart' deferred as hello;

 When you need the library, invoke loadLibrary() using the library‚Äôs identifier. .

| Future<void> greet() async {
|   await hello.loadLibrary();
|   hello.printGreeting();
| }

 In the preceding code, the await keyword pauses execution until the library is loaded. .
 For more information about async and await, see asynchrony support. .

 You can invoke loadLibrary() multiple times on a library without problems. The library is loaded only once. .

 Keep in mind the following when you use deferred loading: .

 A deferred library‚Äôs constants aren‚Äôt constants in the importing file. Remember, these constants don‚Äôt .
 exist until the deferred library is loaded. You can‚Äôt use types from a deferred library in the .
 importing file. Instead, consider moving interface types to a library imported by both .
 the deferred library and the importing file. Dart implicitly inserts loadLibrary() into .
 the namespace that you define using deferred as namespace. The loadLibrary() function returns a Future. .

    The library directive. .

 To specify library-level doc comments or metadata annotations, attach them to a .
 library declaration at the start of the file. .

| /// A really great test library.
| @TestOn('browser')
| library;


    Keywords. .

 The following table lists the words that the Dart language treats specially. .
abstract 2   	else             	import 2 	    show 1
as 2 	        enum              in          	static 2
assert        export 2 	        interface 2 	super
async 1       extends 	        is          	switch
await 3 	    extension 2 	    late 2 	      sync 1
base 2 	      external 2 	      library 2 	  his
break 	      factory 2 	      mixin 2 	    throw
case 	        false 	          new 	        true
catch        	final (variable) 	null 	        try
class 	      final (class) 2 	on 1 	        typedef 2
const 	      finally 	        operator 2 	  var
continue 	    for 	            part 2 	      void
covariant 2 	Function 2 	      required 2   	when
default     	get 2 	          rethrow     	while
deferred 2 	  hide 1      	    return   	    with
do 	          if              	sealed 2    	yield 3
dynamic 2 	  implements 2 	    set 2 	 

Avoid using these words as identifiers. However, if necessary, the keywords marked with superscripts can be identifiers:

    Words with the superscript 1 are contextual keywords, which have meaning only in specific places. They‚Äôre valid identifiers everywhere.

    Words with the superscript 2 are built-in identifiers. These keywords are valid identifiers in most places, but they can‚Äôt be used as class or type names, or as import prefixes.

    Words with the superscript 3 are limited reserved words related to asynchrony support. You can‚Äôt use await or yield as an identifier in any function body marked with async, async*, or sync*.

All other words in the table are reserved words, which can‚Äôt be identifiers.


  Built-in types. .

 The Dart language has special support for the following: .

 Numbers (int, double) .
 Strings (String) .
 Booleans (bool) .
 Records ((value1, value2)) .
 Lists (List, also known as arrays) .
 Sets (Set) .
 Maps (Map) .
 Runes (Runes; often replaced by the characters API) .
 Symbols (Symbol) .
 The value null (Null) .

 This support includes the ability to create objects using literals. For example, .
 'this is a string' is a string literal, and true is a boolean literal. .

 Because every variable in Dart refers to an object‚Äîan instance of a class‚Äîyou can usually use .
 constructors to initialize variables. Some of the built-in types have their own constructors. .
 For example, you can use the Map() constructor to create a map. .

 Some other types also have special roles in the Dart language: .

     Object: The superclass of all Dart classes except Null. .
     Enum: The superclass of all enums. .
     Future and Stream: Used in asynchrony support. .
     Iterable: Used in for-in loops and in synchronous generator functions. .
     Never: Indicates that an expression can never successfully finish evaluating. .
     Most often used for functions that always throw an exception.
     dynamic: Indicates that you want to disable static checking. Usually you should .
     use Object or Object? instead. .
     void: Indicates that a value is never used. Often used as a return type.

 The Object, Object?, Null, and Never classes have special roles in the class hierarchy. .
 Learn about these roles in Understanding null safety.

    Numbers. .

 Dart numbers come in two flavors: .

int. .

 Integer values no larger than 64 bits, depending on the platform. On native platforms, .
 values can be from -263 to 263 - 1. On the web, integer values are represented as JavaScript numbers .
 (64-bit floating-point values with no fractional part) and can be from -253 to 253 - 1. . 

double. .

    64-bit (double-precision) floating-point numbers, as specified by the IEEE 754 standard.

 Both int and double are subtypes of num. The num type includes basic operators such as +, -, /, and *, .
 and is also where you‚Äôll find abs(), ceil(), and floor(), among other methods. (Bitwise operators, .
 such as >>, are defined in the int class.) If num and its subtypes don‚Äôt have what you‚Äôre looking for, .
 the dart:math library might.

 Integers are numbers without a decimal point. Here are some examples of defining integer literals: .

| var x = 1;
| var hex = 0xDEADBEEF;

 If a number includes a decimal, it is a double. Here are some examples of defining double literals: .

| var y = 1.1;
| var exponents = 1.42e5;

 You can also declare a variable as a num. If you do this, the variable can have both .
 integer and double values. .

| num x = 1; // x can have both int and double values
| x += 2.5;

 Integer literals are automatically converted to doubles when necessary: .

| double z = 1; // Equivalent to double z = 1.0.

 Here‚Äôs how you turn a string into a number, or vice versa: .

| // String -> int
| var one = int.parse('1');
| assert(one == 1);

| // String -> double
| var onePointOne = double.parse('1.1');
| assert(onePointOne == 1.1);

| // int -> String
| String oneAsString = 1.toString();
| assert(oneAsString == '1');

| // double -> String
| String piAsString = 3.14159.toStringAsFixed(2);
| assert(piAsString == '3.14');

The int type specifies the traditional bitwise shift (<<, >>, >>>), complement (~), AND (&), OR (|), .
and XOR (^) operators, which are useful for manipulating and masking flags in bit fields. For example: .

| assert((3 << 1) == 6); // 0011 << 1 == 0110
| assert((3 | 4) == 7); // 0011 | 0100 == 0111
| assert((3 & 4) == 0); // 0011 & 0100 == 0000

 For more examples, see the bitwise and shift operator section. .

 Literal numbers are compile-time constants. Many arithmetic expressions are also .
 compile-time constants, as long as their operands are compile-time constants that evaluate to numbers. .

| const msPerSecond = 1000;
| const secondsUntilRetry = 5;
| const msUntilRetry = secondsUntilRetry * msPerSecond;

 For more information, see Numbers in Dart. .

  Strings. .

 A Dart string (String object) holds a sequence of UTF-16 code units. You can use either single .
 or double quotes to create a string: .

| var s1 = 'Single quotes work well for string literals.';
| var s2 = "Double quotes work just as well.";
| var s3 = 'It\'s easy to escape the string delimiter.';
| var s4 = "It's even easier to use the other delimiter.";

 You can put the value of an expression inside a string by using ${expression}. If the expression .
 is an identifier, you can skip the {}. To get the string corresponding to an object, .
 Dart calls the object‚Äôs toString() method. .

| var s = 'string interpolation';

| assert('Dart has $s, which is very handy.' ==
|     'Dart has string interpolation, '
|         'which is very handy.');
| assert('That deserves all caps. '
|         '${s.toUpperCase()} is very handy!' ==
|     'That deserves all caps. '
|         'STRING INTERPOLATION is very handy!');

 Note: The == operator tests whether two objects are equivalent. Two strings are equivalent .
 if they contain the same sequence of code units. .

 You can concatenate strings using adjacent string literals or the + operator: .

| var s1 = 'String '
|     'concatenation'
|     " works even over line breaks.";
| assert(s1 ==
|     'String concatenation works even over '
|         'line breaks.');

| var s2 = 'The + operator ' + 'works, as well.';
| assert(s2 == 'The + operator works, as well.');

 Another way to create a multi-line string: use a triple quote with either single or double quotation marks: .

| var s1 = '''
| You can create
| multi-line strings like this one.
| ''';

| var s2 = """This is also a
| multi-line string.""";

 You can create a ‚Äúraw‚Äù string by prefixing it with r: .

| var s = r'In a raw string, not even \n gets special treatment.';

 See Runes and grapheme clusters for details on how to express Unicode characters in a string. .

 Literal strings are compile-time constants, as long as any interpolated expression is a compile-time .
 constant that evaluates to null or a numeric, string, or boolean value. .

| // These work in a const string.
| const aConstNum = 0;
| const aConstBool = true;
| const aConstString = 'a constant string';

| // These do NOT work in a const string.
| var aNum = 0;
| var aBool = true;
| var aString = 'a string';
| const aConstList = [1, 2, 3];

| const validConstString = '$aConstNum $aConstBool $aConstString';
| // const invalidConstString = '$aNum $aBool $aString $aConstList';

 For more information on using strings, check out Strings and regular expressions. .

  Booleans. .

 To represent boolean values, Dart has a type named bool. Only two objects have type bool: .
 the boolean literals true and false, which are both compile-time constants. .

 Dart‚Äôs type safety means that you can‚Äôt use code like if (nonbooleanValue) or assert (nonbooleanValue). .
 Instead, explicitly check for values, like this: .

| // Check for an empty string.
| var fullName = '';
| assert(fullName.isEmpty);

| // Check for zero.
| var hitPoints = 0;
| assert(hitPoints <= 0);

| // Check for null.
| var unicorn = null;
| assert(unicorn == null);

| // Check for NaN.
| var iMeantToDoThis = 0 / 0;
| assert(iMeantToDoThis.isNaN);

  Runes and grapheme clusters. .

 In Dart, runes expose the Unicode code points of a string. You can use the characters package to .
 view or manipulate user-perceived characters, also known as Unicode (extended) grapheme clusters. .

 Unicode defines a unique numeric value for each letter, digit, and symbol used in all of .
 the world‚Äôs writing systems. Because a Dart string is a sequence of UTF-16 code units, .
 expressing Unicode code points within a string requires special syntax. The usual way to .
 express a Unicode code point is \uXXXX, where XXXX is a 4-digit hexadecimal value. For example, .
 the heart character (‚ô•) is \u2665. To specify more or less than 4 hex digits, place the value .
 in curly brackets. For example, the laughing emoji (üòÜ) is \u{1f606}. .

 If you need to read or write individual Unicode characters, use the characters getter defined .
 on String by the characters package. The returned Characters object is the string as a sequence .
 of grapheme clusters. Here‚Äôs an example of using the characters API: .

| import 'package:characters/characters.dart';

| void main() {
|   var hi = 'Hi üá©üá∞';
|   print(hi);
|   print('The end of the string: ${hi.substring(hi.length - 1)}');
|   print('The last character: ${hi.characters.last}');
| }

 The output, depending on your environment, looks something like this: .

|  dart run bin/main.dart
| Hi üá©üá∞
| The end of the string: ???
| The last character: üá©üá∞

 For details on using the characters package to manipulate strings, see the example and API .
 reference for the characters package. .
  
  Symbols. .

 A Symbol object represents an operator or identifier declared in a Dart program. You might never .
 need to use symbols, but they‚Äôre invaluable for APIs that refer to identifiers by name, because .
 minification changes identifier names but not identifier symbols.

 To get the symbol for an identifier, use a symbol literal, which is just # followed by the identifier: .

| #radix
| #bar

Symbol literals are compile-time constants. .

  Records. .

 Version note: Records require a language version of at least 3.0. .

 Records are an anonymous, immutable, aggregate type. Like other collection types, they let you .
 bundle multiple objects into a single object. Unlike other collection types, records are fixed-sized, .
 heterogeneous, and typed. .

 Records are real values; you can store them in variables, nest them, pass them to and from functions, .
 and store them in data structures such as lists, maps, and sets. .

Record syntax. .

 Records expressions are comma-delimited lists of named or positional fields, enclosed in parentheses: .

| var record = ('first', a: 2, b: true, 'last');

 Record type annotations are comma-delimited lists of types enclosed in parentheses. You can use record .
 type annotations to define return types and parameter types. For example, the following (int, int) .
 statements are record type annotations: .

| (int, int) swap((int, int) record) {
|   var (a, b) = record;
|   return (b, a);
| }

 Fields in record expressions and type annotations mirror how parameters and arguments work in functions. .
 Positional fields go directly inside the parentheses: .

| // Record type annotation in a variable declaration:
| (String, int) record;

| // Initialize it with a record expression:
| record = ('A string', 123);

 In a record type annotation, named fields go inside a curly brace-delimited section of type-and-name pairs, .
 after all positional fields. In a record expression, the names go before each field value with a colon after: .

| // Record type annotation in a variable declaration:
| ({int a, bool b}) record;

| // Initialize it with a record expression:
| record = (a: 123, b: true);

 The names of named fields in a record type are part of the record‚Äôs type definition, or its shape. .
 Two records with named fields with different names have different types: .

| ({int a, int b}) recordAB = (a: 1, b: 2);
| ({int x, int y}) recordXY = (x: 3, y: 4);

| // Compile error! These records don't have the same type.
| // recordAB = recordXY;

 In a record type annotation, you can also name the positional fields, but these names are .
 purely for documentation and don‚Äôt affect the record‚Äôs type: .

| (int a, int b) recordAB = (1, 2);
| (int x, int y) recordXY = (3, 4);

| recordAB = recordXY; // OK.

 This is similar to how positional parameters in a function declaration or function typedef can have .
 names but those names don‚Äôt affect the signature of the function. .

 For more information and examples, check out Record types and Record equality. .
  
  Record fields. .

 Record fields are accessible through built-in getters. Records are immutable, so fields do not have setters. .

 Named fields expose getters of the same name. Positional fields expose getters of the name $<position>, .
 skipping named fields: .

| var record = ('first', a: 2, b: true, 'last');

| print(record.$1); // Prints 'first'
| print(record.a); // Prints 2
| print(record.b); // Prints true
| print(record.$2); // Prints 'last'

 To streamline record field access even more, check out the page on Patterns. .
 
  Record types. .

 There is no type declaration for individual record types. Records are structurally typed based on the .
 types of their fields. A record‚Äôs shape (the set of its fields, the fields‚Äô types, and their names, if .
 any) uniquely determines the type of a record. .

 Each field in a record has its own type. Field types can differ within the same record. The type system is .
 aware of each field‚Äôs type wherever it is accessed from the record: .

| (num, Object) pair = (42, 'a');

| var first = pair.$1; // Static type `num`, runtime type `int`.
| var second = pair.$2; // Static type `Object`, runtime type `String`.

 Consider two unrelated libraries that create records with the same set of fields. The type system .
 understands that those records are the same type even though the libraries are not coupled to each other. .

  Record equality. .

 Two records are equal if they have the same shape (set of fields), and their corresponding fields .
 have the same values. Since named field order is not part of a record‚Äôs shape, the order of named .
 fields does not affect equality. .

 For example: .

| (int x, int y, int z) point = (1, 2, 3);
| (int r, int g, int b) color = (1, 2, 3);

| print(point == color); // Prints 'true'.

| ({int x, int y, int z}) point = (x: 1, y: 2, z: 3);
| ({int r, int g, int b}) color = (r: 1, g: 2, b: 3);

| print(point == color); // Prints 'false'. Lint: Equals on unrelated types.

 Records automatically define hashCode and == methods based on the structure of their fields. .

  Multiple returns. .

 Records allow functions to return multiple values bundled together. To retrieve record values. .
 from a return, destructure the values into local variables using pattern matching. .

| // Returns multiple values in a record:
| (String, int) userInfo(Map<String, dynamic> json) {
|   return (json['name'] as String, json['age'] as int);
| }

| final json = <String, dynamic>{
|   'name': 'Dash',
|   'age': 10,
|   'color': 'blue',
| };

| // Destructures using a record pattern:
| var (name, age) = userInfo(json);

| /* Equivalent to:
|   var info = userInfo(json);
|   var name = info.$1;
|   var age  = info.$2;
| */

 You can return multiple values from a function without records, but other methods come with downsides. .
 For example, creating a class is much more verbose, and using other collection types like List or Map .
 loses type safety. .


  Collections. .

 Dart has built-in support for list, set, and map collections. To learn more about configuring the types .
 collections contain, check out Generics. .


  Lists. .

 Perhaps the most common collection in nearly every programming language is the array, or ordered group .
 of objects. In Dart, arrays are List objects, so most people just call them lists. .

 Dart list literals are denoted by a comma separated list of expressions or values, enclosed .
 in square brackets ([]). Here‚Äôs a simple Dart list: .

| var list = [1, 2, 3];

 Note: Dart infers that list has type List<int>. If you try to add non-integer objects to this list, .
 the analyzer or runtime raises an error. For more information, read about type inference. .

 You can add a comma after the last item in a Dart collection literal. This trailing comma doesn‚Äôt .
 affect the collection, but it can help prevent copy-paste errors. .

| var list = [
|   'Car',
|   'Boat',
|   'Plane',
| ];

 Lists use zero-based indexing, where 0 is the index of the first value and list.length - 1 is .
 the index of the last value. You can get a list‚Äôs length using the .length property and access .
 a list‚Äôs values using the subscript operator ([]): .

| var list = [1, 2, 3];
| assert(list.length == 3);
| assert(list[1] == 2);

| list[1] = 1;
| assert(list[1] == 1);

To create a list that‚Äôs a compile-time constant, add const before the list literal: ,

| var constantList = const [1, 2, 3];
| // constantList[1] = 1; // This line will cause an error.

 For more information about lists, refer to the Lists section of the Library tour. .

  Sets. .

 A set in Dart is an unordered collection of unique items. Dart support for sets is provided by set .
 literals and the Set type. .

 Here is a simple Dart set, created using a set literal: .

| var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};

 Note: Dart infers that halogens has the type Set<String>. If you try to add the wrong type of value .
 to the set, the analyzer or runtime raises an error. For more information, read about type inference. .

 To create an empty set, use {} preceded by a type argument, or assign {} to a variable of type Set: .

| var names = <String>{};
| // Set<String> names = {}; // This works, too.
| // var names = {}; // Creates a map, not a set.

 Set or map? The syntax for map literals is similar to that for set literals. Because map literals .
 came first, {} defaults to the Map type. If you forget the type annotation on {} or the variable .
 it‚Äôs assigned to, then Dart creates an object of type Map<dynamic, dynamic>. .

 Add items to an existing set using the add() or addAll() methods: .

| var elements = <String>{};
| elements.add('fluorine');
| elements.addAll(halogens);

 Use .length to get the number of items in the set: .

| var elements = <String>{};
| elements.add('fluorine');
| elements.addAll(halogens);
| assert(elements.length == 5);

 To create a set that‚Äôs a compile-time constant, add const before the set literal: .

| final constantSet = const {
|   'fluorine',
|   'chlorine',
|   'bromine',
|   'iodine',
|   'astatine',
| };
| // constantSet.add('helium'); // This line will cause an error.

 For more information about sets, refer to the Sets section of the Library tour. .

  Maps. .

 In general, a map is an object that associates keys and values. Both keys and values can be any .
 type of object. Each key occurs only once, but you can use the same value multiple times. Dart support .
 for maps is provided by map literals and the Map type. .

 Here are a couple of simple Dart maps, created using map literals: .

| var gifts = {
|   // Key:    Value
|   'first': 'partridge',
|   'second': 'turtledoves',
|   'fifth': 'golden rings'
| };

| var nobleGases = {
|   2: 'helium',
|   10: 'neon',
|   18: 'argon',
| };

 Note: Dart infers that gifts has the type Map<String, String> and nobleGases has the type Map<int, .
 String>. If you try to add the wrong type of value to either map, the analyzer or runtime raises an .
 error. For more information, read about type inference. .

 You can create the same objects using a Map constructor: .

| var gifts = Map<String, String>();
| gifts['first'] = 'partridge';
| gifts['second'] = 'turtledoves';
| gifts['fifth'] = 'golden rings';

| var nobleGases = Map<int, String>();
| nobleGases[2] = 'helium';
| nobleGases[10] = 'neon';
| nobleGases[18] = 'argon';

 Note: If you come from a language like C# or Java, you might expect to see new Map() instead .
 of just Map(). In Dart, the new keyword is optional. For details, see Using constructors. .

 Add a new key-value pair to an existing map using the subscript assignment operator ([]=): .

| var gifts = {'first': 'partridge'};
| gifts['fourth'] = 'calling birds'; // Add a key-value pair

 Retrieve a value from a map using the subscript operator ([]): .

| var gifts = {'first': 'partridge'};
| assert(gifts['first'] == 'partridge');

 If you look for a key that isn‚Äôt in a map, you get null in return: .

| var gifts = {'first': 'partridge'};
| assert(gifts['fifth'] == null);

 Use .length to get the number of key-value pairs in the map: .

| var gifts = {'first': 'partridge'};
| gifts['fourth'] = 'calling birds';
| assert(gifts.length == 2);

 To create a map that‚Äôs a compile-time constant, add const before the map literal: .

| final constantMap = const {
|   2: 'helium',
|   10: 'neon',
|   18: 'argon',
| };

| // constantMap[2] = 'Helium'; // This line will cause an error.

 For more information about maps, refer to the Maps section of the Library tour. .
 
  Operators. .

Spread operators. .

 Dart supports the spread operator (...) and the null-aware spread operator (...?) in list, map, .
 and set literals. Spread operators provide a concise way to insert multiple values into a collection. .

For example, you can use the spread operator (...) to insert all the values of a list into another list:

var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);

If the expression to the right of the spread operator might be null, you can avoid exceptions by using a null-aware spread operator (...?):

var list2 = [0, ...?list];
assert(list2.length == 1);

For more details and examples of using the spread operator, see the spread operator proposal.

Control-flow operators

Dart offers collection if and collection for for use in list, map, and set literals. You can use these operators to build collections using conditionals (if) and repetition (for).

Here‚Äôs an example of using collection if to create a list with three or four items in it:

var nav = ['Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];

Dart also supports if-case inside collection literals:

var nav = ['Home', 'Furniture', 'Plants', if (login case 'Manager') 'Inventory'];

Here‚Äôs an example of using collection for to manipulate the items of a list before adding them to another list:

var listOfInts = [1, 2, 3];
var listOfStrings = ['#0', for (var i in listOfInts) '#$i'];
assert(listOfStrings[1] == '#1');

For more details and examples of using collection if and for, see the control flow collections proposal.

Generics

If you look at the API documentation for the basic array type, List, you‚Äôll see that the type is actually List<E>. The <‚Ä¶> notation marks List as a generic (or parameterized) type‚Äîa type that has formal type parameters. By convention, most type variables have single-letter names, such as E, T, S, K, and V.
Why use generics?

Generics are often required for type safety, but they have more benefits than just allowing your code to run:

    Properly specifying generic types results in better generated code.
    You can use generics to reduce code duplication.

If you intend for a list to contain only strings, you can declare it as List<String> (read that as ‚Äúlist of string‚Äù). That way you, your fellow programmers, and your tools can detect that assigning a non-string to the list is probably a mistake. Here‚Äôs an example:

var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
names.add(42); // Error

Another reason for using generics is to reduce code duplication. Generics let you share a single interface and implementation between many types, while still taking advantage of static analysis. For example, say you create an interface for caching an object:

abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}

You discover that you want a string-specific version of this interface, so you create another interface:

abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}

Later, you decide you want a number-specific version of this interface‚Ä¶ You get the idea.

Generic types can save you the trouble of creating all these interfaces. Instead, you can create a single interface that takes a type parameter:

abstract class Cache<T> {
  T getByKey(String key);
  void setByKey(String key, T value);
}

In this code, T is the stand-in type. It‚Äôs a placeholder that you can think of as a type that a developer will define later.
Using collection literals

List, set, and map literals can be parameterized. Parameterized literals are just like the literals you‚Äôve already seen, except that you add <type> (for lists and sets) or <keyType, valueType> (for maps) before the opening bracket. Here is an example of using typed literals:

var names = <String>['Seth', 'Kathy', 'Lars'];
var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};
var pages = <String, String>{
  'index.html': 'Homepage',
  'robots.txt': 'Hints for web robots',
  'humans.txt': 'We are people, not machines'
};

Using parameterized types with constructors

To specify one or more types when using a constructor, put the types in angle brackets (<...>) just after the class name. For example:

var nameSet = Set<String>.from(names);

The following code creates a map that has integer keys and values of type View:

var views = Map<int, View>();

Generic collections and the types they contain

Dart generic types are reified, which means that they carry their type information around at runtime. For example, you can test the type of a collection:

var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true

Note: In contrast, generics in Java use erasure, which means that generic type parameters are removed at runtime. In Java, you can test whether an object is a List, but you can‚Äôt test whether it‚Äôs a List<String>.
Restricting the parameterized type

When implementing a generic type, you might want to limit the types that can be provided as arguments, so that the argument must be a subtype of a particular type. You can do this using extends.

A common use case is ensuring that a type is non-nullable by making it a subtype of Object (instead of the default, Object?).

class Foo<T extends Object> {
  // Any type provided to Foo for T must be non-nullable.
}

You can use extends with other types besides Object. Here‚Äôs an example of extending SomeBaseClass, so that members of SomeBaseClass can be called on objects of type T:

class Foo<T extends SomeBaseClass> {
  // Implementation goes here...
  String toString() => "Instance of 'Foo<$T>'";
}

class Extender extends SomeBaseClass {...}

It‚Äôs OK to use SomeBaseClass or any of its subtypes as the generic argument:

var someBaseClassFoo = Foo<SomeBaseClass>();
var extenderFoo = Foo<Extender>();

It‚Äôs also OK to specify no generic argument:

var foo = Foo();
print(foo); // Instance of 'Foo<SomeBaseClass>'

Specifying any non-SomeBaseClass type results in an error:

var foo = Foo<Object>();

Using generic methods

Methods and functions also allow type arguments:

T first<T>(List<T> ts) {
  // Do some initial work or error checking, then...
  T tmp = ts[0];
  // Do some additional checking or processing...
  return tmp;
}

Here the generic type parameter on first (<T>) allows you to use the type argument T in several places:

    In the function‚Äôs return type (T).
    In the type of an argument (List<T>).
    In the type of a local variable (T tmp).
Typedefs

A type alias‚Äîoften called a typedef because it‚Äôs declared with the keyword typedef‚Äîis a concise way to refer to a type. Here‚Äôs an example of declaring and using a type alias named IntList:

typedef IntList = List<int>;
IntList il = [1, 2, 3];

A type alias can have type parameters:

typedef ListMapper<X> = Map<X, List<X>>;
Map<String, List<String>> m1 = {}; // Verbose.
ListMapper<String> m2 = {}; // Same thing but shorter and clearer.

Version note: Before 2.13, typedefs were restricted to function types. Using the new typedefs requires a language version of at least 2.13.

We recommend using inline function types instead of typedefs for functions, in most situations. However, function typedefs can still be useful:

typedef Compare<T> = int Function(T a, T b);

int sort(int a, int b) => a - b;

void main() {
  assert(sort is Compare<int>); // True!
}

The Dart type system

The Dart language is type safe: it uses a combination of static type checking and runtime checks to ensure that a variable‚Äôs value always matches the variable‚Äôs static type, sometimes referred to as sound typing. Although types are mandatory, type annotations are optional because of type inference.

One benefit of static type checking is the ability to find bugs at compile time using Dart‚Äôs static analyzer.

You can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types List<T> and Map<K,V>.

For example, in the following code the printInts() function prints an integer list, and main() creates a list and passes it to printInts().

void printInts(List<int> a) => print(a);

void main() {
  final list = [];
  list.add(1);
  list.add('2');
  printInts(list);
}

The preceding code results in a type error on list (highlighted above) at the call of printInts(list):

error - The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'. - argument_type_not_assignable

The error highlights an unsound implicit cast from List<dynamic> to List<int>. The list variable has static type List<dynamic>. This is because the initializing declaration var list = [] doesn‚Äôt provide the analyzer with enough information for it to infer a type argument more specific than dynamic. The printInts() function expects a parameter of type List<int>, causing a mismatch of types.

When adding a type annotation (<int>) on creation of the list (highlighted below) the analyzer complains that a string argument can‚Äôt be assigned to an int parameter. Removing the quotes in list.add('2') results in code that passes static analysis and runs with no errors or warnings.

void printInts(List<int> a) => print(a);

void main() {
  final list = <int>[];
  list.add(1);
  list.add(2);
  printInts(list);
}

Try it in DartPad.
What is soundness?

Soundness is about ensuring your program can‚Äôt get into certain invalid states. A sound type system means you can never get into a state where an expression evaluates to a value that doesn‚Äôt match the expression‚Äôs static type. For example, if an expression‚Äôs static type is String, at runtime you are guaranteed to only get a string when you evaluate it.

Dart‚Äôs type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a String to int is a compile-time error. Casting an object to a String using as String fails with a runtime error if the object isn‚Äôt a String.
The benefits of soundness

A sound type system has several benefits:

    Revealing type-related bugs at compile time.
    A sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.

    More readable code.
    Code is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can‚Äôt lie.

    More maintainable code.
    With a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.

    Better ahead of time (AOT) compilation.
    While AOT compilation is possible without types, the generated code is much less efficient.

Tips for passing static analysis

Most of the rules for static types are easy to understand. Here are some of the less obvious rules:

    Use sound return types when overriding methods.
    Use sound parameter types when overriding methods.
    Don‚Äôt use a dynamic list as a typed list.

Let‚Äôs see these rules in detail, with examples that use the following type hierarchy:

a hierarchy of animals where the supertype is Animal and the subtypes are Alligator, Cat, and HoneyBadger. Cat has the subtypes of Lion and MaineCoon

Use sound return types when overriding methods

The return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the Animal class:

class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

The parent getter method returns an Animal. In the HoneyBadger subclass, you can replace the getter‚Äôs return type with HoneyBadger (or any other subtype of Animal), but an unrelated type is not allowed.

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }

  @override
  HoneyBadger get parent => ...
}

class HoneyBadger extends Animal {
  @override
  void chase(Animal a) { ... }
  
  @override
  Root get parent => ...
}

Use sound parameter types when overriding methods

The parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don‚Äôt ‚Äútighten‚Äù the parameter type by replacing the type with a subtype of the original parameter.

Note: If you have a valid reason to use a subtype, you can use the covariant keyword.

Consider the chase(Animal) method for the Animal class:

class Animal {
  void chase(Animal a) { ... }
  Animal get parent => ...
}

The chase() method takes an Animal. A HoneyBadger chases anything. It‚Äôs OK to override the chase() method to take anything (Object).

class HoneyBadger extends Animal {
  @override
  void chase(Object a) { ... }

  @override
  Animal get parent => ...
}

The following code tightens the parameter on the chase() method from Animal to Mouse, a subclass of Animal.

class Mouse extends Animal {...}

class Cat extends Animal {
  @override
  void chase(Mouse x) { ... }
}

This code is not type safe because it would then be possible to define a cat and send it after an alligator:

Animal a = Cat();
a.chase(Alligator()); // Not type safe or feline safe.

Don‚Äôt use a dynamic list as a typed list

A dynamic list is good when you want to have a list with different kinds of things in it. However, you can‚Äôt use a dynamic list as a typed list.

This rule also applies to instances of generic types.

The following code creates a dynamic list of Dog, and assigns it to a list of type Cat, which generates an error during static analysis.

class Cat extends Animal { ... }

class Dog extends Animal { ... }

void main() {
  List<Cat> foo = <dynamic>[Dog()]; // Error
  List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK
}

Runtime checks

Runtime checks deal with type safety issues that can‚Äôt be detected at compile time.

For example, the following code throws an exception at runtime because it‚Äôs an error to cast a list of dogs to a list of cats:

void main() {
  List<Animal> animals = [Dog()];
  List<Cat> cats = animals as List<Cat>;
}

Type inference

The analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn‚Äôt have enough information to infer a specific type, it uses the dynamic type.

Here‚Äôs an example of how type inference works with generics. In this example, a variable named arguments holds a map that pairs string keys with values of various types.

If you explicitly type the variable, you might write this:

Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};

Alternatively, you can use var or final and let Dart infer the type:

var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>

The map literal infers its type from its entries, and then the variable infers its type from the map literal‚Äôs type. In this map, the keys are both strings, but the values have different types (String and int, which have the upper bound Object). So the map literal has the type Map<String, Object>, and so does the arguments variable.
Field and method inference

A field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.

A field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.
Static field inference

Static fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).
Local variable inference

Local variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.

var x = 3; // x is inferred as an int.
x = 4.0;

num y = 3; // A num can be double or int.
y = 4.0;

Type argument inference

Type arguments to constructor calls and generic method invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.

// Inferred as if you wrote <int>[].
List<int> listOfInt = [];

// Inferred as if you wrote <double>[3.0].
var listOfDouble = [3.0];

// Inferred as Iterable<int>.
var ints = listOfDouble.map((x) => x.toInt());

In the last example, x is inferred as double using downward information. The return type of the closure is inferred as int using upward information. Dart uses this return type as upward information when inferring the map() method‚Äôs type argument: <int>.
Substituting types

When you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?

When substituting types, it helps to think in terms of consumers and producers. A consumer absorbs a type and a producer generates a type.

You can replace a consumer‚Äôs type with a supertype and a producer‚Äôs type with a subtype.

Let‚Äôs look at examples of simple type assignment and assignment with generic types.
Simple type assignment

When assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.

Consider the following type hierarchy:

a hierarchy of animals where the supertype is Animal and the subtypes are Alligator, Cat, and HoneyBadger. Cat has the subtypes of Lion and MaineCoon

Consider the following simple assignment where Cat c is a consumer and Cat() is a producer:

Cat c = Cat();

In a consuming position, it‚Äôs safe to replace something that consumes a specific type (Cat) with something that consumes anything (Animal), so replacing Cat c with Animal c is allowed, because Animal is a supertype of Cat.

Animal c = Cat();

But replacing Cat c with MaineCoon c breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as Lion:

MaineCoon c = Cat();

In a producing position, it‚Äôs safe to replace something that produces a type (Cat) with a more specific type (MaineCoon). So, the following is allowed:

Cat c = MaineCoon();

Generic type assignment

Are the rules the same for generic types? Yes. Consider the hierarchy of lists of animals‚Äîa List of Cat is a subtype of a List of Animal, and a supertype of a List of MaineCoon:

List<Animal> -> List<Cat> -> List<MaineCoon>

In the following example, you can assign a MaineCoon list to myCats because List<MaineCoon> is a subtype of List<Cat>:

List<MaineCoon> myMaineCoons = ...
List<Cat> myCats = myMaineCoons;

What about going in the other direction? Can you assign an Animal list to a List<Cat>?

List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals;

This assignment doesn‚Äôt pass static analysis because it creates an implicit downcast, which is disallowed from non-dynamic types such as Animal.

To make this type of code pass static analysis, you can use an explicit cast.

List<Animal> myAnimals = ...
List<Cat> myCats = myAnimals as List<Cat>;

An explicit cast might still fail at runtime, though, depending on the actual type of the list being cast (myAnimals).
Methods

When overriding a method, the producer and consumer rules still apply. For example:

Animal class showing the chase method as the consumer and the parent getter as the producer

For a consumer (such as the chase(Animal) method), you can replace the parameter type with a supertype. For a producer (such as the parent getter method), you can replace the return type with a subtype.

For more information, see Use sound return types when overriding methods and Use sound parameter types when overriding methods.

Patterns

Version note: Patterns require a language version of at least 3.0.

Patterns are a syntactic category in the Dart language, like statements and expressions. A pattern represents the shape of a set of values that it may match against actual values.

This page describes:

    What patterns do.
    Where patterns are allowed in Dart code.
    What the common use cases for patterns are.

To learn about the different kinds of patterns, visit the pattern types page.
What patterns do

In general, a pattern may match a value, destructure a value, or both, depending on the context and shape of the pattern.

First, pattern matching allows you to check whether a given value:

    Has a certain shape.
    Is a certain constant.
    Is equal to something else.
    Has a certain type.

Then, pattern destructuring provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to some or all of those parts in the process.
Matching

A pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the value matches the pattern.

What constitutes a match depends on what kind of pattern you are using. For example, a constant pattern matches if the value is equal to the pattern‚Äôs constant:

switch (number) {
  // Constant pattern matches if 1 == number.
  case 1:
    print('one');
}

Many patterns make use of subpatterns, sometimes called outer and inner patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of any collection-type pattern could be variable patterns or constant patterns:

const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}

To ignore parts of a matched value, you can use a wildcard pattern as a placeholder. In the case of list patterns, you can use a rest element.
Destructuring

When an object and pattern match, the pattern can then access the object‚Äôs data and extract it in parts. In other words, the pattern destructures the object:

var numList = [1, 2, 3];
// List pattern [a, b, c] destructures the three elements from numList...
var [a, b, c] = numList;
// ...and assigns them to new variables.
print(a + b + c);

You can nest any kind of pattern inside a destructuring pattern. For example, this case pattern matches and destructures a two-element list whose first element is a or b:

switch (list) {
  case ['a' || 'b', var c]:
    print(c);
}

Places patterns can appear

You can use patterns in several places in the Dart language:

    Local variable declarations and assignments
    for and for-in loops
    if-case and switch-case
    Control flow in collection literals

This section describes common use cases for matching and destructuring with patterns.
Variable declaration

You can use a pattern variable declaration anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:

// Declares new variables a, b, and c.
var (a, [b, c]) = ('str', [1, 2]);

A pattern variable declaration must start with either var or final, followed by a pattern.
Variable assignment

A variable assignment pattern falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values to existing variables, instead of binding new ones.

Use a variable assignment pattern to swap the values of two variables without declaring a third temporary one:

var (a, b) = ('left', 'right');
(b, a) = (a, b); // Swap.
print('$a $b'); // Prints "right left".

Switch statements and expressions

Every case clause contains a pattern. This applies to switch statements and expressions, as well as if-case statements. You can use any kind of pattern in a case.

Case patterns are refutable. They allow control flow to either:

    Match and destructure the object being switched on.
    Continue execution if the object doesn‚Äôt match.

The values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.

switch (obj) {
  // Matches if 1 == obj.
  case 1:
    print('one');

  // Matches if the value of obj is between the constant values of 'first' and 'last'.
  case >= first && <= last:
    print('in range');

  // Matches if obj is a record with two fields, then assigns the fields to 'a' and 'b'.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}

Logical-or patterns are useful for having multiple cases share a body in switch expressions or statements:

var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};

Switch statements can have multiple cases share a body without using logical-or patterns, but they are still uniquely useful for allowing multiple cases to share a guard:

switch (shape) {
  case Square(size: var s) || Circle(size: var s) when s > 0:
    print('Non-empty symmetric shape');
}

For and for-in loops

You can use patterns in for and for-in loops to iterate-over and destructure values in a collection.

This example uses object destructuring in a for-in loop to destructure the MapEntry objects that a <Map>.entries call returns:

Map<String, int> hist = {
  'a': 23,
  'b': 100,
};

for (var MapEntry(key: key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

The object pattern checks that hist.entries has the named type MapEntry, and then recurses into the named field subpatterns key and value. It calls the key getter and value getter on the MapEntry in each iteration, and binds the results to local variables key and count, respectively.

Binding the result of a getter call to a variable of the same name is a common use case, so object patterns can also infer the getter name from the variable subpattern. This allows you to simplify the variable pattern from something redundant like key: key to just :key:

for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

Uses cases for patterns

The previous section describes how patterns fit into other Dart code constructs. You saw some interesting uses cases as examples, like swapping the values of two variables, or destructuring key-value pairs in a map. This section describes even more use cases, answering:

    When and why you might want to use patterns.
    What kinds of problems they solve.
    Which idioms they best suit.

Destructuring multiple returns

Records allow aggregating and returning multiple values from a single function call. Patterns add the ability to destructure a record‚Äôs fields directly into local variables, inline with the function call.

Instead of individually declaring new local variables for each record field, like this:

var info = userInfo(json);
var name = info.$1;
var age = info.$2;

You can destructure the fields of a record that a function returns into local variables using a variable declaration or assigment pattern, and a record pattern as its subpattern:

var (name, age) = userInfo(json);

Destructuring class instances

Object patterns match against named object types, allowing you to destructure their data using the getters the object‚Äôs class already exposes.

To destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:

final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');

Algebraic data types

Object destructuring and switch cases are conducive to writing code in an algebraic data type style. Use this method when:

    You have a family of related types.
    You have an operation that needs specific behavior for each type.
    You want to group that behavior in one place instead of spreading it across all the different type definitions.

Instead of implementing the operation as an instance method for every type, keep the operation‚Äôs variations in a single function that switches over the subtypes:

sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
      Square(length: var l) => l * l,
      Circle(radius: var r) => math.pi * r * r
    };

Validating incoming JSON

Map and list patterns work well for destructuring key-value pairs in JSON data:

var json = {
  'user': ['Lily', 13]
};
var {'user': [name, age]} = json;

If you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.

Without patterns, validation is verbose:

if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  var user = json['user'];
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    var name = user[0] as String;
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}

A single case pattern can achieve the same validation. Single cases work best as if-case statements. Patterns provide a more declarative, and much less verbose method of validating JSON:

if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}

This case pattern simultaneously validates that:

    json is a map, because it must first match the outer map pattern to proceed.
        And, since it‚Äôs a map, it also confirms json is not null.
    json contains a key user.
    The key user pairs with a list of two values.
    The types of the list values are String and int.
    The new local variables to hold the values are String and int.


Pattern types

This page is a reference for the different kinds of patterns. For an overview of how patterns work, where you can use them in Dart, and common use cases, visit the main Patterns page.
Pattern precedence

Similar to operator precedence, pattern evaluation adheres to precedence rules. You can use parenthesized patterns to evaluate lower-precedence patterns first.

This document lists the pattern types in ascending order of precedence:

    Logical-or patterns are lower-precedence than logical-and, logical-and patterns are lower-precedence than relational patterns, and so on.

    Post-fix unary patterns (cast, null-check, and null-assert) share the same level of precedence.

    The remaining primary patterns share the highest precedence. Collection-type (record, list, and map) and Object patterns encompass other data, so are evaluated first as outer-patterns.

Logical-or

subpattern1 || subpattern2

A logical-or pattern separates subpatterns by || and matches if any of the branches match. Branches are evaluated left-to-right. Once a branch matches, the rest are not evaluated.

var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};

Subpatterns in a logical-or pattern can bind variables, but the branches must define the same set of variables, because only one branch will be evaluated when the pattern matches.
Logical-and

subpattern1 && subpattern2

A pair of patterns separated by && matches only if both subpatterns match. If the left branch does not match, the right branch is not evaluated.

Subpatterns in a logical-and pattern can bind variables, but the variables in each subpattern must not overlap, because they will both be bound if the pattern matches:

switch ((1, 2)) {
  // Error, both subpatterns attempt to bind 'b'.
  case (var a, var b) && (var b, var c): // ...
}

Relational

== expression

< expression

Relational patterns compare the matched value to a given constant using any of the equality or relational operators: ==, !=, <, >, <=, and >=.

The pattern matches when calling the appropriate operator on the matched value with the constant as an argument returns true.

Relational patterns are useful for matching on numeric ranges, especially when combined with the logical-and pattern:

String asciiCharType(int char) {
  const space = 32;
  const zero = 48;
  const nine = 57;

  return switch (char) {
    < space => 'control',
    == space => 'space',
    > space && < zero => 'punctuation',
    >= zero && <= nine => 'digit',
    _ => ''
  };
}

Cast

foo as String

A cast pattern lets you insert a type cast in the middle of destructuring, before passing the value to another subpattern:

(num, Object) record = (1, 's');
var (i as int, s as String) = record;

Cast patterns will throw if the value doesn‚Äôt have the stated type. Like the null-assert pattern, this lets you forcibly assert the expected type of some destructured value.
Null-check

subpattern?

Null-check patterns match first if the value is not null, and then match the inner pattern against that same value. They let you bind a variable whose type is the non-nullable base type of the nullable value being matched.

To treat null values as match failures without throwing, use the null-check pattern.

String? maybeString = 'nullable with base type String';
switch (maybeString) {
  case var s?:
  // 's' has type non-nullable String here.
}

To match when the value is null, use the constant pattern null.
Null-assert

subpattern!

Null-assert patterns match first if the object is not null, then on the value. They permit non-null values to flow through, but throw if the matched value is null.

To ensure null values are not silently treated as match failures, use a null-assert pattern while matching:

List<String?> row = ['user', null];
switch (row) {
  case ['user', var name!]: // ...
  // 'name' is a non-nullable string here.
}

To eliminate null values from variable declaration patterns, use the null-assert pattern:

(int?, int?) position = (2, 3);

var (x!, y!) = position;

To match when the value is null, use the constant pattern null.
Constant

123, null, 'string', math.pi, SomeClass.constant, const Thing(1, 2), const (1 + 2)

Constant patterns match when the value is equal to the constant:

switch (number) {
  // Matches if 1 == number.
  case 1: // ...
}

You can use simple literals and references to named constants directly as constant patterns:

    Number literals (123, 45.56)
    Boolean literals (true)
    String literals ('string')
    Named constants (someConstant, math.pi, double.infinity)
    Constant constructors (const Point(0, 0))
    Constant collection literals (const [], const {1, 2})

More complex constant expressions must be parenthesized and prefixed with const (const (1 + 2)):

// List or map pattern:
case [a, b]: // ...

// List or map literal:
case const [a, b]: // ...

Variable

var bar, String str, final int _

Variable patterns bind new variables to values that have been matched or destructured. They usually occur as part of a destructuring pattern to capture a destructured value.

The variables are in scope in a region of code that is only reachable when the pattern has matched.

switch ((1, 2)) {
  // 'var a' and 'var b' are variable patterns that bind to 1 and 2, respectively.
  case (var a, var b): // ...
  // 'a' and 'b' are in scope in the case body.
}

A typed variable pattern only matches if the matched value has the declared type, and fails otherwise:

switch ((1, 2)) {
  // Does not match.
  case (int a, String b): // ...
}

You can use a wildcard pattern as a variable pattern.
Identifier

foo, _

Identifier patterns may behave like a constant pattern or like a variable pattern, depending on the context where they appear:

    Declaration context: declares a new variable with identifier name: var (a, b) = (1, 2);
    Assignment context: assigns to existing variable with identifier name: (a, b) = (3, 4);

    Matching context: treated as a named constant pattern (unless its name is _):

    const c = 1;
    switch (2) {
      case c:
        print('match $c');
      default:
        print('no match'); // Prints "no match".
    }

    Wildcard identifier in any context: matches any value and discards it: case [_, var y, _]: print('The middle element is $y');

Parenthesized

(subpattern)

Like parenthesized expressions, parentheses in a pattern let you control pattern precedence and insert a lower-precedence pattern where a higher precedence one is expected.

For example, imagine the boolean constants x, y, and z are equal to true, true, and false, respectively:

// ...
x || y && z => 'matches true',
(x || y) && z => 'matches false',
// ...

In the first case, the logical-and pattern y && z evaluates first because logical-and patterns have higher precedence than logical-or. In the next case, the logical-or pattern is parenthesized. It evaluates first, which results in a different match.
List

[subpattern1, subpattern2]

A list pattern matches values that implement List, and then recursively matches its subpatterns against the list‚Äôs elements to destructure them by position:

const a = 'a';
const b = 'b';
switch (obj) {
  // List pattern [a, b] matches obj first if obj is a list with two fields,
  // then if its fields match the constant subpatterns 'a' and 'b'.
  case [a, b]:
    print('$a, $b');
}

List patterns require that the number of elements in the pattern match the entire list. You can, however, use a rest element as a place holder to account for any number of elements in a list.
Rest element

List patterns can contain one rest element (...) which allows matching lists of arbitrary lengths.

var [a, b, ..., c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 6 7".
print('$a $b $c $d');

A rest element can also have a subpattern that collects elements that don‚Äôt match the other subpatterns in the list, into a new list:

var [a, b, ...rest, c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 [3, 4, 5] 6 7".
print('$a $b $rest $c $d');

Map

{"key": subpattern1, someConst: subpattern2}

Map patterns match values that implement Map, and then recursively match its subpatterns against the map‚Äôs keys to destructure them.

Map patterns don‚Äôt require the pattern to match the entire map. A map pattern ignores any keys that the map contains that aren‚Äôt matched by the pattern.
Record

(subpattern1, subpattern2)

(x: subpattern1, y: subpattern2)

Record patterns match a record object and destructure its fields. If the value isn‚Äôt a record with the same shape as the pattern, the match fails. Otherwise, the field subpatterns are matched against the corresponding fields in the record.

Record patterns require that the pattern match the entire record. To destructure a record with named fields using a pattern, include the field names in the pattern:

var (myString: foo, myNumber: bar) = (myString: 'string', myNumber: 1);

The getter name can be omitted and inferred from the variable pattern or identifier pattern in the field subpattern. These pairs of patterns are each equivalent:

// Record pattern with variable subpatterns:
var (untyped: untyped, typed: int typed) = record;
var (:untyped, :int typed) = record;

switch (record) {
  case (untyped: var untyped, typed: int typed): // ...
  case (:var untyped, :int typed): // ...
}

// Record pattern wih null-check and null-assert subpatterns:
switch (record) {
  case (checked: var checked?, asserted: var asserted!): // ...
  case (:var checked?, :var asserted!): // ...
}

// Record pattern wih cast subpattern:
var (untyped: untyped as int, typed: typed as String) = record;
var (:untyped as int, :typed as String) = record;

Object

SomeClass(x: subpattern1, y: subpattern2)

Object patterns check the matched value against a given named type to destructure data using getters on the object‚Äôs properties. They are refuted if the value doesn‚Äôt have the same type.

switch (shape) {
  // Matches if shape is of type Rect, and then against the properties of Rect.
  case Rect(width: var w, height: var h): // ...
}

The getter name can be omitted and inferred from the variable pattern or identifier pattern in the field subpattern:

// Binds new variables x and y to the values of Point's x and y properties.
var Point(:x, :y) = Point(1, 2);

Object patterns don‚Äôt require the pattern to match the entire object. If an object has extra fields that the pattern doesn‚Äôt destructure, it can still match.
Wildcard

_

A pattern named _ is a wildcard, either a variable pattern or identifier pattern, that doesn‚Äôt bind or assign to any variable.

It‚Äôs useful as a placeholder in places where you need a subpattern in order to destructure later positional values:

var list = [1, 2, 3];
var [_, two, _] = list;

A wildcard name with a type annotation is useful when you want to test a value‚Äôs type but not bind the value to a name:

switch (record) {
  case (int _, String _):
    print('First field is int and second is String.');
}

Functions

Dart is a true object-oriented language, so even functions are objects and have a type, Function. This means that functions can be assigned to variables or passed as arguments to other functions. You can also call an instance of a Dart class as if it were a function. For details, see Callable objects.

Here‚Äôs an example of implementing a function:

bool isNoble(int atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

Although Effective Dart recommends type annotations for public APIs, the function still works if you omit the types:

isNoble(atomicNumber) {
  return _nobleGases[atomicNumber] != null;
}

For functions that contain just one expression, you can use a shorthand syntax:

bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;

The => expr syntax is a shorthand for { return expr; }. The => notation is sometimes referred to as arrow syntax.

Note: Only an expression‚Äînot a statement‚Äîcan appear between the arrow (=>) and the semicolon (;). For example, you can‚Äôt put an if statement there, but you can use a conditional expression.
Parameters

A function can have any number of required positional parameters. These can be followed either by named parameters or by optional positional parameters (but not both).

Note: Some APIs‚Äînotably Flutter widget constructors‚Äîuse only named parameters, even for parameters that are mandatory. See the next section for details.

You can use trailing commas when you pass arguments to a function or when you define function parameters.
Named parameters

Named parameters are optional unless they‚Äôre explicitly marked as required.

When defining a function, use {param1, param2, ‚Ä¶} to specify named parameters. If you don‚Äôt provide a default value or mark a named parameter as required, their types must be nullable as their default value will be null:

/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool? bold, bool? hidden}) {...}

When calling a function, you can specify named arguments using paramName: value. For example:

enableFlags(bold: true, hidden: false);

To define a default value for a named parameter besides null, use = to specify a default value. The specified value must be a compile-time constant. For example:

/// Sets the [bold] and [hidden] flags ...
void enableFlags({bool bold = false, bool hidden = false}) {...}

// bold will be true; hidden will be false.
enableFlags(bold: true);

If you instead want a named parameter to be mandatory, requiring callers to provide a value for the parameter, annotate them with required:

const Scrollbar({super.key, required Widget child});

If someone tries to create a Scrollbar without specifying the child argument, then the analyzer reports an issue.

Note: A parameter marked as required can still be nullable:

const Scrollbar({super.key, required Widget? child});

You might want to place positional arguments first, but Dart doesn‚Äôt require it. Dart allows named arguments to be placed anywhere in the argument list when it suits your API:

repeat(times: 2, () {
  ...
});

Optional positional parameters

Wrapping a set of function parameters in [] marks them as optional positional parameters. If you don‚Äôt provide a default value, their types must be nullable as their default value will be null:

String say(String from, String msg, [String? device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}

Here‚Äôs an example of calling this function without the optional parameter:

assert(say('Bob', 'Howdy') == 'Bob says Howdy');

And here‚Äôs an example of calling this function with the third parameter:

assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');

To define a default value for an optional positional parameter besides null, use = to specify a default value. The specified value must be a compile-time constant. For example:

String say(String from, String msg, [String device = 'carrier pigeon']) {
  var result = '$from says $msg with a $device';
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');

The main() function

Every app must have a top-level main() function, which serves as the entrypoint to the app. The main() function returns void and has an optional List<String> parameter for arguments.

Here‚Äôs a simple main() function:

void main() {
  print('Hello, World!');
}

Here‚Äôs an example of the main() function for a command-line app that takes arguments:

// Run the app like this: dart args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}

You can use the args library to define and parse command-line arguments.
Functions as first-class objects

You can pass a function as a parameter to another function. For example:

void printElement(int element) {
  print(element);
}

var list = [1, 2, 3];

// Pass printElement as a parameter.
list.forEach(printElement);

You can also assign a function to a variable, such as:

var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';
assert(loudify('hello') == '!!! HELLO !!!');

This example uses an anonymous function. More about those in the next section.
Anonymous functions

Most functions are named, such as main() or printElement(). You can also create a nameless function called an anonymous function, or sometimes a lambda or closure. You might assign an anonymous function to a variable so that, for example, you can add or remove it from a collection.

An anonymous function looks similar to a named function‚Äîzero or more parameters, separated by commas and optional type annotations, between parentheses.

The code block that follows contains the function‚Äôs body:

([[Type] param1[, ‚Ä¶]]) {
  codeBlock;
};

The following example defines an anonymous function with an untyped parameter, item, and passes it to the map function. The function, invoked for each item in the list, converts each string to uppercase. Then in the anonymous function passed to forEach, each converted string is printed out alongside its length.

const list = ['apples', 'bananas', 'oranges'];
list.map((item) {
  return item.toUpperCase();
}).forEach((item) {
  print('$item: ${item.length}');
});

Click Run to execute the code.

If the function contains only a single expression or return statement, you can shorten it using arrow notation. Paste the following line into DartPad and click Run to verify that it is functionally equivalent.

list
    .map((item) => item.toUpperCase())
    .forEach((item) => print('$item: ${item.length}'));

Lexical scope

Dart is a lexically scoped language, which means that the scope of variables is determined statically, simply by the layout of the code. You can ‚Äúfollow the curly braces outwards‚Äù to see if a variable is in scope.

Here is an example of nested functions with variables at each scope level:

bool topLevel = true;

void main() {
  var insideMain = true;

  void myFunction() {
    var insideFunction = true;

    void nestedFunction() {
      var insideNestedFunction = true;

      assert(topLevel);
      assert(insideMain);
      assert(insideFunction);
      assert(insideNestedFunction);
    }
  }
}

Notice how nestedFunction() can use variables from every level, all the way up to the top level.
Lexical closures

A closure is a function object that has access to variables in its lexical scope, even when the function is used outside of its original scope.

Functions can close over variables defined in surrounding scopes. In the following example, makeAdder() captures the variable addBy. Wherever the returned function goes, it remembers addBy.

/// Returns a function that adds [addBy] to the
/// function's argument.
Function makeAdder(int addBy) {
  return (int i) => addBy + i;
}

void main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}

Testing functions for equality

Here‚Äôs an example of testing top-level functions, static methods, and instance methods for equality:

void foo() {} // A top-level function

class A {
  static void bar() {} // A static method
  void baz() {} // An instance method
}

void main() {
  Function x;

  // Comparing top-level functions.
  x = foo;
  assert(foo == x);

  // Comparing static methods.
  x = A.bar;
  assert(A.bar == x);

  // Comparing instance methods.
  var v = A(); // Instance #1 of A
  var w = A(); // Instance #2 of A
  var y = w;
  x = w.baz;

  // These closures refer to the same instance (#2),
  // so they're equal.
  assert(y.baz == x);

  // These closures refer to different instances,
  // so they're unequal.
  assert(v.baz != w.baz);
}

Return values

All functions return a value. If no return value is specified, the statement return null; is implicitly appended to the function body.

foo() {}

assert(foo() == null);

To return multiple values in a function, aggregate the values in a record.

(String, int) foo() {
  return ('something', 42);
}

Generators

When you need to lazily produce a sequence of values, consider using a generator function. Dart has built-in support for two kinds of generator functions:

    Synchronous generator: Returns an Iterable object.
    Asynchronous generator: Returns a Stream object.

To implement a synchronous generator function, mark the function body as sync*, and use yield statements to deliver values:

Iterable<int> naturalsTo(int n) sync* {
  int k = 0;
  while (k < n) yield k++;
}

To implement an asynchronous generator function, mark the function body as async*, and use yield statements to deliver values:

Stream<int> asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k < n) yield k++;
}

If your generator is recursive, you can improve its performance by using yield*:

Iterable<int> naturalsDownFrom(int n) sync* {
  if (n > 0) {
    yield n;
    yield* naturalsDownFrom(n - 1);
  }
}

Error handling
Exceptions

Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn‚Äôt caught, the isolate that raised the exception is suspended, and typically the isolate and its program are terminated.

In contrast to Java, all of Dart‚Äôs exceptions are unchecked exceptions. Methods don‚Äôt declare which exceptions they might throw, and you aren‚Äôt required to catch any exceptions.

Dart provides Exception and Error types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object‚Äînot just Exception and Error objects‚Äîas an exception.
Throw

Here‚Äôs an example of throwing, or raising, an exception:

throw FormatException('Expected at least 1 section');

You can also throw arbitrary objects:

throw 'Out of llamas!';

Note: Production-quality code usually throws types that implement Error or Exception.

Because throwing an exception is an expression, you can throw exceptions in => statements, as well as anywhere else that allows expressions:

void distanceTo(Point other) => throw UnimplementedError();

Catch

Catching, or capturing, an exception stops the exception from propagating (unless you rethrow the exception). Catching an exception gives you a chance to handle it:

try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
}

To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object‚Äôs type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:

try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}

As the preceding code shows, you can use either on or catch or both. Use on when you need to specify the exception type. Use catch when your exception handler needs the exception object.

You can specify one or two parameters to catch(). The first is the exception that was thrown, and the second is the stack trace (a StackTrace object).

try {
  // ¬∑¬∑¬∑
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}

To partially handle an exception, while allowing it to propagate, use the rethrow keyword.

void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Allow callers to see the exception.
  }
}

void main() {
  try {
    misbehave();
  } catch (e) {
    print('main() finished handling ${e.runtimeType}.');
  }
}

Finally

To ensure that some code runs whether or not an exception is thrown, use a finally clause. If no catch clause matches the exception, the exception is propagated after the finally clause runs:

try {
  breedMoreLlamas();
} finally {
  // Always clean up, even if an exception is thrown.
  cleanLlamaStalls();
}

The finally clause runs after any matching catch clauses:

try {
  breedMoreLlamas();
} catch (e) {
  print('Error: $e'); // Handle the exception first.
} finally {
  cleanLlamaStalls(); // Then clean up.
}

Learn more by reading the Exceptions section of the library tour.
Assert

During development, use an assert statement‚Äî assert(<condition>, <optionalMessage>); ‚Äîto disrupt normal execution if a boolean condition is false.

// Make sure the variable has a non-null value.
assert(text != null);

// Make sure the value is less than 100.
assert(number < 100);

// Make sure this is an https URL.
assert(urlString.startsWith('https'));

To attach a message to an assertion, add a string as the second argument to assert (optionally with a trailing comma):

assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');

The first argument to assert can be any expression that resolves to a boolean value. If the expression‚Äôs value is true, the assertion succeeds and execution continues. If it‚Äôs false, the assertion fails and an exception (an AssertionError) is thrown.

When exactly do assertions work? That depends on the tools and framework you‚Äôre using:

    Flutter enables assertions in debug mode.
    Development-only tools such as webdev serve typically enable assertions by default.
    Some tools, such as dart run and dart compile js support assertions through a command-line flag: --enable-asserts.

In production code, assertions are ignored, and the arguments to assert aren‚Äôt evaluated.

Classes

Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except Null descend from Object. Mixin-based inheritance means that although every class (except for the top class, Object?) has exactly one superclass, a class body can be reused in multiple class hierarchies. Extension methods are a way to add functionality to a class without changing the class or creating a subclass. Class modifiers allow you to control how libraries can subtype a class.
Using class members

Objects have members consisting of functions and data (methods and instance variables, respectively). When you call a method, you invoke it on an object: the method has access to that object‚Äôs functions and data.

Use a dot (.) to refer to an instance variable or method:

var p = Point(2, 2);

// Get the value of y.
assert(p.y == 2);

// Invoke distanceTo() on p.
double distance = p.distanceTo(Point(4, 4));

Use ?. instead of . to avoid an exception when the leftmost operand is null:

// If p is non-null, set a variable equal to its y value.
var a = p?.y;

Using constructors

You can create an object using a constructor. Constructor names can be either ClassName or ClassName.identifier. For example, the following code creates Point objects using the Point() and Point.fromJson() constructors:

var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});

The following code has the same effect, but uses the optional new keyword before the constructor name:

var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});

Some classes provide constant constructors. To create a compile-time constant using a constant constructor, put the const keyword before the constructor name:

var p = const ImmutablePoint(2, 2);

Constructing two identical compile-time constants results in a single, canonical instance:

var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance!

Within a constant context, you can omit the const before a constructor or literal. For example, look at this code, which creates a const map:

// Lots of const keywords here.
const pointAndLine = const {
  'point': const [const ImmutablePoint(0, 0)],
  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],
};

You can omit all but the first use of the const keyword:

// Only one const, which establishes the constant context.
const pointAndLine = {
  'point': [ImmutablePoint(0, 0)],
  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],
};

If a constant constructor is outside of a constant context and is invoked without const, it creates a non-constant object:

var a = const ImmutablePoint(1, 1); // Creates a constant
var b = ImmutablePoint(1, 1); // Does NOT create a constant

assert(!identical(a, b)); // NOT the same instance!

Getting an object‚Äôs type

To get an object‚Äôs type at runtime, you can use the Object property runtimeType, which returns a Type object.

print('The type of a is ${a.runtimeType}');

Use a type test operator rather than runtimeType to test an object‚Äôs type. In production environments, the test object is Type is more stable than the test object.runtimeType == Type.

Up to here, you‚Äôve seen how to use classes. The rest of this section shows how to implement classes.
Instance variables

Here‚Äôs how you declare instance variables:

class Point {
  double? x; // Declare instance variable x, initially null.
  double? y; // Declare y, initially null.
  double z = 0; // Declare z, initially 0.
}

All uninitialized instance variables have the value null.

All instance variables generate an implicit getter method. Non-final instance variables and late final instance variables without initializers also generate an implicit setter method. For details, check out Getters and setters.

If you initialize a non-late instance variable where it‚Äôs declared, the value is set when the instance is created, which is before the constructor and its initializer list execute. As a result, non-late instance variable initializers can‚Äôt access this.

class Point {
  double? x; // Declare instance variable x, initially null.
  double? y; // Declare y, initially null.
}

void main() {
  var point = Point();
  point.x = 4; // Use the setter method for x.
  assert(point.x == 4); // Use the getter method for x.
  assert(point.y == null); // Values default to null.
}

Instance variables can be final, in which case they must be set exactly once. Initialize final, non-late instance variables at declaration, using a constructor parameter, or using a constructor‚Äôs initializer list:

class ProfileMark {
  final String name;
  final DateTime start = DateTime.now();

  ProfileMark(this.name);
  ProfileMark.unnamed() : name = '';
}

If you need to assign the value of a final instance variable after the constructor body starts, you can use one of the following:

    Use a factory constructor.
    Use late final, but be careful: a late final without an initializer adds a setter to the API.

Implicit interfaces

Every class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B‚Äôs API without inheriting B‚Äôs implementation, class A should implement the B interface.

A class implements one or more interfaces by declaring them in an implements clause and then providing the APIs required by the interfaces. For example:

// A person. The implicit interface contains greet().
class Person {
  // In the interface, but visible only in this library.
  final String _name;

  // Not in the interface, since this is a constructor.
  Person(this._name);

  // In the interface.
  String greet(String who) => 'Hello, $who. I am $_name.';
}

// An implementation of the Person interface.
class Impostor implements Person {
  String get _name => '';

  String greet(String who) => 'Hi $who. Do you know who I am?';
}

String greetBob(Person person) => person.greet('Bob');

void main() {
  print(greetBob(Person('Kathy')));
  print(greetBob(Impostor()));
}

Here‚Äôs an example of specifying that a class implements multiple interfaces:

class Point implements Comparable, Location {...}

Class variables and methods

Use the static keyword to implement class-wide variables and methods.
Static variables

Static variables (class variables) are useful for class-wide state and constants:

class Queue {
  static const initialCapacity = 16;
  // ¬∑¬∑¬∑
}

void main() {
  assert(Queue.initialCapacity == 16);
}

Static variables aren‚Äôt initialized until they‚Äôre used.

Note: This page follows the style guide recommendation of preferring lowerCamelCase for constant names.
Static methods

Static methods (class methods) don‚Äôt operate on an instance, and thus don‚Äôt have access to this. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:

import 'dart:math';

class Point {
  double x, y;
  Point(this.x, this.y);

  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 < distance && distance < 2.9);
  print(distance);
}

Note: Consider using top-level functions, instead of static methods, for common or widely used utilities and functionality.

You can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.


Constructors

Declare a constructor by creating a function with the same name as its class (plus, optionally, an additional identifier as described in Named constructors). The most common form of constructor, the generative constructor, creates a new instance of a class:

class Point {
  double x = 0;
  double y = 0;

  Point(double x, double y) {
    // See initializing formal parameters for a better way
    // to initialize instance variables.
    this.x = x;
    this.y = y;
  }
}

The this keyword refers to the current instance.

Note: Use this only when there is a name conflict. Otherwise, Dart style omits the this.
Initializing formal parameters

The pattern of assigning a constructor argument to an instance variable is so common, Dart has initializing formal parameters to make it easy.

Initializing parameters can also be used to initialize non-nullable or final instance variables, which both must be initialized or provided a default value.

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);
}

The variables introduced by the initializing formals are implicitly final and only in scope of the initializer list.
Default constructors

If you don‚Äôt declare a constructor, a default constructor is provided for you. The default constructor has no arguments and invokes the no-argument constructor in the superclass.
Constructors aren‚Äôt inherited

Subclasses don‚Äôt inherit constructors from their superclass. A subclass that declares no constructors has only the default (no argument, no name) constructor.
Named constructors

Use a named constructor to implement multiple constructors for a class or to provide extra clarity:

const double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  Point(this.x, this.y);

  // Named constructor
  Point.origin()
      : x = xOrigin,
        y = yOrigin;
}

Remember that constructors are not inherited, which means that a superclass‚Äôs named constructor is not inherited by a subclass. If you want a subclass to be created with a named constructor defined in the superclass, you must implement that constructor in the subclass.
Invoking a non-default superclass constructor

By default, a constructor in a subclass calls the superclass‚Äôs unnamed, no-argument constructor. The superclass‚Äôs constructor is called at the beginning of the constructor body. If an initializer list is also being used, it executes before the superclass is called. In summary, the order of execution is as follows:

    initializer list
    superclass‚Äôs no-arg constructor
    main class‚Äôs no-arg constructor

If the superclass doesn‚Äôt have an unnamed, no-argument constructor, then you must manually call one of the constructors in the superclass. Specify the superclass constructor after a colon (:), just before the constructor body (if any).

In the following example, the constructor for the Employee class calls the named constructor for its superclass, Person. Click Run to execute the code.

Because the arguments to the superclass constructor are evaluated before invoking the constructor, an argument can be an expression such as a function call:

class Employee extends Person {
  Employee() : super.fromJson(fetchDefaultData());
  // ¬∑¬∑¬∑
}

Warning: Arguments to the superclass constructor don‚Äôt have access to this. For example, arguments can call static methods but not instance methods.
Super parameters

To avoid having to manually pass each parameter into the super invocation of a constructor, you can use super-initializer parameters to forward parameters to the specified or default superclass constructor. This feature can‚Äôt be used with redirecting constructors. Super-initializer parameters have similar syntax and semantics to initializing formal parameters:

class Vector2d {
  final double x;
  final double y;

  Vector2d(this.x, this.y);
}

class Vector3d extends Vector2d {
  final double z;

  // Forward the x and y parameters to the default super constructor like:
  // Vector3d(final double x, final double y, this.z) : super(x, y);
  Vector3d(super.x, super.y, this.z);
}

Super-initializer parameters cannot be positional if the super-constructor invocation already has positional arguments, but they can always be named:

class Vector2d {
  // ...

  Vector2d.named({required this.x, required this.y});
}

class Vector3d extends Vector2d {
  // ...

  // Forward the y parameter to the named super constructor like:
  // Vector3d.yzPlane({required double y, required this.z})
  //       : super.named(x: 0, y: y);
  Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0);
}

Version note: Using super-initializer parameters requires a language version of at least 2.17. If you‚Äôre using an earlier language version, you must manually pass in all super constructor parameters.
Initializer list

Besides invoking a superclass constructor, you can also initialize instance variables before the constructor body runs. Separate initializers with commas.

// Initializer list sets instance variables before
// the constructor body runs.
Point.fromJson(Map<String, double> json)
    : x = json['x']!,
      y = json['y']! {
  print('In Point.fromJson(): ($x, $y)');
}

Warning: The right-hand side of an initializer doesn‚Äôt have access to this.

During development, you can validate inputs by using assert in the initializer list.

Point.withAssert(this.x, this.y) : assert(x >= 0) {
  print('In Point.withAssert(): ($x, $y)');
}

Initializer lists are handy when setting up final fields. The following example initializes three final fields in an initializer list. Click Run to execute the code.
Redirecting constructors

Sometimes a constructor‚Äôs only purpose is to redirect to another constructor in the same class. A redirecting constructor‚Äôs body is empty, with the constructor call (using this instead of the class name) appearing after a colon (:).

class Point {
  double x, y;

  // The main constructor for this class.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  Point.alongXAxis(double x) : this(x, 0);
}

Constant constructors

If your class produces objects that never change, you can make these objects compile-time constants. To do this, define a const constructor and make sure that all instance variables are final.

class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}

Constant constructors don‚Äôt always create constants. For details, see the section on using constructors.
Factory constructors

Use the factory keyword when implementing a constructor that doesn‚Äôt always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype. Another use case for factory constructors is initializing a final variable using logic that can‚Äôt be handled in the initializer list.

Tip: Another way to handle late initialization of a final variable is to use late final (carefully!).

In the following example, the Logger factory constructor returns objects from a cache, and the Logger.fromJson factory constructor initializes a final variable from a JSON object.

class Logger {
  final String name;
  bool mute = false;

  // _cache is library-private, thanks to
  // the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  factory Logger.fromJson(Map<String, Object> json) {
    return Logger(json['name'].toString());
  }

  Logger._internal(this.name);

  void log(String msg) {
    if (!mute) print(msg);
  }
}

Note: Factory constructors have no access to this.

Invoke a factory constructor just like you would any other constructor:

var logger = Logger('UI');
logger.log('Button clicked');

var logMap = {'name': 'UI'};
var loggerJson = Logger.fromJson(logMap);

Methods

Methods are functions that provide behavior for an object.
Instance methods

Instance methods on objects can access instance variables and this. The distanceTo() method in the following sample is an example of an instance method:

import 'dart:math';

class Point {
  final double x;
  final double y;

  Point(this.x, this.y);

  double distanceTo(Point other) {
    var dx = x - other.x;
    var dy = y - other.y;
    return sqrt(dx * dx + dy * dy);
  }
}

Operators

Operators are instance methods with special names. Dart allows you to define operators with the following names:
< 	+ 	| 	>>>
> 	/ 	^ 	[]
<= 	~/ 	& 	[]=
>= 	* 	<< 	~
- 	% 	>> 	==

Note: You may have noticed that some operators, like !=, aren‚Äôt in the list of names. That‚Äôs because they‚Äôre just syntactic sugar. For example, the expression e1 != e2 is syntactic sugar for !(e1 == e2).

An operator declaration is identified using the built-in identifier operator. The following example defines vector addition (+), subtraction (-), and equality (==):

class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);

  @override
  bool operator ==(Object other) =>
      other is Vector && x == other.x && y == other.y;

  @override
  int get hashCode => Object.hash(x, y);
}

void main() {
  final v = Vector(2, 3);
  final w = Vector(2, 2);

  assert(v + w == Vector(4, 5));
  assert(v - w == Vector(0, 1));
}

Getters and setters

Getters and setters are special methods that provide read and write access to an object‚Äôs properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the get and set keywords:

class Rectangle {
  double left, top, width, height;

  Rectangle(this.left, this.top, this.width, this.height);

  // Define two calculated properties: right and bottom.
  double get right => left + width;
  set right(double value) => left = value - width;
  double get bottom => top + height;
  set bottom(double value) => top = value - height;
}

void main() {
  var rect = Rectangle(3, 4, 20, 15);
  assert(rect.left == 3);
  rect.right = 12;
  assert(rect.left == -8);
}

With getters and setters, you can start with instance variables, later wrapping them with methods, all without changing client code.

Note: Operators such as increment (++) work in the expected way, whether or not a getter is explicitly defined. To avoid any unexpected side effects, the operator calls the getter exactly once, saving its value in a temporary variable.
Abstract methods

Instance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in abstract classes or mixins.

To make a method abstract, use a semicolon (;) instead of a method body:

abstract class Doer {
  // Define instance variables and methods...

  void doSomething(); // Define an abstract method.
}

class EffectiveDoer extends Doer {
  void doSomething() {
    // Provide an implementation, so the method is not abstract here...
  }
}

Extend a class

Use extends to create a subclass, and super to refer to the superclass:

class Television {
  void turnOn() {
    _illuminateDisplay();
    _activateIrSensor();
  }
  // ¬∑¬∑¬∑
}

class SmartTelevision extends Television {
  void turnOn() {
    super.turnOn();
    _bootNetworkInterface();
    _initializeMemory();
    _upgradeApps();
  }
  // ¬∑¬∑¬∑
}

For another usage of extends, see the discussion of parameterized types on the Generics page.
Overriding members

Subclasses can override instance methods (including operators), getters, and setters. You can use the @override annotation to indicate that you are intentionally overriding a member:

class Television {
  // ¬∑¬∑¬∑
  set contrast(int value) {...}
}

class SmartTelevision extends Television {
  @override
  set contrast(num value) {...}
  // ¬∑¬∑¬∑
}

An overriding method declaration must match the method (or methods) that it overrides in several ways:

    The return type must be the same type as (or a subtype of) the overridden method‚Äôs return type.
    Argument types must be the same type as (or a supertype of) the overridden method‚Äôs argument types. In the preceding example, the contrast setter of SmartTelevision changes the argument type from int to a supertype, num.
    If the overridden method accepts n positional parameters, then the overriding method must also accept n positional parameters.
    A generic method can‚Äôt override a non-generic one, and a non-generic method can‚Äôt override a generic one.

Sometimes you might want to narrow the type of a method parameter or an instance variable. This violates the normal rules, and it‚Äôs similar to a downcast in that it can cause a type error at runtime. Still, narrowing the type is possible if the code can guarantee that a type error won‚Äôt occur. In this case, you can use the covariant keyword in a parameter declaration. For details, see the Dart language specification.

Warning: If you override ==, you should also override Object‚Äôs hashCode getter. For an example of overriding == and hashCode, see Implementing map keys.
noSuchMethod()

To detect or react whenever code attempts to use a non-existent method or instance variable, you can override noSuchMethod():

class A {
  // Unless you override noSuchMethod, using a
  // non-existent member results in a NoSuchMethodError.
  @override
  void noSuchMethod(Invocation invocation) {
    print('You tried to use a non-existent member: '
        '${invocation.memberName}');
  }
}

You can‚Äôt invoke an unimplemented method unless one of the following is true:

    The receiver has the static type dynamic.

    The receiver has a static type that defines the unimplemented method (abstract is OK), and the dynamic type of the receiver has an implementation of noSuchMethod() that‚Äôs different from the one in class Object.

For more information, see the informal noSuchMethod forwarding specification.

Mixins

Mixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.

To use a mixin, use the with keyword followed by one or more mixin names. The following example shows two classes that use mixins:

class Musician extends Performer with Musical {
  // ¬∑¬∑¬∑
}

class Maestro extends Person with Musical, Aggressive, Demented {
  Maestro(String maestroName) {
    name = maestroName;
    canConduct = true;
  }
}

To define a mixin, use the mixin declaration. In the rare case where you need to define both a mixin and a class, you can use the mixin class declaration.

Mixins and mixin classes cannot have an extends clause, and must not declare any generative constructors.

For example:

mixin Musical {
  bool canPlayPiano = false;
  bool canCompose = false;
  bool canConduct = false;

  void entertainMe() {
    if (canPlayPiano) {
      print('Playing piano');
    } else if (canConduct) {
      print('Waving hands');
    } else {
      print('Humming to self');
    }
  }
}

Sometimes you might want to restrict the types that can use a mixin. For example, the mixin might depend on being able to invoke a method that the mixin doesn‚Äôt define. As the following example shows, you can restrict a mixin‚Äôs use by using the on keyword to specify the required superclass:

class Musician {
  // ...
}
mixin MusicalPerformer on Musician {
  // ...
}
class SingerDancer extends Musician with MusicalPerformer {
  // ...
}

In the preceding code, only classes that extend or implement the Musician class can use the mixin MusicalPerformer. Because SingerDancer extends Musician, SingerDancer can mix in MusicalPerformer.
class, mixin, or mixin class?

Version note: The mixin class declaration requires a language version of at least 3.0.

A mixin declaration defines a mixin. A class declaration defines a class. A mixin class declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.

Any restrictions that apply to classes or mixins also apply to mixin classes:

    Mixins can‚Äôt have extends or with clauses, so neither can a mixin class.
    Classes can‚Äôt have an on clause, so neither can a mixin class.

abstract mixin class

You can achieve similar behavior to the on directive for a mixin class. Make the mixin class abstract and define the abstract methods its behavior depends on:

abstract mixin class Musician {
  // No 'on' clause, but an abstract method that other types must define if 
  // they want to use (mix in or extend) Musician: 
  void playInstrument(String instrumentName);

  void playPiano() {
    playInstrument('Piano');
  }
  void playFlute() {
    playInstrument('Flute');
  }
}

class Virtuoso with Musician { // Use Musician as a mixin
  void playInstrument(String instrumentName) {
    print('Plays the $instrumentName beautifully');
  }  
} 

class Novice extends Musician { // Use Musician as a class
  void playInstrument(String instrumentName) {
    print('Plays the $instrumentName poorly');
  }  
} 

By declaring the Musician mixin as abstract, you force any type that uses it to define the abstract method upon which its behavior depends.

This is similar to how the on directive ensures a mixin has access to any interfaces it depends on by specifying the superclass of that interface.


Enumerated types

Enumerated types, often called enumerations or enums, are a special kind of class used to represent a fixed number of constant values.

Note: All enums automatically extend the Enum class. They are also sealed, meaning they cannot be subclassed, implemented, mixed in, or otherwise explicitly instantiated.

Abstract classes and mixins can explicitly implement or extend Enum, but unless they are then implemented by or mixed into an enum declaration, no objects can actually implement the type of that class or mixin.
Declaring simple enums

To declare a simple enumerated type, use the enum keyword and list the values you want to be enumerated:

enum Color { red, green, blue }

Tip: You can also use trailing commas when declaring an enumerated type to help prevent copy-paste errors.
Declaring enhanced enums

Dart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.

To declare an enhanced enum, follow a syntax similar to normal classes, but with a few extra requirements:

    Instance variables must be final, including those added by mixins.
    All generative constructors must be constant.
    Factory constructors can only return one of the fixed, known enum instances.
    No other class can be extended as Enum is automatically extended.
    There cannot be overrides for index, hashCode, the equality operator ==.
    A member named values cannot be declared in an enum, as it would conflict with the automatically generated static values getter.
    All instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.

Instance methods in an enhanced enum can use this to reference the current enum value.

Here is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:

enum Vehicle implements Comparable<Vehicle> {
  car(tires: 4, passengers: 5, carbonPerKilometer: 400),
  bus(tires: 6, passengers: 50, carbonPerKilometer: 800),
  bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0);

  const Vehicle({
    required this.tires,
    required this.passengers,
    required this.carbonPerKilometer,
  });

  final int tires;
  final int passengers;
  final int carbonPerKilometer;

  int get carbonFootprint => (carbonPerKilometer / passengers).round();

  bool get isTwoWheeled => this == Vehicle.bicycle;

  @override
  int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint;
}

Version note: Enhanced enums require a language version of at least 2.17.
Using enums

Access the enumerated values like any other static variable:

final favoriteColor = Color.blue;
if (favoriteColor == Color.blue) {
  print('Your favorite color is blue!');
}

Each value in an enum has an index getter, which returns the zero-based position of the value in the enum declaration. For example, the first value has index 0, and the second value has index 1.

assert(Color.red.index == 0);
assert(Color.green.index == 1);
assert(Color.blue.index == 2);

To get a list of all the enumerated values, use the enum‚Äôs values constant.

List<Color> colors = Color.values;
assert(colors[2] == Color.blue);

You can use enums in switch statements, and you‚Äôll get a warning if you don‚Äôt handle all of the enum‚Äôs values:

var aColor = Color.blue;

switch (aColor) {
  case Color.red:
    print('Red as roses!');
  case Color.green:
    print('Green as grass!');
  default: // Without this, you see a WARNING.
    print(aColor); // 'Color.blue'
}

If you need to access the name of an enumerated value, such as 'blue' from Color.blue, use the .name property:

print(Color.blue.name); // 'blue'

You can access a member of an enum value like you would on a normal object:

print(Vehicle.car.carbonFootprint);

Extension methods

Extension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.

If you like to learn by watching videos, here‚Äôs a good overview of extension methods.
Overview

When you‚Äôre using someone else‚Äôs API or when you implement a library that‚Äôs widely used, it‚Äôs often impractical or impossible to change the API. But you might still want to add some functionality.

For example, consider the following code that parses a string into an integer:

int.parse('42')

It might be nice‚Äîshorter and easier to use with tools‚Äîto have that functionality be on String instead:

'42'.parseInt()

To enable that code, you can import a library that contains an extension of the String class:

import 'string_apis.dart';
// ¬∑¬∑¬∑
print('42'.parseInt()); // Use an extension method.

Extensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here‚Äôs how you might implement the extension method parseInt(), using an extension (named NumberParsing) that operates on strings:

extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }
  // ¬∑¬∑¬∑
}

lib/string_apis.dart

The next section describes how to use extension methods. After that are sections about implementing extension methods.
Using extension methods

Like all Dart code, extension methods are in libraries. You‚Äôve already seen how to use an extension method‚Äîjust import the library it‚Äôs in, and use it like an ordinary method:

// Import a library that contains an extension on String.
import 'string_apis.dart';
// ¬∑¬∑¬∑
print('42'.padLeft(5)); // Use a String method.
print('42'.parseInt()); // Use an extension method.

That‚Äôs all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to dynamic) and how to resolve API conflicts.
Static types and dynamic

You can‚Äôt invoke extension methods on variables of type dynamic. For example, the following code results in a runtime exception:

dynamic d = '2';
print(d.parseInt()); // Runtime exception: NoSuchMethodError

Extension methods do work with Dart‚Äôs type inference. The following code is fine because the variable v is inferred to have type String:

var v = '2';
print(v.parseInt()); // Output: 2

The reason that dynamic doesn‚Äôt work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they‚Äôre as fast as calling a static function.

For more information about static types and dynamic, see The Dart type system.
API conflicts

If an extension member conflicts with an interface or with another extension member, then you have a few options.

One option is changing how you import the conflicting extension, using show or hide to limit the exposed API:

// Defines the String extension method parseInt().
import 'string_apis.dart';

// Also defines parseInt(), but hiding NumberParsing2
// hides that extension method.
import 'string_apis_2.dart' hide NumberParsing2;

// ¬∑¬∑¬∑
// Uses the parseInt() defined in 'string_apis.dart'.
print('42'.parseInt());

Another option is applying the extension explicitly, which results in code that looks as if the extension is a wrapper class:

// Both libraries define extensions on String that contain parseInt(),
// and the extensions have different names.
import 'string_apis.dart'; // Contains NumberParsing extension.
import 'string_apis_2.dart'; // Contains NumberParsing2 extension.

// ¬∑¬∑¬∑
// print('42'.parseInt()); // Doesn't work.
print(NumberParsing('42').parseInt());
print(NumberParsing2('42').parseInt());

If both extensions have the same name, then you might need to import using a prefix:

// Both libraries define extensions named NumberParsing
// that contain the extension method parseInt(). One NumberParsing
// extension (in 'string_apis_3.dart') also defines parseNum().
import 'string_apis.dart';
import 'string_apis_3.dart' as rad;

// ¬∑¬∑¬∑
// print('42'.parseInt()); // Doesn't work.

// Use the ParseNumbers extension from string_apis.dart.
print(NumberParsing('42').parseInt());

// Use the ParseNumbers extension from string_apis_3.dart.
print(rad.NumberParsing('42').parseInt());

// Only string_apis_3.dart has parseNum().
print('42'.parseNum());

As the example shows, you can invoke extension methods implicitly even if you import using a prefix. The only time you need to use the prefix is to avoid a name conflict when invoking an extension explicitly.
Implementing extension methods

Use the following syntax to create an extension:

extension <extension name>? on <type> {
  (<member definition>)*
}

For example, here‚Äôs how you might implement an extension on the String class:

extension NumberParsing on String {
  int parseInt() {
    return int.parse(this);
  }

  double parseDouble() {
    return double.parse(this);
  }
}

lib/string_apis.dart

The members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods.
Unnamed extensions

When declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they‚Äôre declared. Since they don‚Äôt have a name, they can‚Äôt be explicitly applied to resolve API conflicts.

extension on String {
  bool get isBlank => trim().isEmpty;
}

Note: You can invoke an unnamed extension‚Äôs static members only within the extension declaration.
Implementing generic extensions

Extensions can have generic type parameters. For example, here‚Äôs some code that extends the built-in List<T> type with a getter, an operator, and a method:

extension MyFancyList<T> on List<T> {
  int get doubleLength => length * 2;
  List<T> operator -() => reversed.toList();
  List<List<T>> split(int at) => [sublist(0, at), sublist(at)];
}

The type T is bound based on the static type of the list that the methods are called on.


Callable objects

To allow an instance of your Dart class to be called like a function, implement the call() method.

The call() method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal functions such as parameters and return types.

In the following example, the WannabeFunction class defines a call() function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click Run to execute the code.


Class modifiers

Version note: Class modifiers, besides abstract, require a language version of at least 3.0.

Class modifiers control how a class or mixin can be used, both from within its own library, and from outside of the library where it‚Äôs defined.

Modifier keywords come before a class or mixin declaration. For example, writing abstract class defines an abstract class. The full set of modifiers that can appear before a class declaration include:

    abstract
    base
    final
    interface
    sealed
    mixin

Only the base modifier can appear before a mixin declaration. The modifiers do not apply to other declarations like enum, typedef, or extension.

When deciding whether to use class modifiers, consider the intended uses of the class, and what behaviors the class needs to be able to rely on.

Note: If you maintain a library, read the Class modifiers for API maintainers page for guidance on how to navigate these changes for your libraries.
No modifier

To allow unrestricted permission to construct or subtype from any library, use a class or mixin declaration without a modifier. By default, you can:

    Construct new instances of a class.
    Extend a class to create a new subtype.
    Implement a class or mixin‚Äôs interface.
    Mix in a mixin or mixin class.

abstract

To define a class that doesn‚Äôt require a full, concrete implementation of its entire interface, use the abstract modifier.

Abstract classes cannot be constructed from any library, whether its own or an outside library. Abstract classes often have abstract methods.

// Library a.dart
abstract class Vehicle {
  void moveForward(int meters);
}

// Library b.dart
import 'a.dart';

// Error: Cannot be constructed
Vehicle myVehicle = Vehicle();

// Can be extended
class Car extends Vehicle {
  int passengers = 4;
  // ¬∑¬∑¬∑
}

// Can be implemented
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}

If you want your abstract class to appear to be instantiable, define a factory constructor.
base

To enforce inheritance of a class or mixin‚Äôs implementation, use the base modifier. A base class disallows implementation outside of its own library. This guarantees:

    The base class constructor is called whenever an instance of a subtype of the class is created.
    All implemented private members exist in subtypes.
    A new implemented member in a base class does not break subtypes, since all subtypes inherit the new member.
        This is true unless the subtype already declares a member with the same name and an incompatible signature.

You must mark any class which implements or extends a base class as base, final, or sealed. This prevents outside libraries from breaking the base class guarantees.

// Library a.dart
base class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

// Library b.dart
import 'a.dart';

// Can be constructed
Vehicle myVehicle = Vehicle();

// Can be extended
base class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// ERROR: Cannot be implemented
base class MockVehicle implements Vehicle {
  @override
  void moveForward() {
    // ...
  }
}

interface

To define an interface, use the interface modifier. Libraries outside of the interface‚Äôs own defining library can implement the interface, but not extend it. This guarantees:

    When one of the class‚Äôs instance methods calls another instance method on this, it will always invoke a known implementation of the method from the same library.
    Other libraries can‚Äôt override methods that the interface class‚Äôs own methods might later call in unexpected ways. This reduces the fragile base class problem.

// Library a.dart
interface class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

// Library b.dart
import 'a.dart';

// Can be constructed
Vehicle myVehicle = Vehicle();

// ERROR: Cannot be inherited
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// Can be implemented
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}

abstract interface

The most common use for the interface modifier is to define a pure interface. Combine the interface and abstract modifiers for an abstract interface class.

Like an interface class, other libraries can implement, but cannot inherit, a pure interface. Like an abstract class, a pure interface can have abstract members.
final

To close the type hierarchy, use the final modifier. This prevents subtyping from a class outside of the current library. Disallowing both inheritance and implementation prevents subtyping entirely. This guarantees:

    You can safely add incremental changes to the API.
    You can call instance methods knowing that they haven‚Äôt been overwritten in a third-party subclass.

Final classes can be extended or implemented within the same library. The final modifier encompasses the effects of base, and therefore any subclasses must also be marked base, final, or sealed.

// Library a.dart
final class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

// Library b.dart
import 'a.dart';

// Can be constructed
Vehicle myVehicle = Vehicle();

// ERROR: Cannot be inherited
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

class MockVehicle implements Vehicle {
  // ERROR: Cannot be implemented
  @override
  void moveForward(int meters) {
    // ...
  }
}

sealed

To create a known, enumerable set of subtypes, use the sealed modifier. This allows you to create a switch over those subtypes that is statically ensured to be exhaustive.

The sealed modifier prevents a class from being extended or implemented outside its own library. Sealed classes are implicitly abstract.

    They cannot be constructed themselves.
    They can have factory constructors.
    They can define constructors for their subclasses to use.

Subclasses of sealed classes are, however, not implicitly abstract.

The compiler is aware of any possible direct subtypes because they can only exist in the same library. This allows the compiler to alert you when a switch does not exhaustively handle all possible subtypes in its cases:

sealed class Vehicle {}

class Car extends Vehicle {}

class Truck implements Vehicle {}

class Bicycle extends Vehicle {}

// ERROR: Cannot be instantiated
Vehicle myVehicle = Vehicle();

// Subclasses can be instantiated
Vehicle myCar = Car();

String getVehicleSound(Vehicle vehicle) {
  // ERROR: The switch is missing the Bicycle subtype or a default case.
  return switch (vehicle) {
    Car() => 'vroom',
    Truck() => 'VROOOOMM',
  };
}

If you don‚Äôt want exhaustive switching, or want to be able to add subtypes later without breaking the API, use the final modifier. For a more in depth comparison, read sealed versus final.
Combining modifiers

You can combine some modifiers for layered restrictions. A class declaration can be, in order:

    (Optional) abstract, describing whether the class can contain abstract members and prevents instantiation.
    (Optional) One of base, interface, final or sealed, describing restrictions on other libraries subtyping the class.
    (Optional) mixin, describing whether the declaration can be mixed in.
    The class keyword itself.

You can‚Äôt combine some modifiers because they are contradictory, redundant, or otherwise mutually exclusive:

    abstract with sealed. A sealed class is always implicitly abstract.
    interface, final or sealed with mixin. These access modifiers prevent mixing in.

See the Class modifiers reference for complete guidance.

Class modifiers for API maintainers

Dart 3.0 adds a few new modifiers that you can place on class and mixin declarations. If you are the author of a library package, these modifiers give you more control over what users are allowed to do with the types that your package exports. This can make it easier to evolve your package, and easier to know if a change to your code may break users.

Dart 3.0 also includes a breaking change around using classes as mixins. This change might not break your class, but it could break users of your class.

This guide walks you through these changes so you know how to use the new modifiers, and how they affect users of your libraries.
The mixin modifier on classes

The most important modifier to be aware of is mixin. Language versions prior to Dart 3.0 allow any class to be used as a mixin in another class‚Äôs with clause, UNLESS the class:

    Declares any non-factory constructors.
    Extends any class other than Object.

This makes it easy to accidentally break someone else‚Äôs code, by adding a constructor or extends clause to a class without realizing that others are using it in a with clause.

Dart 3.0 no longer allows classes to be used as mixins by default. Instead, you must explicitly opt-in to that behavior by declaring a mixin class:

mixin class Both {}

class UseAsMixin with Both {}
class UseAsSuperclass extends Both {}

If you update your package to Dart 3.0 and don‚Äôt change any of your code, you may not see any errors. But you may inadvertently break users of your package if they were using your classes as mixins.
Migrating classes as mixins

If the class has a non-factory constructor, an extends clause, or a with clause, then it already can‚Äôt be used as a mixin. Behavior won‚Äôt change with Dart 3.0; there‚Äôs nothing to worry about and nothing you need to do.

In practice, this describes about 90% of existing classes. For the remaining classes that can be used as mixins, you have to decide what you want to support.

Here are a few questions to help decide. The first is pragmatic:

    Do you want to risk breaking any users? If the answer is a hard ‚Äúno‚Äù, then place mixin before any and all classes that could be used as a mixin. This exactly preserves the existing behavior of your API.

On the other hand, if you want to take this opportunity to rethink the affordances your API offers, then you may want to not turn it into a mixin class. Consider these two design questions:

    Do you want users to be able to construct instances of it directly? In other words, is the class deliberately not abstract?

    Do you want people to be able to use the declaration as a mixin? In other words, do you want them to be able to use it in with clauses?

If the answer to both is ‚Äúyes‚Äù, then make it a mixin class. If the answer to the second is ‚Äúno‚Äù, then just leave it as a class. If the answer to the first is ‚Äúno‚Äù and the second is ‚Äúyes‚Äù, then change it from a class to a mixin declaration.

The last two options, leaving it a class or turning it into a pure mixin, are breaking API changes. You‚Äôll want to bump the major version of your package if you do this.
Other opt-in modifiers

Handling classes as mixins is the only critical change in Dart 3.0 that affects the API of your package. Once you‚Äôve gotten this far, you can stop if you don‚Äôt want to make other changes to what your package allows users to do.

Note that if you do continue and use any of the modifiers described below, it is potentially a breaking change to your package‚Äôs API which necessitates a major version increment.
The interface modifier

Dart doesn‚Äôt have a separate syntax for declaring pure interfaces. Instead, you declare an abstract class that happens to contain only abstract methods. When a user sees that class in your package‚Äôs API, they may not know if it contains code they can reuse by extending the class, or whether it is instead meant to be used as an interface.

You can clarify that by putting the interface modifier on the class. That allows the class to be used in an implements clause, but prevents it from being used in extends.

Even when the class does have non-abstract methods, you may want to prevent users from extending it. Inheritance is one of the most powerful kinds of coupling in software, because it enables code reuse. But that coupling is also dangerous and fragile. When inheritance crosses package boundaries, it can be hard to evolve the superclass without breaking subclasses.

Marking the class interface lets users construct it (unless it‚Äôs also marked abstract) and implement the class‚Äôs interface, but prevents them from reusing any of its code.

When a class is marked interface, the restriction can be ignored within the library where the class is declared. Inside the library, you‚Äôre free to extend it since it‚Äôs all your code and presumably you know what you‚Äôre doing. The restriction applies to other packages, and even other libraries within your own package.
The base modifier

The base modifier is somewhat the opposite of interface. It allows you to use the class in an extends clause, or use a mixin or mixin class in a with clause. But, it disallows code outside of the class‚Äôs library from using the class or mixin in an implements clause.

This ensures that every object that is an instance of your class or mixin‚Äôs interface inherits your actual implementation. In particular, this means that every instance will include all of the private members your class or mixin declares. This can help prevent runtime errors that might otherwise occur.

Consider this library:

// a.dart
class A {
  void _privateMethod() {
    print('I inherited from A');
  }
}

void callPrivateMethod(A a) {
  a._privateMethod();
}

This code seems fine on its own, but there‚Äôs nothing preventing a user from creating another library like this:

// b.dart
import 'a.dart';

class B implements A {
  // No implementation of _privateMethod()!
}

main() {
  callPrivateMethod(B()); // Runtime exception!
}

Adding the base modifier to the class can help prevent these runtime errors. As with interface, you can ignore this restriction in the same library where the base class or mixin is declared. Then subclasses in the same library will be reminded to implement the private methods. But note that the next section does apply:
Base transitivity

The goal of marking a class base is to ensure that every instance of that type concretely inherits from it. To maintain this, the base restriction is ‚Äúcontagious‚Äù. Every subtype of a type marked base ‚Äì direct or indirect ‚Äì must also prevent being implemented. That means it must be marked base (or final or sealed, which we‚Äôll get to next).

Applying base to a type requires some care, then. It affects not just what users can do with your class or mixin, but also the affordances their subclasses can offer. Once you‚Äôve put base on a type, the whole hierarchy under it is prohibited from being implemented.

That sounds intense, but it‚Äôs how most other programming languages have always worked. Most don‚Äôt have implicit interfaces at all, so when you declare a class in Java, C#, or other languages, you effectively have the same constraint.
The final modifier

If you want all of the restrictions of both interface and base, you can mark a class or mixin class final. This prevents anyone outside of your library from creating any kind of subtype of it: no using it in implements, extends, with, or on clauses.

This is the most restrictive for users of the class. All they can do is construct it (unless it‚Äôs marked abstract). In return, you have the fewest restrictions as the class maintainer. You can add new methods, turn constructors into factory constructors, etc. without worrying about breaking any downstream users.
The sealed modifer

The last modifier, sealed, is special. It exists primarily to enable exhaustiveness checking in pattern matching. If a switch has cases for every direct subtype of a type marked sealed, then the compiler knows the switch is exhaustive.

// amigos.dart
sealed class Amigo {}
class Lucky extends Amigo {}
class Dusty extends Amigo {}
class Ned extends Amigo {}

String lastName(Amigo amigo) =>
    switch (amigo) {
      case Lucky _ => 'Day';
      case Dusty _ => 'Bottoms';
      case Ned _   => 'Nederlander';
    }

This switch has a case for each of the subtypes of Amigo. The compiler knows that every instance of Amigo must be an instance of one of those subtypes, so it knows the switch is safely exhaustive and doesn‚Äôt require any final default case.

For this to be sound, the compiler enforces two restrictions:

    The sealed class can‚Äôt itself be directly constructible. Otherwise, you could have an instance of Amigo that isn‚Äôt an instance of any of the subtypes. So every sealed class is implicitly abstract too.

    Every direct subtype of the sealed type must be in the same library where the sealed type is declared. This way, the compiler can find them all. It knows that there aren‚Äôt other hidden subtypes floating around that would not match any of the cases.

The second restriction is similar to final. Like final, it means that a class marked sealed can‚Äôt be directly extended, implemented, or mixed in outside of the library where it‚Äôs declared. But, unlike base and final, there is no transitive restriction:

// amigo.dart
sealed class Amigo {}
class Lucky extends Amigo {}
class Dusty extends Amigo {}
class Ned extends Amigo {}

// other.dart

// This is an error:
class Bad extends Amigo {}

// But these are both fine:
class OtherLucky extends Lucky {}
class OtherDusty implements Dusty {}

Of course, if you want the subtypes of your sealed type to be restricted as well, you can get that by marking them using interface, base, final, or sealed.
sealed versus final

If you have a class that you don‚Äôt want users to be able to directly subtype, when should you use sealed versus final? A couple of simple rules:

    If you want users to be able to directly construct instances of the class, then it can‚Äôt use sealed since sealed types are implicitly abstract.

    If the class has no subtypes in your library, then there‚Äôs no point in using sealed since you get no exhaustiveness checking benefits.

Otherwise, if the class does have some subtypes that you define, then sealed is likely what you want. If users see that the class has a few subtypes, it‚Äôs handy to be able to handle each of them separately as switch cases and have the compiler know that the entire type is covered.

Using sealed does mean that if you later add another subtype to the library, it‚Äôs a breaking API change. When a new subtype appears, all of those existing switches become non-exhaustive since they don‚Äôt handle the new type. It‚Äôs exactly like adding a new value to an enum.

Those non-exhaustive switch compile errors are useful to users because they draw the user‚Äôs attention to places in their code where they‚Äôll need to handle the new type.

But it does mean that whenever you add a new subtype, it‚Äôs a breaking change. If you want the freedom to add new subtypes in a non-breaking way, then it‚Äôs better to mark the supertype using final instead of sealed. That means that when a user switches on a value of that supertype, even if they have cases for all of the subtypes, the compiler will force them to add another default case. That default case will then be what is executed if you add more subtypes later.
Summary

As an API designer, these new modifiers give you control over how users work with your code, and conversely how you are able to evolve your code without breaking theirs.

But these options carry complexity with them: you now have more choices to make as an API designer. Also, since these features are new, we still don‚Äôt know what the best practices will be. Every language‚Äôs ecosystem is different and has different needs.

Fortunately, you don‚Äôt need to figure it out all at once. We chose the defaults deliberately so that even if you do nothing, your classes mostly have the same affordances they had before 3.0. If you just want to keep your API the way it was, put mixin on the classes that already supported that, and you‚Äôre done.

Over time, as you get a sense of where you want finer control, you can consider applying some of the other modifiers:

    Use interface to prevent users from reusing your class‚Äôs code while allowing them to re-implement its interface.

    Use base to require users to reuse your class‚Äôs code and ensure every instance of your class‚Äôs type is an instance of that actual class or a subclass.

    Use final to completely prevent a class from being extended.

    Use sealed to opt in to exhaustiveness checking on a family of subtypes.

When you do, increment the major version when publishing your package, since these modifiers all imply restrictions that are breaking changes.


Class modifiers reference

This page contains reference information for class modifiers.
Valid combinations

The valid combinations of class modifiers and their resulting capabilities are:
Declaration 	Construct? 	Extend? 	Implement? 	Mix in? 	Exhaustive? 	 
class 	Yes 	Yes 	Yes 	No 	No 	 
base class 	Yes 	Yes 	No 	No 	No 	 
interface class 	Yes 	No 	Yes 	No 	No 	 
final class 	Yes 	No 	No 	No 	No 	 
sealed class 	No 	No 	No 	No 	Yes 	 
abstract class 	No 	Yes 	Yes 	No 	No 	 
abstract base class 	No 	Yes 	No 	No 	No 	 
abstract interface class 	No 	No 	Yes 	No 	No 	 
abstract final class 	No 	No 	No 	No 	No 	 
mixin class 	Yes 	Yes 	Yes 	Yes 	No 	 
base mixin class 	Yes 	Yes 	No 	Yes 	No 	 
abstract mixin class 	No 	Yes 	Yes 	Yes 	No 	 
abstract base mixin class 	No 	Yes 	No 	Yes 	No 	 
mixin 	No 	No 	Yes 	Yes 	No 	 
base mixin 	No 	No 	No 	Yes 	No 	 
Invalid combinations

Certain combinations of modifiers are not allowed:
Combination 	Reasoning
base, interface, and final 	All control the same two capabilities (extend and implement), so are mutually exclusive.
sealed and abstract 	Neither can be constructed, so are redundant together.
sealed with base, interface, or final 	sealed types already cannot be mixed in, extended or implemented from another library, so are redundant to combine with the listed modifiers.
mixin and abstract 	Neither can be constructed, so are redundant together.
mixin and interface, final, or sealed 	A mixin or mixin class declaration is intended to be mixed in, which the listed modifiers prevent.
enum and any modifiers 	enum declarations cannot be extended, implemented, mixed in, and can always be instantiated, so no modifiers apply to enum declarations.

Asynchrony support

Dart libraries are full of functions that return Future or Stream objects. These functions are asynchronous: they return after setting up a possibly time-consuming operation (such as I/O), without waiting for that operation to complete.

The async and await keywords support asynchronous programming, letting you write asynchronous code that looks similar to synchronous code.
Handling Futures

When you need the result of a completed Future, you have two options:

    Use async and await, as described here and in the asynchronous programming codelab.
    Use the Future API, as described in the library tour.

Code that uses async and await is asynchronous, but it looks a lot like synchronous code. For example, here‚Äôs some code that uses await to wait for the result of an asynchronous function:

await lookUpVersion();

To use await, code must be in an async function‚Äîa function marked as async:

Future<void> checkVersion() async {
  var version = await lookUpVersion();
  // Do something with version
}

Note: Although an async function might perform time-consuming operations, it doesn‚Äôt wait for those operations. Instead, the async function executes only until it encounters its first await expression. Then it returns a Future object, resuming execution only after the await expression completes.

Use try, catch, and finally to handle errors and cleanup in code that uses await:

try {
  version = await lookUpVersion();
} catch (e) {
  // React to inability to look up the version
}

You can use await multiple times in an async function. For example, the following code waits three times for the results of functions:

var entrypoint = await findEntryPoint();
var exitCode = await runExecutable(entrypoint, args);
await flushThenExit(exitCode);

In await expression, the value of expression is usually a Future; if it isn‚Äôt, then the value is automatically wrapped in a Future. This Future object indicates a promise to return an object. The value of await expression is that returned object. The await expression makes execution pause until that object is available.

If you get a compile-time error when using await, make sure await is in an async function. For example, to use await in your app‚Äôs main() function, the body of main() must be marked as async:

void main() async {
  checkVersion();
  print('In main: version is ${await lookUpVersion()}');
}

Note: The preceding example uses an async function (checkVersion()) without waiting for a result‚Äîa practice that can cause problems if the code assumes that the function has finished executing. To avoid this problem, use the unawaited_futures linter rule.

For an interactive introduction to using futures, async, and await, see the asynchronous programming codelab.
Declaring async functions

An async function is a function whose body is marked with the async modifier.

Adding the async keyword to a function makes it return a Future. For example, consider this synchronous function, which returns a String:

String lookUpVersion() => '1.0.0';

If you change it to be an async function‚Äîfor example, because a future implementation will be time consuming‚Äîthe returned value is a Future:

Future<String> lookUpVersion() async => '1.0.0';

Note that the function‚Äôs body doesn‚Äôt need to use the Future API. Dart creates the Future object if necessary. If your function doesn‚Äôt return a useful value, make its return type Future<void>.

For an interactive introduction to using futures, async, and await, see the asynchronous programming codelab.
Handling Streams

When you need to get values from a Stream, you have two options:

    Use async and an asynchronous for loop (await for).
    Use the Stream API, as described in the library tour.

Note: Before using await for, be sure that it makes the code clearer and that you really do want to wait for all of the stream‚Äôs results. For example, you usually should not use await for for UI event listeners, because UI frameworks send endless streams of events.

An asynchronous for loop has the following form:

await for (varOrType identifier in expression) {
  // Executes each time the stream emits a value.
}

The value of expression must have type Stream. Execution proceeds as follows:

    Wait until the stream emits a value.
    Execute the body of the for loop, with the variable set to that emitted value.
    Repeat 1 and 2 until the stream is closed.

To stop listening to the stream, you can use a break or return statement, which breaks out of the for loop and unsubscribes from the stream.

If you get a compile-time error when implementing an asynchronous for loop, make sure the await for is in an async function. For example, to use an asynchronous for loop in your app‚Äôs main() function, the body of main() must be marked as async:

void main() async {
  // ...
  await for (final request in requestServer) {
    handleRequest(request);
  }
  // ...
}

For more information about asynchronous programming, in general, see the dart:async section of the library tour.

Concurrency in Dart

Dart supports concurrent programming with async-await, isolates, and classes such as Future and Stream. This page gives an overview of async-await, Future, and Stream, but it‚Äôs mostly about isolates.

Within an app, all Dart code runs in an isolate. Each Dart isolate has a single thread of execution and shares no mutable objects with other isolates. To communicate with each other, isolates use message passing. Many Dart apps use only one isolate, the main isolate. You can create additional isolates to enable parallel code execution on multiple processor cores.

Although Dart‚Äôs isolate model is built with underlying primitives such as processes and threads that the operating system provides, the Dart VM‚Äôs use of these primitives is an implementation detail that this page doesn‚Äôt discuss.
Asynchrony types and syntax

If you‚Äôre already familiar with Future, Stream, and async-await, then you can skip ahead to the isolates section.
Future and Stream types

The Dart language and libraries use Future and Stream objects to represent values to be provided in the future. For example, a promise to eventually provide an int value is typed as Future<int>. A promise to provide a series of int values has the type Stream<int>.

As another example, consider the dart:io methods for reading files. The synchronous File method readAsStringSync() reads a file synchronously, blocking until the file is either fully read or an error occurs. The method then either returns an object of type String or throws an exception. The asynchronous equivalent, readAsString(), immediately returns an object of type Future<String>. At some point in the future, the Future<String> completes with either a string value or an error.
Why asynchronous code matters

It matters whether a method is synchronous or asynchronous because most apps need to do more than one thing at a time.

Asynchronous computations are often the result of performing computations outside of the current Dart code; this includes computations that don‚Äôt complete immediately, and where you aren‚Äôt willing to block your Dart code waiting for the result. For example, an app might start an HTTP request, but need to update its display or respond to user input before the HTTP request completes. Asynchronous code helps apps stay responsive.

These scenarios include operating system calls like non-blocking I/O, performing an HTTP request, or communicating with a browser. Other scenarios include waiting for computations performed in another Dart isolate as described below, or maybe just waiting for a timer to trigger. All of these processes either run in a different thread, or are handled by the operating system or the Dart runtime, which allows Dart code to run concurrently with the computation.
The async-await syntax

The async and await keywords provide a declarative way to define asynchronous functions and use their results.

Here‚Äôs an example of some synchronous code that blocks while waiting for file I/O:

const String filename = 'with_keys.json';

void main() {
  // Read some data.
  final fileData = _readFileSync();
  final jsonData = jsonDecode(fileData);

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}

String _readFileSync() {
  final file = File(filename);
  final contents = file.readAsStringSync();
  return contents.trim();
}

Here‚Äôs similar code, but with changes (highlighted) to make it asynchronous:

const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final fileData = await _readFileAsync();
  final jsonData = jsonDecode(fileData);

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}

Future<String> _readFileAsync() async {
  final file = File(filename);
  final contents = await file.readAsString();
  return contents.trim();
}

The main() function uses the await keyword in front of _readFileAsync() to let other Dart code (such as event handlers) use the CPU while native code (file I/O) executes. Using await also has the effect of converting the Future<String> returned by _readFileAsync() into a String. As a result, the contents variable has the implicit type String.

Note: The await keyword works only in functions that have async before the function body.

As the following figure shows, the Dart code pauses while readAsString() executes non-Dart code, in either the Dart virtual machine (VM) or the operating system (OS). Once readAsString() returns a value, Dart code execution resumes.

Flowchart-like figure showing app code executing from start to exit, waiting for native I/O in between

If you‚Äôd like to learn more about using async, await, and futures, visit the asynchronous programming codelab.
How isolates work

Most modern devices have multi-core CPUs. To take advantage of multiple cores, developers sometimes use shared-memory threads running concurrently. However, shared-state concurrency is error prone and can lead to complicated code.

Instead of threads, all Dart code runs inside of isolates. Each isolate has its own memory heap, ensuring that none of the state in an isolate is accessible from any other isolate. No shared state between isolates means concurrency complexities like mutexes or locks and data races won‚Äôt occur in Dart. That said, isolates don‚Äôt prevent race conditions all together.

Using isolates, your Dart code can perform multiple independent tasks at once, using additional processor cores if they‚Äôre available. Isolates are like threads or processes, but each isolate has its own memory and a single thread running an event loop.

Platform note: Only the Dart Native platform implements isolates. To learn more about the Dart Web platform, see the Concurrency on the web section.
The main isolate

You often don‚Äôt need to think about isolates at all. Dart programs run in the main isolate by default. It‚Äôs the thread where a program starts to run and execute, as shown in the following figure:

A figure showing a main isolate, which runs `main()`, responds to events, and then exits

Even single-isolate programs can execute smoothly. Before continuing to the next line of code, these apps use async-await to wait for asynchronous operations to complete. A well-behaved app starts quickly, getting to the event loop as soon as possible. The app then responds to each queued event promptly, using asynchronous operations as necessary.
The isolate life cycle

As the following figure shows, every isolate starts by running some Dart code, such as the main() function. This Dart code might register some event listeners‚Äîto respond to user input or file I/O, for example. When the isolate‚Äôs initial function returns, the isolate stays around if it needs to handle events. After handling the events, the isolate exits.

A more general figure showing that any isolate runs some code, optionally responds to events, and then exits
Event handling

In a client app, the main isolate‚Äôs event queue might contain repaint requests and notifications of tap and other UI events. For example, the following figure shows a repaint event, followed by a tap event, followed by two repaint events. The event loop takes events from the queue in first in, first out order.

A figure showing events being fed, one by one, into the event loop

Event handling happens on the main isolate after main() exits. In the following figure, after main() exits, the main isolate handles the first repaint event. After that, the main isolate handles the tap event, followed by a repaint event.

A figure showing the main isolate executing event handlers, one by one

If a synchronous operation takes too much processing time, the app can become unresponsive. In the following figure, the tap-handling code takes too long, so subsequent events are handled too late. The app might appear to freeze, and any animation it performs might be jerky.

A figure showing a tap handler with a too-long execution time

In client apps, the result of a too-lengthy synchronous operation is often janky (non-smooth) UI animation. Worse, the UI might become completely unresponsive.
Background workers

If your app‚Äôs UI becomes unresponsive due to a time-consuming computation‚Äîparsing a large JSON file, for example‚Äîconsider offloading that computation to a worker isolate, often called a background worker. A common case, shown in the following figure, is spawning a simple worker isolate that performs a computation and then exits. The worker isolate returns its result in a message when the worker exits.

A figure showing a main isolate and a simple worker isolate

Each isolate message can deliver one object, which includes anything that‚Äôs transitively reachable from that object. Not all object types are sendable, and the send fails if any transitively reachable object is unsendable. For example, you can send an object of type List<Object> only if none of the objects in the list is unsendable. If one of the objects is, say, a Socket, then the send fails because sockets are unsendable.

For information on the kinds of objects that you can send in messages, see the API reference documentation for the send() method.

A worker isolate can perform I/O (reading and writing files, for example), set timers, and more. It has its own memory and doesn‚Äôt share any state with the main isolate. The worker isolate can block without affecting other isolates.
Code examples

This section discusses some examples that use the Isolate API to implement isolates.
Implementing a simple worker isolate

These examples implement a main isolate that spawns a simple worker isolate. Isolate.run() simplifies the steps behind setting up and managing worker isolates:

    Spawns (starts and creates) an isolate
    Runs a function on the spawned isolate
    Captures the result
    Returns the result to the main isolate
    Terminates the isolate once work is complete
    Checks, captures, and throws exceptions and errors back to the main isolate

Flutter logo Flutter note: If you‚Äôre using Flutter, you can use Flutter‚Äôs compute function instead of Isolate.run(). On the web, the compute function falls back to running the specified function on the current event loop. Use Isolate.run() when targeting native platforms only, for a more ergonomic API.
Running an existing method in a new isolate

The main isolate contains the code that spawns a new isolate:

const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(_readAndParseJson);

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}

The spawned isolate executes the function passed as the first argument, _readAndParseJson:

Future<Map<String, dynamic>> _readAndParseJson() async {
  final fileData = await File(filename).readAsString();
  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
  return jsonData;
}

    Isolate.run() spawns an isolate, the background worker, while main() waits for the result.

    The spawned isolate executes the argument passed to run(): the function _readAndParseJson().

    Isolate.run() takes the result from return and sends the value back to the main isolate, shutting down the worker isolate.

    The worker isolate transfers the memory holding the result to the main isolate. It does not copy the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.

_readAndParseJson() is an existing, asynchronous function that could just as easily run directly in the main isolate. Using Isolate.run() to run it instead enables concurrency. The worker isolate completely abstracts the computations of _readAndParseJson(). It can complete without blocking the main isolate.

The result of Isolate.run() is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn‚Äôt impact the main isolate, because it‚Äôs running concurrently either way.

For the complete program, check out the send_and_receive.dart sample.
Sending closures with isolates

You can also create a simple worker isolate with run() using a function literal, or closure, directly in the main isolate.

const String filename = 'with_keys.json';

void main() async {
  // Read some data.
  final jsonData = await Isolate.run(() async {
    final fileData = await File(filename).readAsString();
    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;
    return jsonData;
  });

  // Use that data.
  print('Number of JSON keys: ${jsonData.length}');
}

This example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.

However, now the isolate sends a closure. Closures are less limited than typical named functions, both in how they function and how they‚Äôre written into the code. In this example, Isolate.run() executes what looks like local code, concurrently. In that sense, you can imagine run() to work like a control flow operator for ‚Äúrun in parallel‚Äù.
Sending multiple messages between isolates

Isolate.run() abstracts a handful of lower-level, isolate-related API to simplify isolate management:

    Isolate.spawn() and Isolate.exit()
    ReceivePort and SendPort

You can use these primitives directly for more granular control over isolate functionality. For example, run() shuts down its isolate after returning a single message. What if you want to allow multiple messages to pass between isolates? You can set up your own isolate much the same way run() is implemented, just utilizing the send() method of SendPort in a slightly different way.

One common pattern, which the following figure shows, is for the main isolate to send a request message to the worker isolate, which then sends one or more reply messages.

A figure showing the main isolate spawning the isolate and then sending a request message, which the worker isolate responds to with a reply message; two request-reply cycles are shown

Check out the long_running_isolate.dart sample, which shows how to spawn a long-running isolate that receives and sends messages multiple times between isolates.
Performance and isolate groups

When an isolate calls Isolate.spawn(), the two isolates have the same executable code and are in the same isolate group. Isolate groups enable performance optimizations such as sharing code; a new isolate immediately runs the code owned by the isolate group. Also, Isolate.exit() works only when the isolates are in the same isolate group.

In some special cases, you might need to use Isolate.spawnUri(), which sets up the new isolate with a copy of the code that‚Äôs at the specified URI. However, spawnUri() is much slower than spawn(), and the new isolate isn‚Äôt in its spawner‚Äôs isolate group. Another performance consequence is that message passing is slower when isolates are in different groups.

Flutter logo Flutter note: Flutter doesn‚Äôt support Isolate.spawnUri().

Concurrency on the web

All Dart apps can use async-await, Future, and Stream for non-blocking, interleaved computations. The Dart web platform, however, does not support isolates. Dart web apps can use web workers to run scripts in background threads similar to isolates. Web workers‚Äô functionality and capabilities differ somewhat from isolates, though.

For instance, when web workers send data between threads, they copy the data back and forth. Data copying can be very slow, though, especially for large messages. Isolates do the same, but also provide APIs that can more efficiently transfer the memory that holds the message instead.

Creating web workers and isolates also differs. You can only create web workers by declaring a separate program entrypoint and compiling it separately. Starting a web worker is similar to using Isolate.spawnUri to start an isolate. You can also start an isolate with Isolate.spawn, which requires fewer resources because it reuses some of the same code and data as the spawning isolate. Web workers don‚Äôt have an equivalent API.

Sound null safety

The Dart language enforces sound null safety.

Null safety prevents errors that result from unintentional access of variables set to null.

For example, if a method expects an integer but receives null, your app causes a runtime error. This type of error, a null dereference error, can be difficult to debug.

With sound null safety, all variables require a value. This means Dart considers all variables non-nullable. You can assign values of the declared type only, like int i=42. You can never assign a value of null to default variable types. To specify that a variable type can have a null value, add a ? after the type annotation: int? i. These specific types can contain either a null or a value of the defined type.

Sound null safety changes potential runtime errors into edit-time analysis errors. With null safety, the Dart analyzer and compilers flag if a non-nullable variable has either:

    Not been initialized with a non-null value
    Been assigned a null value. These checks allows you to fix these errors before deploying your app.

Introduction through examples

With null safety, none of the variables in the following code can be null:

// With null safety, none of these can ever be null.
var i = 42; // Inferred to be an int.
String name = getFileName();
final b = Foo();

To indicate that a variable might have the value null, just add ? to its type declaration:

int? aNullableInt = null;

    To try an interactive example, see the null safety codelab.
    To learn more about this topic, see Understanding null safety.

Null safety principles

Dart supports null safety using the following three core design principles:

    Non-nullable by default. Unless you explicitly tell Dart that a variable can be null, it‚Äôs considered non-nullable. This default was chosen after research found that non-null was by far the most common choice in APIs.

    Fully sound. Dart‚Äôs null safety is sound, which enables compiler optimizations. If the type system determines that something isn‚Äôt null, then that thing can never be null. Once you migrate your whole project and its dependencies to null safety, you reap the full benefits of soundness‚Äînot only fewer bugs, but smaller binaries and faster execution.

Dart 3 and null safety

Dart 3 has built-in sound null safety. Dart 3 prevents code without it from running.

To learn how to migrate to Dart 3, check out the Dart 3 migration guide. Packages developed without null safety support cause issues when resolving dependencies:

 dart pub get

Because pkg1 doesn't support null safety, version solving failed.

=2.9.0 <3.0.0'" must be 2.12.0 or higher to enable null safety.

Libraries incompatible with Dart 3 cause analysis or compilation errors.

 dart analyze .
Analyzing ....                         0.6s

=2.12.0. 
  Try removing the language version override and migrating the code.
  ‚Ä¢ illegal_language_version_override

 dart run bin/my_app.dart
../pkg1/lib/pkg1.dart:1:1: Error: Library doesn't support null safety.
// @dart=2.9
^^^^^^^^^^^^

To resolve these issues:

    Check for null safe versions of any packages you installed from pub.dev
    migrate all of your source code to use sound null safety.

Dart 3 can be found in the stable channels for Dart and Flutter. To learn more, check out the download page for details. To test your code for Dart 3 compatibility, use Dart 3 or later.

 dart --version                     # make sure this reports 3.0.0-417.1.beta or higher

 dart pub get / flutter pub get     # this should resolve without issues

 dart analyze / flutter analyze     # this should pass without errors

If the pub get step fails, check the status of the dependencies.

If the analyze step fails, update your code to resolve the issues listed by the analyzer.
Dart 2.x and null safety

From Dart 2.12 to 2.19, you need to enable null safety. You cannot use null safety in SDK versions earlier than Dart 2.12.

To enable sound null safety, set the SDK constraint lower-bound to a language version of 2.12 or later. For example, your pubspec.yaml file might have the following constraints:

environment:
  sdk: '>=2.12.0 <3.0.0'

Migrating existing code

Warning: Dart 3 removes the dart migrate tool. If you need help migrating your code, run the tool with the 2.19 SDK, then upgrade to Dart 3.

You can migrate without the tool, but it involves hand editing code.

Dart code written without null safety support can be migrated to use null safety. We recommend using the dart migrate tool, included in the Dart SDK versions 2.12 to 2.19.

 cd my_app

 dart migrate

To learn how to migrate your code to null safety, check out the migration guide.
Where to learn more

To learn more about null safety, check out the following resources:

Migrating to null safety

Version note: Dart 2.19 is the final release that supports null-safety migration, including the dart migrate tool. To migrate your package to null safety, use the latest Dart 2.19 SDK. To learn more, see Dart 3 and null safety.

This page describes how and when to migrate your code to null safety. Here are the basic steps for migrating each package that you own:

    Wait for the packages that you depend on to migrate.
    Migrate your package‚Äôs code, preferably using the interactive migration tool.
    Statically analyze your package‚Äôs code.
    Test to make sure your changes work.
    If the package is already on pub.dev, publish the null-safe version as a prerelease version.

Tip: If your application or library is large, check out Gradual null safety migration for large Dart projects.

Migrating an app is technically the same as migrating a package. Before migrating an app, make sure that all of your dependencies are ready.

For an informal look at the experience of using the migration tool, watch this video:
1. Wait to migrate

We strongly recommend migrating code in order, with the leaves of the dependency graph being migrated first. For example, if package C depends on package B, which depends on package A, then A should be migrated to null safety first, then B, then C.

Illustration of C/B/A sentence

Although you can migrate before your dependencies support null safety, you might have to change your code when your dependencies migrate. For example, if you predict that a function will take a nullable parameter but the package migrates it to be non-nullable, then passing a nullable argument becomes a compile error.

You can‚Äîand should‚Äîmigrate your package before packages that depend on it are migrated. Your null-safe package is usable by packages and apps that don‚Äôt use null safety yet, as long as they use Dart 2.12 or later. For example, the Dart and Flutter core libraries are null safe, and they‚Äôre still usable by apps that haven‚Äôt migrated to null safety.

This section tells you how to check and update your package‚Äôs dependencies, with the help of the dart pub outdated command in null-safety mode. The instructions assume your code is under source control, so that you can easily undo any changes.

Switch to the latest Dart 2.19 release

Switch to the latest Dart 2.19 release of the Dart SDK. This is included in the Flutter 3.7 SDK.

Check that you have Dart 2.19:

 dart --version
Dart SDK version: 2.19.6

Check dependency status

Get the migration state of your package‚Äôs dependencies, using the following command:

 dart pub outdated --mode=null-safety

If the output says that all the packages support null safety, then you can start migrating. Otherwise, use the Resolvable column to find null-safe releases, if they exist.

Why do all dependencies need to support null safety? When all of an app‚Äôs direct dependencies support null safety, you can run the app with sound null safety. When all the dev dependencies support null safety, you can run tests with sound null safety. You might also need null-safe dev dependencies for other reasons, such as code generation.

Here‚Äôs an example of the output for a simple package. The green checkmarked version for each package supports null safety:

Output of dart pub outdated

The output shows that all of the package‚Äôs dependencies have resolvable prereleases that support null safety.

If any of your package‚Äôs dependencies don‚Äôt yet support null safety, we encourage you to reach out to the package owner. You can find contact details on the package page on pub.dev.
Update dependencies

Before migrating your package‚Äôs code, update its dependencies to null-safe versions:

    Run dart pub upgrade --null-safety to upgrade to the latest versions supporting null safety. Note: This command changes your pubspec.yaml file.

    Run dart pub get.

2. Migrate

Most of the changes that your code needs to be null safe are easily predictable. For example, if a variable can be null, its type needs a ? suffix. If a named parameter shouldn‚Äôt be nullable, mark it required or give it a default value.

You have two options for migrating:

    Use the migration tool, which can make most of the easily predictable changes for you.
    Migrate your code by hand.

Tip: For additional help while migrating code, check the null safety FAQ.
Using the migration tool

The migration tool takes a package of null-unsafe Dart code and converts it to null safety. You can guide the tool‚Äôs conversion by adding hint markers to your Dart code.

Before starting the tool, make sure you‚Äôre ready:

    Use the latest 2.19 release of the Dart SDK.
    Use dart pub outdated --mode=null-safety to make sure that all dependencies are null safe and up-to-date.

Start the migration tool by running the dart migrate command in the directory that contains the package‚Äôs pubspec.yaml file:

 dart migrate

If your package is ready to migrate, then the tool produces a line like the following:

View the migration suggestions by visiting:

  http://127.0.0.1:60278/Users/you/project/mypkg.console-simple?authToken=Xfz0jvpyeMI%3D

Visit that URL in a Chrome browser to see an interactive UI where you can guide the migration process:

Screenshot of migration tool

For every variable and type annotation, you can see what nullability the tool infers. For example, in the preceding screenshot, the tool infers that the ints list (previously a list of int) in line 1 is nullable, and thus should be a list of int?.
Understanding migration results

To see the reasons for each change (or non-change), click its line number in the Proposed Edits pane. The reasons appear in the Edit Details pane.

For example, consider the following code, from before null safety:

var ints = const <int>[0, null];
var zero = ints[0];
var one = zero + 1;
var zeroOne = <int>[zero, one];

The default migration when this code is outside a function (it‚Äôs different within a function) is backward compatible but not ideal:

var ints = const <int?>[0, null];
var zero = ints[0];
var one = zero! + 1;
var zeroOne = <int?>[zero, one];

By clicking the line 3 link, you can see the migration tool‚Äôs reasons for adding the !. Because you know that zero can‚Äôt be null, you can improve the migration result.
Improving migration results

When analysis infers the wrong nullability, you can override its proposed edits by inserting temporary hint markers:

    In the Edit Details pane of the migration tool, you can insert hint markers using the Add /*?*/ hint and Add /*!*/ hint buttons.

    These buttons add comments to your file immediately, and there‚Äôs no Undo. If you don‚Äôt want a hint that the tool inserted, you can use your usual code editor to remove it.

    You can use an editor to add hint markers, even while the tool is still running. Because your code hasn‚Äôt opted into null safety yet, you can‚Äôt use new null-safety features. You can, however, make changes like refactoring that don‚Äôt depend on null-safety features.

    When you‚Äôve finished editing your code, click Rerun from sources to pick up your changes.

The following table shows the hint markers that you can use to change the migration tool‚Äôs proposed edits.
Hint marker 	Effect on the migration tool
expression /*!*/ 	Adds a ! to the migrated code, casting expression to its underlying non-nullable type.
type /*!*/ 	Marks type as non-nullable.
/*?*/ 	Marks the preceding type as nullable.
/*late*/ 	Marks the variable declaration as late, indicating that it has late initialization.
/*late final*/ 	Marks the variable declaration as late final, indicating that it has late, one-time initialization.
/*required*/ 	Marks the parameter as required.

A single hint can have ripple effects elsewhere in the code. In the example from before, manually adding a /*!*/ marker where zero is assigned its value (on line 2) makes the migration tool infer the type of zero as int instead of int?. This type change can affect code that directly or indirectly uses zero.

var zero = ints[0]/*!*/;

With the above hint, the migration tool changes its proposed edits, as the following code snippets show. Line 3 no longer has a ! after zero, and in line 4 zeroOne is inferred to be a list of int, not int?.
First migration 	Migration with hint

var ints = const <int?>[0, null];
var zero = ints[0];
var one = zero! + 1;
var zeroOne = <int?>[zero, one];

	

var ints = const <int?>[0, null];
var zero = ints[0]/*!*/;
var one = zero + 1;
var zeroOne = <int>[zero, one];

Opting out files

Although we recommend migrating all at once, sometimes that isn‚Äôt practical, especially in a large app or package. To opt out a file or directory, click its green checkbox. Later, when you apply changes, each opted out file will be unchanged except for a 2.9 version comment.

For more information about incremental migration, see Unsound null safety.

Note that only fully migrated apps and packages are compatible with Dart 3.
Applying changes

When you like all of the changes that the migration tool proposes, click Apply migration. The migration tool deletes the hint markers and saves the migrated code. The tool also updates the minimum SDK constraint in the pubspec, which opts the package into null safety.

The next step is to statically analyze your code. If it‚Äôs valid, then test your code. Then, if you‚Äôve published your code on pub.dev, publish a null-safe prerelease.
Migrating by hand

If you prefer not to use the migration tool, you can migrate manually.

We recommend that you first migrate leaf libraries‚Äîlibraries that don‚Äôt import other files from the package. Then migrate libraries that directly depend on the leaf libraries. End by migrating the libraries that have the most intra-package dependencies.

For example, say you have a lib/src/util.dart file that imports other (null-safe) packages and core libraries, but that doesn‚Äôt have any import '<local_path>' directives. Consider migrating util.dart first, and then migrating simple files that depend only on util.dart. If any libraries have cyclic imports (for example, A imports B which imports C, and C imports A), consider migrating those libraries together.

To migrate a package by hand, follow these steps:

    Edit the package‚Äôs pubspec.yaml file, setting the minimum SDK constraint to at least 2.12.0:

    environment:
      sdk: '>=2.12.0 <3.0.0'

    Regenerate the package configuration file:

     dart pub get

    Running dart pub get with a lower SDK constraint of at least 2.12.0 sets the default language version of every library in the package to a minimum of 2.12, opting them all in to null safety.

    Open the package in your IDE.
    You‚Äôre likely to see a lot of analysis errors. That‚Äôs OK.

    Migrate the code of each Dart file, using the analyzer to identify static errors.
    Eliminate static errors by adding ?, !, required, and late, as needed.

See Unsound null safety for more help on migrating code by hand.
3. Analyze

Update your packages (using dart pub get in your IDE or on the command line). Then use your IDE or the command line to perform static analysis on your code:

 dart pub get

 dart analyze     # or `flutter analyze`

4. Test

If your code passes analysis, run tests:

 dart test       # or `flutter test`

You might need to update tests that expect null values.

If you need to make large changes to your code, then you might need to remigrate it. If so, revert your code changes before using the migration tool again.
5. Publish

We encourage you to publish packages‚Äîpossibly as prereleases‚Äîas soon as you migrate:

    Set the package version to indicate a breaking change.
    Update the SDK constraints and package dependencies.
    Publish the package. If you don‚Äôt consider this version to be a stable release, then publish the package as a prerelease.

Update the package version

Update the version of the package to indicate a breaking change:

    If your package is already at 1.0.0 or greater, increase the major version. For example, if the previous version is 2.3.2, the new version is 3.0.0.

    If your package hasn‚Äôt reached 1.0.0 yet, either increase the minor version or update the version to 1.0.0. For example, if the previous version is 0.3.2, the new version is either 0.4.0 or 1.0.0.

Check your pubspec

Before you publish a stable null safety version of a package, we strongly recommend following these pubspec rules:

    Set the Dart lower SDK constraint to the lowest stable version that you‚Äôve tested against (at least 2.12.0).
    Use stable versions of all direct dependencies.

Welcome to null safety

If you made it this far, you should have a fully migrated, null-safe Dart package.

If all of the packages you depend on are migrated too, then your program is sound with respect to null-reference errors. You should see output like this when running or compiling your code:

Compiling with sound null safety

From all of the Dart team, thank you for migrating your code.

Understanding null safety

Written by Bob Nystrom
July 2020

Null safety is the largest change we‚Äôve made to Dart since we replaced the original unsound optional type system with a sound static type system in Dart 2.0. When Dart first launched, compile-time null safety was a rare feature needing a long introduction. Today, Kotlin, Swift, Rust, and other languages all have their own answers to what has become a very familiar problem. Here is an example:

// Without null safety:
bool isEmpty(String string) => string.length == 0;

main() {
  isEmpty(null);
}

If you run this Dart program without null safety, it throws a NoSuchMethodError exception on the call to .length. The null value is an instance of the Null class, and Null has no ‚Äúlength‚Äù getter. Runtime failures suck. This is especially true in a language like Dart that is designed to run on an end-user‚Äôs device. If a server application fails, you can often restart it before anyone notices. But when a Flutter app crashes on a user‚Äôs phone, they are not happy. When your users aren‚Äôt happy, you aren‚Äôt happy.

Developers like statically-typed languages like Dart because they enable the type checker to find mistakes in code at compile time, usually right in the IDE. The sooner you find a bug, the sooner you can fix it. When language designers talk about ‚Äúfixing null reference errors‚Äù, they mean enriching the static type checker so that the language can detect mistakes like the above attempt to call .length on a value that might be null.

There is no one true solution to this problem. Rust and Kotlin both have their own approach that makes sense in the context of those languages. This doc walks through all the details of our answer for Dart. It includes changes to the static type system and a suite of other modifications and new language features to let you not only write null-safe code but hopefully to enjoy doing so.

This document is long. If you want something shorter that covers just what you need to know to get up and running, start with the overview. When you are ready for a deeper understanding and have the time, come back here so you can understand how the language handles null, why we designed it that way, and how to write idiomatic, modern, null-safe Dart. (Spoiler alert: it ends up surprisingly close to how you write Dart today.)

The various ways a language can tackle null reference errors each have their pros and cons. These principles guided the choices we made:

    Code should be safe by default. If you write new Dart code and don‚Äôt use any explicitly unsafe features, it never throws a null reference error at runtime. All possible null reference errors are caught statically. If you want to defer some of that checking to runtime to get greater flexibility, you can, but you have to choose that by using some feature that is textually visible in the code.

    In other words, we aren‚Äôt giving you a life jacket and leaving it up to you to remember to put it on every time you go out on the water. Instead, we give you a boat that doesn‚Äôt sink. You stay dry unless you jump overboard.

    Null safe code should be easy to write. Most existing Dart code is dynamically correct and does not throw null reference errors. You like your Dart program the way it looks now, and we want you to be able to keep writing code that way. Safety shouldn‚Äôt require sacrificing usability, paying penance to the type checker, or having to significantly change the way you think.

    The resulting null safe code should be fully sound. ‚ÄúSoundness‚Äù in the context of static checking means different things to different people. For us, in the context of null safety, that means that if an expression has a static type that does not permit null, then no possible execution of that expression can ever evaluate to null. The language provides this guarantee mostly through static checks, but there can be some runtime checks involved too. (Though, note the first principle: any place where those runtime checks happen will be your choice.)

    Soundness is important for user confidence. A boat that mostly stays afloat is not one you‚Äôre enthused to brave the open seas on. But it‚Äôs also important for our intrepid compiler hackers. When the language makes hard guarantees about semantic properties of a program, it means that the compiler can perform optimizations that assume those properties are true. When it comes to null, it means we can generate smaller code that eliminates unneeded null checks, and faster code that doesn‚Äôt need to verify a receiver is non-null before calling methods on it.

    One caveat: We only guarantee soundness in Dart programs that are fully null safe. Dart supports programs that contain a mixture of newer null safe code and older legacy code. In these mixed-version programs, null reference errors may still occur. In a mixed-version program, you get all of the static safety benefits in the portions that are null safe, but you don‚Äôt get full runtime soundness until the entire application is null safe.

Note that eliminating null is not a goal. There‚Äôs nothing wrong with null. On the contrary, it‚Äôs really useful to be able to represent the absence of a value. Building support for a special ‚Äúabsent‚Äù value directly into the language makes working with absence flexible and usable. It underpins optional parameters, the handy ?. null-aware operator, and default initialization. It is not null that is bad, it is having null go where you don‚Äôt expect it that causes problems.

Thus with null safety, our goal is to give you control and insight into where null can flow through your program and certainty that it can‚Äôt flow somewhere that would cause a crash.
Nullability in the type system

Null safety begins in the static type system because everything else rests upon that. Your Dart program has a whole universe of types in it: primitive types like int and String, collection types like List, and all of the classes and types you and the packages you use define. Before null safety, the static type system allowed the value null to flow into expressions of any of those types.

In type theory lingo, the Null type was treated as a subtype of all types:

The set of operations‚Äîgetters, setters, methods, and operators‚Äîallowed on some expressions are defined by its type. If the type is List, you can call .add() or [] on it. If it‚Äôs int, you can call +. But the null value doesn‚Äôt define any of those methods. Allowing null to flow into an expression of some other type means any of those operations can fail. This is really the crux of null reference errors‚Äîevery failure comes from trying to look up a method or property on null that it doesn‚Äôt have.
Non-nullable and nullable types

Null safety eliminates that problem at the root by changing the type hierarchy. The Null type still exists, but it‚Äôs no longer a subtype of all types. Instead, the type hierarchy looks like this:

Since Null is no longer a subtype, no type except the special Null class permits the value null. We‚Äôve made all types non-nullable by default. If you have a variable of type String, it will always contain a string. There, we‚Äôve fixed all null reference errors.

If we didn‚Äôt think null was useful at all, we could stop here. But null is useful, so we still need a way to handle it. Optional parameters are a good illustrative case. Consider this null safe Dart code:

// Using null safety:
makeCoffee(String coffee, [String? dairy]) {
  if (dairy != null) {
    print('$coffee with $dairy');
  } else {
    print('Black $coffee');
  }
}

Here, we want to allow the dairy parameter to accept any string, or the value null, but nothing else. To express that, we give dairy a nullable type by slapping ? at the end of the underlying base type String. Under the hood, this is essentially defining a union of the underlying type and the Null type. So String? would be a shorthand for String|Null if Dart had full-featured union types.
Using nullable types

If you have an expression with a nullable type, what can you do with the result? Since our principle is safe by default, the answer is not much. We can‚Äôt let you call methods of the underlying type on it because those might fail if the value is null:

// Hypothetical unsound null safety:
bad(String? maybeString) {
  print(maybeString.length);
}

main() {
  bad(null);
}

This would crash if we let you run it. The only methods and properties we can safely let you access are ones defined by both the underlying type and the Null class. That‚Äôs just toString(), ==, and hashCode. So you can use nullable types as map keys, store them in sets, compare them to other values, and use them in string interpolation, but that‚Äôs about it.

How do they interact with non-nullable types? It‚Äôs always safe to pass a non-nullable type to something expecting a nullable type. If a function accepts String? then passing a String is allowed because it won‚Äôt cause any problems. We model this by making every nullable type a supertype of its underlying type. You can also safely pass null to something expecting a nullable type, so Null is also a subtype of every nullable type:

But going the other direction and passing a nullable type to something expecting the underlying non-nullable type is unsafe. Code that expects a String may call String methods on the value. If you pass a String? to it, null could flow in and that could fail:

// Hypothetical unsound null safety:
requireStringNotNull(String definitelyString) {
  print(definitelyString.length);
}

main() {
  String? maybeString = null; // Or not!
  requireStringNotNull(maybeString);
}

This program is not safe and we shouldn‚Äôt allow it. However, Dart has always had this thing called implicit downcasts. If you, for example, pass a value of type Object to a function expecting an String, the type checker allows it:

// Without null safety:
requireStringNotObject(String definitelyString) {
  print(definitelyString.length);
}

main() {
  Object maybeString = 'it is';
  requireStringNotObject(maybeString);
}

To maintain soundness, the compiler silently inserts an as String cast on the argument to requireStringNotObject(). That cast could fail and throw an exception at runtime, but at compile time, Dart says this is OK. Since non-nullable types are modeled as subtypes of nullable types, implicit downcasts would let you pass a String? to something expecting a String. Allowing that would violate our goal of being safe by default. So with null safety we are removing implicit downcasts entirely.

This makes the call to requireStringNotNull() produce a compile error, which is what you want. But it also means all implicit downcasts become compile errors, including the call to requireStringNotObject(). You‚Äôll have to add the explicit downcast yourself:

// Using null safety:
requireStringNotObject(String definitelyString) {
  print(definitelyString.length);
}

main() {
  Object maybeString = 'it is';
  requireStringNotObject(maybeString as String);
}

We think this is an overall good change. Our impression is that most users never liked implicit downcasts. In particular, you may have been burned by this before:

// Without null safety:
List<int> filterEvens(List<int> ints) {
  return ints.where((n) => n.isEven);
}

Spot the bug? The .where() method is lazy, so it returns an Iterable, not a List. This program compiles but then throws an exception at runtime when it tries to cast that Iterable to the List type that filterEvens declares it returns. With the removal of implicit downcasts, this becomes a compile error.

Where were we? Right, OK, so it‚Äôs as if we‚Äôve taken the universe of types in your program and split them into two halves:

There is a region of non-nullable types. Those types let you access all of the interesting methods, but can never ever contain null. And then there is a parallel family of all of the corresponding nullable types. Those permit null, but you can‚Äôt do much with them. We let values flow from the non-nullable side to the nullable side because doing so is safe, but not the other direction.

That seems like nullable types are basically useless. They have no methods and you can‚Äôt get away from them. Don‚Äôt worry, we have a whole suite of features to help you move values from the nullable half over to the other side that we will get to soon.
Top and bottom

This section is a little esoteric. You can mostly skip it, except for two bullets at the very end, unless you‚Äôre into type system stuff. Imagine all the types in your program with edges between ones that are subtypes and supertypes of each other. If you were to draw it, like the diagrams in this doc, it would form a huge directed graph with supertypes like Object near the top and leaf classes like your own types near the bottom.

If that directed graph comes to a point at the top where there is a single type that is the supertype (directly or indirectly), that type is called the top type. Likewise, if there is a weird type at that bottom that is a subtype of every type, you have a bottom type. (In this case, your directed graph is a lattice.)

It‚Äôs convenient if your type system has a top and bottom type, because it means that type-level operations like least upper bound (which type inference uses to figure out the type of a conditional expression based on the types of its two branches) can always produce a type. Before null safety, Object was Dart‚Äôs top type and Null was its bottom type.

Since Object is non-nullable now, it is no longer a top type. Null is not a subtype of it. Dart has no named top type. If you need a top type, you want Object?. Likewise, Null is no longer the bottom type. If it was, everything would still be nullable. Instead, we‚Äôve added a new bottom type named Never:

In practice, this means:

    If you want to indicate that you allow a value of any type, use Object? instead of Object. In fact, it becomes pretty unusual to use Object since that type means ‚Äúcould be any possible value except this one weirdly prohibited value null‚Äù.

    On the rare occasion that you need a bottom type, use Never instead of Null. This is particularly useful to indicate a function never returns to help reachability analysis. If you don‚Äôt know if you need a bottom type, you probably don‚Äôt.

Ensuring correctness

We divided the universe of types into nullable and non-nullable halves. In order to maintain soundness and our principle that you can never get a null reference error at runtime unless you ask for it, we need to guarantee that null never appears in any type on the non-nullable side.

Getting rid of implicit downcasts and removing Null as a bottom type covers all of the main places that types flow through a program across assignments and from arguments into parameters on function calls. The main remaining places where null can sneak in are when a variable first comes into being and when you leave a function. So there are some additional compile errors:
Invalid returns

If a function has a non-nullable return type, then every path through the function must reach a return statement that returns a value. Before null safety, Dart was pretty lax about missing returns. For example:

// Without null safety:
String missingReturn() {
  // No return.
}

If you analyzed this, you got a gentle hint that maybe you forgot a return, but if not, no big deal. That‚Äôs because if execution reaches the end of a function body then Dart implicitly returns null. Since every type is nullable, technically this function is safe, even though it‚Äôs probably not what you want.

With sound non-nullable types, this program is flat out wrong and unsafe. Under null safety, you get a compile error if a function with a non-nullable return type doesn‚Äôt reliably return a value. By ‚Äúreliably‚Äù, I mean that the language analyzes all of the control flow paths through the function. As long as they all return something, it is satisfied. The analysis is pretty smart, so even this function is OK:

// Using null safety:
String alwaysReturns(int n) {
  if (n == 0) {
    return 'zero';
  } else if (n < 0) {
    throw ArgumentError('Negative values not allowed.');
  } else {
    if (n > 1000) {
      return 'big';
    } else {
      return n.toString();
    }
  }
}

We‚Äôll dive more deeply into the new flow analysis in the next section.
Uninitialized variables

When you declare a variable, if you don‚Äôt give it an explicit initializer, Dart default initializes the variable with null. That‚Äôs convenient, but obviously totally unsafe if the variable‚Äôs type is non-nullable. So we have to tighten things up for non-nullable variables:

    Top level variable and static field declarations must have an initializer. Since these can be accessed and assigned from anywhere in the program, it‚Äôs impossible for the compiler to guarantee that the variable has been given a value before it gets used. The only safe option is to require the declaration itself to have an initializing expression that produces a value of the right type:

    // Using null safety:
    int topLevel = 0;

    class SomeClass {
      static int staticField = 0;
    }

    Instance fields must either have an initializer at the declaration, use an initializing formal, or be initialized in the constructor‚Äôs initialization list. That‚Äôs a lot of jargon. Here are the examples:

    // Using null safety:
    class SomeClass {
      int atDeclaration = 0;
      int initializingFormal;
      int initializationList;

      SomeClass(this.initializingFormal)
          : initializationList = 0;
    }

    In other words, as long as the field has a value before you reach the constructor body, you‚Äôre good.

    Local variables are the most flexible case. A non-nullable local variable doesn‚Äôt need to have an initializer. This is perfectly fine:

    // Using null safety:
    int tracingFibonacci(int n) {
      int result;
      if (n < 2) {
        result = n;
      } else {
        result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1);
      }

      print(result);
      return result;
    }

    The rule is only that a local variable must be definitely assigned before it is used. We get to rely on the new flow analysis I alluded to for this as well. As long as every path to a variable‚Äôs use initializes it first, the use is OK.

    Optional parameters must have a default value. If you don‚Äôt pass an argument for an optional positional or named parameter, then the language fills it in with the default value. If you don‚Äôt specify a default value, the default default value is null, and that doesn‚Äôt fly if the parameter‚Äôs type is non-nullable.

    So, if you want a parameter to be optional, you need to either make it nullable or specify a valid non-null default value.

These restrictions sound onerous, but they aren‚Äôt too bad in practice. They are very similar to the existing restrictions around final variables and you‚Äôve likely been working with those for years without even really noticing. Also, remember that these only apply to non-nullable variables. You can always make the type nullable and then get the default initialization to null.

Even so, the rules do cause friction. Fortunately, we have a suite of new language features to lubricate the most common patterns where these new limitations slow you down. First, though, it‚Äôs time to talk about flow analysis.
Flow analysis

Control flow analysis has been around in compilers for years. It‚Äôs mostly hidden from users and used during compiler optimization, but some newer languages have started to use the same techniques for visible language features. Dart already has a dash of flow analysis in the form of type promotion:

// With (or without) null safety:
bool isEmptyList(Object object) {
  if (object is List) {
    return object.isEmpty; // <-- OK!
  } else {
    return false;
  }
}

Note how on the marked line, we can call isEmpty on object. That method is defined on List, not Object. This works because the type checker looks at all of the is expressions and the control flow paths in the program. If the body of some control flow construct only executes when a certain is expression on a variable is true, then inside that body the variable‚Äôs type is ‚Äúpromoted‚Äù to the tested type.

In the example here, the then branch of the if statement only runs when object actually contains a list. Therefore, Dart promotes object to type List instead of its declared type Object. This is a handy feature, but it‚Äôs pretty limited. Prior to null safety, the following functionally identical program did not work:

// Without null safety:
bool isEmptyList(Object object) {
  if (object is! List) return false;
  return object.isEmpty; // <-- Error!
}

Again, you can only reach the .isEmpty call when object contains a list, so this program is dynamically correct. But the type promotion rules were not smart enough to see that the return statement means the second statement can only be reached when object is a list.

For null safety, we‚Äôve taken this limited analysis and made it much more powerful in several ways.
Reachability analysis

First off, we fixed the long-standing complaint that type promotion isn‚Äôt smart about early returns and other unreachable code paths. When analyzing a function, it now takes into account return, break, throw, and any other way execution might terminate early in a function. Under null safety, this function:

// Using null safety:
bool isEmptyList(Object object) {
  if (object is! List) return false;
  return object.isEmpty;
}

Is now perfectly valid. Since the if statement will exit the function when object is not a List, Dart promotes object to be List on the second statement. This is a really nice improvement that helps a lot of Dart code, even stuff not related to nullability.
Never for unreachable code

You can also program this reachability analysis. The new bottom type Never has no values. (What kind of value is simultaneously a String, bool, and int?) So what does it mean for an expression to have type Never? It means that expression can never successfully finish evaluating. It must throw an exception, abort, or otherwise ensure that the surrounding code expecting the result of the expression never runs.

In fact, according to the language, the static type of a throw expression is Never. The type Never is declared in the core libraries and you can use it as a type annotation. Maybe you have a helper function to make it easier to throw a certain kind of exception:

// Using null safety:
Never wrongType(String type, Object value) {
  throw ArgumentError('Expected $type, but was ${value.runtimeType}.');
}

You might use it like so:

// Using null safety:
class Point {
  final double x, y;

  bool operator ==(Object other) {
    if (other is! Point) wrongType('Point', other);
    return x == other.x && y == other.y;
  }

  // Constructor and hashCode...
}

This program analyzes without error. Notice that the last line of the == method accesses .x and .y on other. It has been promoted to Point even though the function doesn‚Äôt have any return or throw. The control flow analysis knows that the declared type of wrongType() is Never which means the then branch of the if statement must abort somehow. Since the second statement can only be reached when other is a Point, Dart promotes it.

In other words, using Never in your own APIs lets you extend Dart‚Äôs reachability analysis.
Definite assignment analysis

I mentioned this one briefly with local variables. Dart needs to ensure a non-nullable local variable is always initialized before it is read. We use definite assignment analysis to be as flexible about that as possible. The language analyzes each function body and tracks the assignments to local variables and parameters through all control flow paths. As long as the variable is assigned on every path that reaches some use of a variable, the variable is considered initialized. This lets you declare a variable with no initializer and then initialize it afterwards using complex control flow, even when the variable has a non-nullable type.

We also use definite assignment analysis to make final variables more flexible. Before null safety, it can be difficult to use final for local variables if you need to initialize them in any sort of interesting way:

// Using null safety:
int tracingFibonacci(int n) {
  final int result;
  if (n < 2) {
    result = n;
  } else {
    result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1);
  }

  print(result);
  return result;
}

This would be an error since the result variable is final but has no initializer. With the smarter flow analysis under null safety, this program is fine. The analysis can tell that result is definitely initialized exactly once on every control flow path, so the constraints for marking a variable final are satisfied.
Type promotion on null checks

The smarter flow analysis helps lots of Dart code, even code not related to nullability. But it‚Äôs not a coincidence that we‚Äôre making these changes now. We have partitioned types into nullable and non-nullable sets. If you have a value of a nullable type, you can‚Äôt really do anything useful with it. In cases where the value is null, that restriction is good. It‚Äôs preventing you from crashing.

But if the value isn‚Äôt null, it would be good to be able to move it over to the non-nullable side so you can call methods on it. Flow analysis is one of the primary ways to do this for local variables and parameters. We‚Äôve extended type promotion to also look at == null and != null expressions.

If you check a local variable with nullable type to see if it is not null, Dart then promotes the variable to the underlying non-nullable type:

// Using null safety:
String makeCommand(String executable, [List<String>? arguments]) {
  var result = executable;
  if (arguments != null) {
    result += ' ' + arguments.join(' ');
  }
  return result;
}

Here, arguments has a nullable type. Normally, that prohibits you from calling .join() on it. But because we have guarded that call in an if statement that checks to ensure the value is not null, Dart promotes it from List<String>? to List<String> and lets you call methods on it or pass it to functions that expect non-nullable lists.

This sounds like a fairly minor thing, but this flow-based promotion on null checks is what makes most existing Dart code work under null safety. Most Dart code is dynamically correct and does avoid throwing null reference errors by checking for null before calling methods. The new flow analysis on null checks turns that dynamic correctness into provable static correctness.

It also, of course, works with the smarter analysis we do for reachability. The above function can be written just as well as:

// Using null safety:
String makeCommand(String executable, [List<String>? arguments]) {
  var result = executable;
  if (arguments == null) return result;
  return result + ' ' + arguments.join(' ');
}

The language is also smarter about what kinds of expressions cause promotion. An explicit == null or != null of course works. But explicit casts using as, or assignments, or the postfix ! operator we‚Äôll get to soon also cause promotion. The general goal is that if the code is dynamically correct and it‚Äôs reasonable to figure that out statically, the analysis should be clever enough to do so.

Note that type promotion only works on local variables, not on fields or top-level variables. For more information about working with non-local variables, see Working with nullable fields.
Unnecessary code warnings

Having smarter reachability analysis and knowing where null can flow through your program helps ensure that you add code to handle null. But we can also use that same analysis to detect code that you don‚Äôt need. Before null safety, if you wrote something like:

// Using null safety:
String checkList(List<Object> list) {
  if (list?.isEmpty ?? false) {
    return 'Got nothing';
  }
  return 'Got something';
}

Dart had no way of knowing if that null-aware ?. operator is useful or not. For all it knows, you could pass null to the function. But in null safe Dart, if you have annotated that function with the now non-nullable List type, then it knows list will never be null. That implies the ?. will never do anything useful and you can and should just use ..

To help you simplify your code, we‚Äôve added warnings for unnecessary code like this now that the static analysis is precise enough to detect it. Using a null-aware operator or even a check like == null or != null on a non-nullable type gets reported as a warning.

And, of course, this plays with non-nullable type promotion too. Once a variable has been promoted to a non-nullable type, you get a warning if you redundantly check it again for null:

// Using null safety:
String checkList(List<Object>? list) {
  if (list == null) return 'No list';
  if (list?.isEmpty ?? false) {
    return 'Empty list';
  }
  return 'Got something';
}

You get a warning on the ?. here because at the point that it executes, we already know list cannot be null. The goal with these warnings is not just to clean up pointless code. By removing unneeded checks for null, we ensure that the remaining meaningful checks stand out. We want you to be able to look at your code and see where null can flow.
Working with nullable types

We‚Äôve now corralled null into the set of nullable types. With flow analysis, we can safely let some non-null values hop over the fence to the non-nullable side where we can use them. That‚Äôs a big step, but if we stop here, the resulting system is still painfully restrictive. Flow analysis only helps with locals and parameters.

To try to regain as much of the flexibility that Dart had before null safety‚Äîand to go beyond it on some places‚Äîwe have a handful of other new features.
Smarter null-aware methods

Dart‚Äôs null aware operator ?. is much older than null safety. The runtime semantics state that if the receiver is null then the property access on the right-hand side is skipped and the expression evaluates to null:

// Without null safety:
String notAString = null;
print(notAString?.length);

Instead of throwing an exception, this prints ‚Äúnull‚Äù. The null-aware operator is a nice tool for making nullable types usable in Dart. While we can‚Äôt let you call methods on nullable types, we can and do let you use null-aware operators on them. The post-null safety version of the program is:

// Using null safety:
String? notAString = null;
print(notAString?.length);

It works just like the previous one.

However, if you‚Äôve ever used null-aware operators in Dart, you‚Äôve probably encountered an annoyance when using them in method chains. Let‚Äôs say you want to see if the length of a potentially absent string is an even number (not a particularly realistic problem, I know, but work with me here):

// Using null safety:
String? notAString = null;
print(notAString?.length.isEven);

Even though this program uses ?., it still throws an exception at runtime. The problem is that the receiver of the .isEven expression is the result of the entire notAString?.length expression to its left. That expression evaluates to null, so we get a null reference error trying to call .isEven. If you‚Äôve ever used ?. in Dart, you probably learned the hard way that you have to apply the null-aware operator to every property or method in a chain after you use it once:

String? notAString = null;
print(notAString?.length?.isEven);

This is annoying, but, worse, it obscures important information. Consider:

// Using null safety:
showGizmo(Thing? thing) {
  print(thing?.doohickey?.gizmo);
}

Here‚Äôs a question for you: Can the doohickey getter on Thing return null? It looks like it could because you‚Äôre using ?. on the result. But it may just be that the second ?. is only there to handle cases where thing is null, not the result of doohickey. You can‚Äôt tell.

To address this, we borrowed a smart idea from C#‚Äôs design of the same feature. When you use a null-aware operator in a method chain, if the receiver evaluates to null, then the entire rest of the method chain is short-circuited and skipped. This means if doohickey has a non-nullable return type, then you can and should write:

// Using null safety:
showGizmo(Thing? thing) {
  print(thing?.doohickey.gizmo);
}

In fact, you‚Äôll get an unnecessary code warning on the second ?. if you don‚Äôt. If you see code like:

// Using null safety:
showGizmo(Thing? thing) {
  print(thing?.doohickey?.gizmo);
}

Then you know for certain it means that doohickey itself has a nullable return type. Each ?. corresponds to a unique path that can cause null to flow into the method chain. This makes null-aware operators in method chains both more terse and more precise.

While we were at it, we added a couple of other null-aware operators:

// Using null safety:

// Null-aware cascade:
receiver?..method();

// Null-aware index operator:
receiver?[index];

There isn‚Äôt a null-aware function call operator, but you can write:

// Allowed with or without null safety:
function?.call(arg1, arg2);

Null assertion operator

The great thing about using flow analysis to move a nullable variable to the non-nullable side of the world is that doing so is provably safe. You get to call methods on the previously-nullable variable without giving up any of the safety or performance of non-nullable types.

But many valid uses of nullable types can‚Äôt be proven to be safe in a way that pleases static analysis. For example:

// Using null safety, incorrectly:
class HttpResponse {
  final int code;
  final String? error;

  HttpResponse.ok()
      : code = 200,
        error = null;
  HttpResponse.notFound()
      : code = 404,
        error = 'Not found';

  @override
  String toString() {
    if (code == 200) return 'OK';
    return 'ERROR $code ${error.toUpperCase()}';
  }
}

If you try to run this, you get a compile error on the call to toUpperCase(). The error field is nullable because it won‚Äôt have a value in a successful response. We can see by inspecting the class that we never access the error message when it is null. But that requires understanding the relationship between the value of code and the nullability of error. The type checker can‚Äôt see that connection.

In other words, we human maintainers of the code know that error won‚Äôt be null at the point that we use it and we need a way to assert that. Normally, you assert types using an as cast, and you can do the same thing here:

// Using null safety:
String toString() {
  if (code == 200) return 'OK';
  return 'ERROR $code ${(error as String).toUpperCase()}';
}

Casting error to the non-nullable String type will throw a runtime exception if the cast fails. Otherwise, it gives us a non-nullable string that we can then call methods on.

‚ÄúCasting away nullability‚Äù comes up often enough that we have a new shorthand syntax. A postfix exclamation mark (!) takes the expression on the left and casts it to its underlying non-nullable type. So the above function is equivalent to:

// Using null safety:
String toString() {
  if (code == 200) return 'OK';
  return 'ERROR $code ${error!.toUpperCase()}';
}

This one-character ‚Äúbang operator‚Äù is particularly handy when the underlying type is verbose. It would be really annoying to have to write as Map<TransactionProviderFactory, List<Set<ResponseFilter>>> just to cast away a single ? from some type.

Of course, like any cast, using ! comes with a loss of static safety. The cast must be checked at runtime to preserve soundness and it may fail and throw an exception. But you have control over where these casts are inserted, and you can always see them by looking through your code.
Late variables

The most common place where the type checker cannot prove the safety of code is around top-level variables and fields. Here is an example:

// Using null safety, incorrectly:
class Coffee {
  String _temperature;

  void heat() { _temperature = 'hot'; }
  void chill() { _temperature = 'iced'; }

  String serve() => _temperature + ' coffee';
}

main() {
  var coffee = Coffee();
  coffee.heat();
  coffee.serve();
}

Here, the heat() method is called before serve(). That means _temperature will be initialized to a non-null value before it is used. But it‚Äôs not feasible for a static analysis to determine that. (It might be possible for a trivial example like this one, but the general case of trying to track the state of each instance of a class is intractable.)

Because the type checker can‚Äôt analyze uses of fields and top-level variables, it has a conservative rule that non-nullable fields have to be initialized either at their declaration (or in the constructor initialization list for instance fields). So Dart reports a compile error on this class.

You can fix the error by making the field nullable and then using null assertion operators on the uses:

// Using null safety:
class Coffee {
  String? _temperature;

  void heat() { _temperature = 'hot'; }
  void chill() { _temperature = 'iced'; }

  String serve() => _temperature! + ' coffee';
}

This works fine. But it sends a confusing signal to the maintainer of the class. By marking _temperature nullable, you imply that null is a useful, meaningful value for that field. But that‚Äôs not the intent. The _temperature field should never be observed in its null state.

To handle the common pattern of state with delayed initialization, we‚Äôve added a new modifier, late. You can use it like this:

// Using null safety:
class Coffee {
  late String _temperature;

  void heat() { _temperature = 'hot'; }
  void chill() { _temperature = 'iced'; }

  String serve() => _temperature + ' coffee';
}

Note that the _temperature field has a non-nullable type, but is not initialized. Also, there‚Äôs no explicit null assertion when it‚Äôs used. There are a few models you can apply to the semantics of late, but I think of it like this: The late modifier means ‚Äúenforce this variable‚Äôs constraints at runtime instead of at compile time‚Äù. It‚Äôs almost like the word ‚Äúlate‚Äù describes when it enforces the variable‚Äôs guarantees.

In this case, since the field is not definitely initialized, every time the field is read, a runtime check is inserted to make sure it has been assigned a value. If it hasn‚Äôt, an exception is thrown. Giving the variable the type String means ‚Äúyou should never see me with a value other than a string‚Äù and the late modifier means ‚Äúverify that at runtime‚Äù.

In some ways, the late modifier is more ‚Äúmagical‚Äù than using ? because any use of the field could fail, and there isn‚Äôt anything textually visible at the use site. But you do have to write late at the declaration to get this behavior, and our belief is that seeing the modifier there is explicit enough for this to be maintainable.

In return, you get better static safety than using a nullable type. Because the field‚Äôs type is non-nullable now, it is a compile error to try to assign null or a nullable String to the field. The late modifier lets you defer initialization, but still prohibits you from treating it like a nullable variable.
Lazy initialization

The late modifier has some other special powers too. It may seem paradoxical, but you can use late on a field that has an initializer:

// Using null safety:
class Weather {
  late int _temperature = _readThermometer();
}

When you do this, the initializer becomes lazy. Instead of running it as soon as the instance is constructed, it is deferred and run lazily the first time the field is accessed. In other words, it works exactly like an initializer on a top-level variable or static field. This can be handy when the initialization expression is costly and may not be needed.

Running the initializer lazily gives you an extra bonus when you use late on an instance field. Usually instance field initializers cannot access this because you don‚Äôt have access to the new object until all field initializers have completed. But with a late field, that‚Äôs no longer true, so you can access this, call methods, or access fields on the instance.
Late final variables

You can also combine late with final:

// Using null safety:
class Coffee {
  late final String _temperature;

  void heat() { _temperature = 'hot'; }
  void chill() { _temperature = 'iced'; }

  String serve() => _temperature + ' coffee';
}

Unlike normal final fields, you do not have to initialize the field in its declaration or in the constructor initialization list. You can assign to it later at runtime. But you can only assign to it once, and that fact is checked at runtime. If you try to assign to it more than once‚Äîlike calling both heat() and chill() here‚Äîthe second assignment throws an exception. This is a great way to model state that gets initialized eventually and is immutable afterwards.

In other words, the new late modifier in combination with Dart‚Äôs other variable modifiers covers most of the feature space of lateinit in Kotlin and lazy in Swift. You can even use it on local variables if you want a little local lazy evaluation.
Required named parameters

To guarantee that you never see a null parameter with a non-nullable type, the type checker requires all optional parameters to either have a nullable type or a default value. What if you want to have a named parameter with a non-nullable type and no default value? That would imply that you want to require the caller to always pass it. In other words, you want a parameter that is named but not optional.

I visualize the various kinds of Dart parameters with this table:

             mandatory    optional
            +------------+------------+
positional  | f(int x)   | f([int x]) |
            +------------+------------+
named       | ???        | f({int x}) |
            +------------+------------+

For unclear reasons, Dart has long supported three corners of this table but left the combination of named+mandatory empty. With null safety, we filled that in. You declare a required named parameter by placing required before the parameter:

// Using null safety:
function({int? a, required int? b, int? c, required int? d}) {}

Here, all the parameters must be passed by name. The parameters a and c are optional and can be omitted. The parameters b and d are required and must be passed. Note that required-ness is independent of nullability. You can have required named parameters of nullable types, and optional named parameters of non-nullable types (if they have a default value).

This is another one of those features that I think makes Dart better regardless of null safety. It simply makes the language feel more complete to me.
Abstract fields

One of the neat features of Dart is that it upholds a thing called the uniform access principle. In human terms it means that fields are indistinguishable from getters and setters. It‚Äôs an implementation detail whether a ‚Äúproperty‚Äù in some Dart class is computed or stored. Because of this, when defining an interface using an abstract class, it‚Äôs typical to use a field declaration:

abstract class Cup {
  Beverage contents;
}

The intent is that users only implement that class and don‚Äôt extend it. The field syntax is simply a shorter way of writing a getter/setter pair:

abstract class Cup {
  Beverage get contents;
  set contents(Beverage);
}

But Dart doesn‚Äôt know that this class will never be used as a concrete type. It sees that contents declaration as a real field. And, unfortunately, that field is non-nullable and has no initializer, so you get a compile error.

One fix is to use explicit abstract getter/setter declarations like in the second example. But that‚Äôs a little verbose, so with null safety we also added support for explicit abstract field declarations:

abstract class Cup {
  abstract Beverage contents;
}

This behaves exactly like the second example. It simply declares an abstract getter and setter with the given name and type.
Working with nullable fields

These new features cover many common patterns and make working with null pretty painless most of the time. But even so, our experience is that nullable fields can still be difficult. In cases where you can make the field late and non-nullable, you‚Äôre golden. But in many cases you need to check to see if the field has a value, and that requires making it nullable so you can observe the null.

You might expect this to work:

// Using null safety, incorrectly:
class Coffee {
  String? _temperature;

  void heat() { _temperature = 'hot'; }
  void chill() { _temperature = 'iced'; }

  void checkTemp() {
    if (_temperature != null) {
      print('Ready to serve ' + _temperature + '!');
    }
  }

  String serve() => _temperature! + ' coffee';
}

Inside checkTemp(), we check to see if _temperature is null. If not, we access it and end up calling + on it. Unfortunately, this is not allowed. Flow-based type promotion does not apply to fields because the static analysis cannot prove that the field‚Äôs value doesn‚Äôt change between the point that you check for null and the point that you use it. (Consider that in pathological cases, the field itself could be overridden by a getter in a subclass that returns null the second time it is called.)

So, since we care about soundness, fields don‚Äôt promote and the above method does not compile. This is annoying. In simple cases like here, your best bet is to slap a ! on the use of the field. It seems redundant, but that‚Äôs more or less how Dart behaves today.

Another pattern that helps is to copy the field to a local variable first and then use that instead:

// Using null safety:
void checkTemp() {
  var temperature = _temperature;
  if (temperature != null) {
    print('Ready to serve ' + temperature + '!');
  }
}

Since the type promotion does apply to locals, this now works fine. If you need to change the value, just remember to store back to the field and not just the local.

For more information on handling these and other type promotion issues, see Fixing type promotion failures.
Nullability and generics

Like most modern statically-typed languages, Dart has generic classes and generic methods. They interact with nullability in a few ways that seem counter-intuitive but make sense once you think through the implications. First is that ‚Äúis this type nullable?‚Äù is no longer a simple yes or no question. Consider:

// Using null safety:
class Box<T> {
  final T object;
  Box(this.object);
}

main() {
  Box<String>('a string');
  Box<int?>(null);
}

In the definition of Box, is T a nullable type or a non-nullable type? As you can see, it can be instantiated with either kind. The answer is that T is a potentially nullable type. Inside the body of a generic class or method, a potentially nullable type has all of the restrictions of both nullable types and non-nullable types.

The former means you can‚Äôt call any methods on it except the handful defined on Object. The latter means that you must initialize any fields or variables of that type before they‚Äôre used. This can make type parameters pretty hard to work with.

In practice, a few patterns show up. In collection-like classes where the type parameter can be instantiated with any type at all, you just have to deal with the restrictions. In most cases, like the example here, it means ensuring you do have access to a value of the type argument‚Äôs type whenever you need to work with one. Fortunately, collection-like classes rarely call methods on their elements.

In places where you don‚Äôt have access to a value, you can make the use of the type parameter nullable:

// Using null safety:
class Box<T> {
  T? object;
  Box.empty();
  Box.full(this.object);
}

Note the ? on the declaration of object. Now the field has an explicitly nullable type, so it is fine to leave it uninitialized.

When you make a type parameter type nullable like T? here, you may need to cast the nullability away. The correct way to do that is using an explicit as T cast, not the ! operator:

// Using null safety:
class Box<T> {
  T? object;
  Box.empty();
  Box.full(this.object);

  T unbox() => object as T;
}

The ! operator always throws if the value is null. But if the type parameter has been instantiated with a nullable type, then null is a perfectly valid value for T:

// Using null safety:
main() {
  var box = Box<int?>.full(null);
  print(box.unbox());
}

This program should run without error. Using as T accomplishes that. Using ! would throw an exception.

Other generic types have some bound that restricts the kinds of type arguments that can be applied:

// Using null safety:
class Interval<T extends num> {
  T min, max;

  Interval(this.min, this.max);

  bool get isEmpty => max <= min;
}

If the bound is non-nullable, then the type parameter is also non-nullable. This means you have the restrictions of non-nullable types‚Äîyou can‚Äôt leave fields and variables uninitialized. The example class here must have a constructor that initializes the fields.

In return for that restriction, you can call any methods on values of the type parameter type that are declared on its bound. Having a non-nullable bound does, however, prevent users of your generic class from instantiating it with a nullable type argument. That‚Äôs probably a reasonable limitation for most classes.

You can also use a nullable bound:

// Using null safety:
class Interval<T extends num?> {
  T min, max;

  Interval(this.min, this.max);

  bool get isEmpty {
    var localMin = min;
    var localMax = max;

    // No min or max means an open-ended interval.
    if (localMin == null || localMax == null) return false;
    return localMax <= localMin;
  }
}

This means that in the body of the class you get the flexibility of treating the type parameter as nullable, but you also have the limitations of nullability. You can‚Äôt call anything on a variable of that type unless you deal with the nullability first. In the example here, we copy the fields in local variables and check those locals for null so that flow analysis promotes them to non-nullable types before we use <=.

Note that a nullable bound does not prevent users from instantiating the class with non-nullable types. A nullable bound means that the type argument can be nullable, not that it must. (In fact, the default bound on type parameters if you don‚Äôt write an extends clause is the nullable bound Object?.) There is no way to require a nullable type argument. If you want uses of the type parameter to reliably be nullable and be implicitly initialized to null, you can use T? inside the body of the class.
Core library changes

There are a couple of other tweaks here and there in the language, but they are minor. Things like the default type of a catch with no on clause is now Object instead of dynamic. Fallthrough analysis in switch statements uses the new flow analysis.

The remaining changes that really matter to you are in the core libraries. Before we embarked on the Grand Null Safety Adventure, we worried that it would turn out there was no way to make our core libraries null safe without massively breaking the world. It turned out not so dire. There are a few significant changes, but for the most part, the migration went smoothly. Most core libraries either did not accept null and naturally move to non-nullable types, or do and gracefully accept it with a nullable type.

There are a few important corners, though:
The Map index operator is nullable

This isn‚Äôt really a change, but more a thing to know. The index [] operator on the Map class returns null if the key isn‚Äôt present. This implies that the return type of that operator must be nullable: V? instead of V.

We could have changed that method to throw an exception when the key isn‚Äôt present and then given it an easier-to-use non-nullable return type. But code that uses the index operator and checks for null to see if the key is absent is very common, around half of all uses based on our analysis. Breaking all of that code would have set the Dart ecosystem aflame.

Instead, the runtime behavior is the same and thus the return type is obliged to be nullable. This means you generally cannot immediately use the result of a map lookup:

// Using null safety, incorrectly:
var map = {'key': 'value'};
print(map['key'].length); // Error.

This gives you a compile error on the attempt to call .length on a nullable string. In cases where you know the key is present you can teach the type checker by using !:

// Using null safety:
var map = {'key': 'value'};
print(map['key']!.length); // OK.

We considered adding another method to Map that would do this for you: look up the key, throw if not found, or return a non-nullable value otherwise. But what to call it? No name would be shorter than the single-character !, and no method name would be clearer than seeing a ! with its built-in semantics right there at the call site. So the idiomatic way to access a known-present element in a map is to use []!. You get used to it.
No unnamed List constructor

The unnamed constructor on List creates a new list with the given size but does not initialize any of the elements. This would poke a very large hole in the soundness guarantees if you created a list of a non-nullable type and then accessed an element.

To avoid that, we have removed the constructor entirely. It is an error to call List() in null safe code, even with a nullable type. That sounds scary, but in practice most code creates lists using list literals, List.filled(), List.generate(), or as a result of transforming some other collection. For the edge case where you want to create an empty list of some type, we added a new List.empty() constructor.

The pattern of creating a completely uninitialized list has always felt out of place in Dart, and now it is even more so. If you have code broken by this, you can always fix it by using one of the many other ways to produce a list.
Cannot set a larger length on non-nullable lists

This is little known, but the length getter on List also has a corresponding setter. You can set the length to a shorter value to truncate the list. And you can also set it to a longer length to pad the list with uninitialized elements.

If you were to do that with a list of a non-nullable type, you‚Äôd violate soundness when you later accessed those unwritten elements. To prevent that, the length setter will throw a runtime exception if (and only if) the list has a non-nullable element type and you set it to a longer length. It is still fine to truncate lists of all types, and you can grow lists of nullable types.

There is an important consequence of this if you define your own list types that extend ListBase or apply ListMixin. Both of those types provide an implementation of insert() that previously made room for the inserted element by setting the length. That would fail with null safety, so instead we changed the implementation of insert() in ListMixin (which ListBase shares) to call add() instead. Your custom list class should provide a definition of add() if you want to be able to use that inherited insert() method.
Cannot access Iterator.current before or after iteration

The Iterator class is the mutable ‚Äúcursor‚Äù class used to traverse the elements of a type that implements Iterable. You are expected to call moveNext() before accessing any elements to advance to the first element. When that method returns false, you have reached the end and there are no more elements.

It used to be that current returned null if you called it either before calling moveNext() the first time or after iteration finished. With null safety, that would require the return type of current to be E? and not E. That in turn means every element access would require a runtime null check.

Those checks would be useless given that almost no one ever accesses the current element in that erroneous way. Instead, we have made the type of current be E. Since there may be a value of that type available before or after iterating, we‚Äôve left the iterator‚Äôs behavior undefined if you call it when you aren‚Äôt supposed to. Most implementations of Iterator throw a StateError.
Summary

That is a very detailed tour through all of the language and library changes around null safety. It‚Äôs a lot of stuff, but this is a pretty big language change. More importantly, we wanted to get to a point where Dart still feels cohesive and usable. That requires changing not just the type system, but a number of other usability features around it. We didn‚Äôt want it to feel like null safety was bolted on.

The core points to take away are:

    Types are non-nullable by default and made nullable by adding ?.

    Optional parameters must be nullable or have a default value. You can use required to make named parameters non-optional. Non-nullable top-level variables and static fields must have initializers. Non-nullable instance fields must be initialized before the constructor body begins.

    Method chains after null-aware operators short circuit if the receiver is null. There are new null-aware cascade (?..) and index (?[]) operators. The postfix null assertion ‚Äúbang‚Äù operator (!) casts its nullable operand to the underlying non-nullable type.

    Flow analysis lets you safely turn nullable local variables and parameters into usable non-nullable ones. The new flow analysis also has smarter rules for type promotion, missing returns, unreachable code, and variable initialization.

    The late modifier lets you use non-nullable types and final in places you otherwise might not be able to, at the expense of runtime checking. It also gives you lazy-initialized fields.

    The List class is changed to prevent uninitialized elements.

Finally, once you absorb all of that and get your code into the world of null safety, you get a sound program that the compilers can optimize and where every place a runtime error can occur is visible in your code. We hope you feel that‚Äôs worth the effort to get there.


Unsound null safety

A Dart program may contain some libraries that are null safe and some that aren‚Äôt. These mixed-version programs rely on unsound null safety.

Dart 3‚Äîplanned for a mid-2023 release‚Äîrequires sound null safety. It will prevent code from running without null safety, or with unsound null safety. All existing code must be migrated to sound null safety to be compatible with Dart 3. To learn more, see the Dart 3 sound null safety tracking issue.

The ability to mix language versions frees package maintainers to migrate their code, with the knowledge that even legacy users can get new bug fixes and other improvements. However, mixed-version programs don‚Äôt get all the advantages that null safety can bring.

This page describes the differences between sound and unsound null safety, with the goal of helping you decide when to migrate to null safety. After the conceptual discussion are instructions for migrating incrementally, followed by details on testing and running mixed-version programs.

Note: We recommend that, if possible, you wait for dependencies to migrate before you migrate your package. For details, see the migration guide.
Sound and unsound null safety

Dart provides sound null safety through a combination of static and runtime checks. Each Dart library that opts in to null safety gets all the static checks, with stricter compile-time errors. This is true even in a mixed-version program that contains null-unsafe libraries. You start getting these benefits as soon as you start migrating some of your code to null safety.

However, a mixed-version program can‚Äôt have the runtime soundness guarantees that a fully null-safe app has. It‚Äôs possible for null to leak out of the null-unsafe libraries into the null-safe code, because preventing that would break the existing behavior of the unmigrated code.

To maintain runtime compatibility with legacy libraries while offering soundness to completely null-safe programs, Dart tools support two modes:

    Mixed-version programs run with unsound null safety. It‚Äôs possible for null reference errors to occur at runtime, but only because a null or nullable type escaped from some null-unsafe library and got into null-safe code.

    When a program is fully migrated and all its libraries are null safe, then it runs with sound null safety, with all of the guarantees and compiler optimizations that soundness enables.

Sound null safety is what you want if possible. Dart tools automatically run your program in sound mode if the main entrypoint library of your program has opted into null safety. If you import a null-unsafe library, the tools print a warning to let you know that they can only run with unsound null safety.
Migrating incrementally

Because Dart supports mixed-version programs, you can migrate one library (generally one Dart file) at a time, while still being able to run your program and its tests.

We recommend that you first migrate leaf libraries‚Äîlibraries that don‚Äôt import other files from the package. Then migrate libraries that directly depend on the leaf libraries. End by migrating the libraries that have the most intra-package dependencies.

For example, say you have a lib/src/util.dart file that imports other (null-safe) packages and core libraries, but that doesn‚Äôt have any import '<local_path>' directives. Consider migrating util.dart first, and then migrating files that depend only on util.dart. If any libraries have cyclic imports (for example, A imports B which imports C, and C imports A), consider migrating those libraries together.
Using the migration tool

You can migrate incrementally using the migration tool. To opt out files or directories, click the green checkbox. In the following screenshot, all files in the bin directory are opted out.

Screenshot of file viewer in migration tool

Each opted out file will be unchanged except for a 2.9 language version comment. You can later run dart migrate again to continue the migration. Any files that are already migrated feature a disabled checkbox: you cannot un-migrate a file once it has been migrated.
Migrating by hand

If you want to incrementally migrate a package by hand, follow these steps:

    Edit the package‚Äôs pubspec.yaml file, setting the minimum SDK constraint to at least 2.12.0:

    environment:
      sdk: '>=2.12.0 <3.0.0'

    Regenerate the package configuration file:

     dart pub get

    Running dart pub get with a lower SDK constraint of 2.12.0 sets the default language version of every library in the package to 2.12, opting them all in to null safety.

    Open the package in your IDE.
    You‚Äôre likely to see a lot of analysis errors. That‚Äôs OK.

    Add a language version comment to the top of any Dart files that you don‚Äôt want to consider during your current migration:

    // @dart=2.9

    Using language version 2.9 for a library that‚Äôs in a 2.12 package can reduce analysis errors (red squiggles) coming from unmigrated code. However, unsound null safety reduces the information the analyzer can use. For example, the analyzer might assume a parameter type is non-nullable, even though a 2.9 file might pass in a null value.

    Migrate the code of each Dart file, using the analyzer to identify static errors.
    Eliminate static errors by adding ?, !, required, and late, as needed.

Testing or running mixed-version programs

To test or run mixed-version code, you need to disable sound null safety. You can do this in two ways:

    Disable sound null safety using the --no-sound-null-safety flag to the dart or flutter command:

 dart --no-sound-null-safety run

     flutter run --no-sound-null-safety

    Alternatively, set the language version in the entrypoint‚Äîthe file that contains main() function‚Äîto 2.9. In Flutter apps, this file is often named lib/main.dart. In command-line apps, this file is often named bin/<packageName>.dart. You can also opt out files under test, because they are also entrypoints. Example:

    // @dart=2.9
    import 'src/my_app.dart';

    void main() {
      //...
    }

Opting out tests using either of these mechanisms can be useful for testing during your incremental migration process, but doing so means that you aren‚Äôt testing your code with full null safety enabled. It‚Äôs important to opt your tests back in to null safety when you‚Äôve finished the incremental migration of your libraries.

Null safety: Frequently asked questions

This page collects some common questions we‚Äôve heard about null safety based on the experience of migrating Google internal code.
What runtime changes should I be aware of for users of migrated code?

Most of the effects of migration do not immediately affect users of migrated code:

    Static null safety checks for users first apply when they migrate their code.
    Full null safety checks happen when all the code is migrated and sound mode is turned on.

Two exceptions to be aware of are:

    The ! operator is a runtime null check in all modes, for all users. So, when migrating, ensure that you only add ! where it‚Äôs an error for a null to flow to that location, even if the calling code has not migrated yet.
    Runtime checks associated with the late keyword apply in all modes, for all users. Only mark a field late if you are sure it is always initialized before it is used.

What if a value is only null in tests?

If a value is only ever null in tests, the code can be improved by marking it non-nullable and making the tests pass non-null values.
How does @required compare to the new required keyword?

The @required annotation marks named arguments that must be passed; if not, the analyzer reports a hint.

With null safety, a named argument with a non-nullable type must either have a default or be marked with the new required keyword. Otherwise, it wouldn‚Äôt make sense for it to be non-nullable, because it would default to null when not passed.

When null safe code is called from legacy code the required keyword is treated exactly like the @required annotation: failure to supply the argument will cause an analyzer hint.

When null safe code is called from null safe code, failing to supply a required argument is an error.

What does this mean for migration? Be careful if adding required where there was no @required before. Any callers not passing the newly-required argument will no longer compile. Instead, you could add a default or make the argument type nullable.
How should I migrate non-nullable fields that should be final, but aren‚Äôt?

Some computations can be moved to the static initializer. Instead of:

// Initialized without values
ListQueue _context;
Float32List _buffer;
dynamic _readObject;

Vec2D(Map<String, dynamic> object) {
  _buffer = Float32List.fromList([0.0, 0.0]);
  _readObject = object['container'];
  _context = ListQueue<dynamic>();
}

you can do:

// Initialized with values
final ListQueue _context = ListQueue<dynamic>();
final Float32List _buffer = Float32List.fromList([0.0, 0.0]);
final dynamic _readObject;

Vec2D(Map<String, dynamic> object) : _readObject = object['container'];

However, if a field is initialized by doing computation in the constructor, then it can‚Äôt be final. With null safety, you‚Äôll find this also makes it harder for it to be non-nullable; if it‚Äôs initialized too late, then it‚Äôs null until it‚Äôs initialized, and must be nullable. Fortunately, you have options:

    Turn the constructor into a factory, then make it delegate to an actual constructor that initializes all the fields directly. A common name for such a private constructor is just an underscore: _. Then, the field can be final and non-nullable. This refactoring can be done before the migration to null safety.
    Or, mark the field late final. This enforces that it‚Äôs initialized exactly once. It must be initialized before it can be read.

How should I migrate a built_value class?

Getters that were annotated @nullable should instead have nullable types; then remove all @nullable annotations. For example:

@nullable
int get count;

becomes

int? get count; //  Variable initialized with ?

Getters that were not marked @nullable should not have nullable types, even if the migration tool suggests them. Add ! hints as needed then rerun the analysis.
How should I migrate a factory that can return null?

Prefer factories that do not return null. We have seen code that meant to throw an exception due to invalid input but instead ended up returning null.

Instead of:

factory StreamReader(dynamic data) {
  StreamReader reader;
  if (data is ByteData) {
    reader = BlockReader(data);
  } else if (data is Map) {
    reader = JSONBlockReader(data);
  }
  return reader;
}

Do:

factory StreamReader(dynamic data) {
  if (data is ByteData) {
    // Move the readIndex forward for the binary reader.
    return BlockReader(data);
  } else if (data is Map) {
    return JSONBlockReader(data);
  } else {
    throw ArgumentError('Unexpected type for data');
  }
}

If the intent of the factory was indeed to return null, then you can turn it into a static method so it is allowed to return null.
How should I migrate an assert(x != null) that now shows as unnecessary?

The assert will be unnecessary when everything is fully migrated, but for now it is needed if you actually want to keep the check. Options:

    Decide that the assert is not really necessary, and remove it. This is a change in behavior when asserts are enabled.
    Decide that the assert can be checked always, and turn it into ArgumentError.checkNotNull. This is a change in behavior when asserts are not enabled.
    Keep the behavior exactly as is: add // ignore: unnecessary_null_comparison to bypass the warning.

How should I migrate a runtime null check that now shows as unnecessary?

The compiler flags an explicit runtime null check as an unnecessary comparison if you make arg non-nullable.

if (arg == null) throw ArgumentError(...)`

You must include this check if the program is a mixed-version one. Until everything is fully migrated and the code switches to running with sound null safety, arg might be set to null.

The simplest way to preserve behavior is change the check into ArgumentError.checkNotNull.

The same applies to some runtime type checks. If arg has static type String, then if (arg is! String) is actually checking whether arg is null. It might look like migrating to null safety means arg can never be null, but it could be null in unsound null safety. So, to preserve behavior, the null check should remain.
The Iterable.firstWhere method no longer accepts orElse: () => null.

Import package:collection and use the extension method firstWhereOrNull instead of firstWhere.
How do I deal with attributes that have setters?

Unlike the late final suggestion above, these attributes cannot be marked as final. Often, settable attributes also do not have initial values since they are expected to be set sometime later.

In such cases, you have two options:

    Set it to an initial value. Often times, the omission of an initial value is by mistake rather than deliberate.

    If you are sure that the attribute needs to be set before accessed, mark it as late.

    WARNING: The late keyword adds a runtime check. If any user calls get before set they‚Äôll get an error at runtime.

How do I signal that the return value from a Map is non-nullable?

The lookup operator on Map ([]) by default returns a nullable type. There‚Äôs no way to signal to the language that the value is guaranteed to be there.

In this case, you should use the bang operator (!) to cast the value back to V:

return blockTypes[key]!;

Which will throw if the map returns null. If you want explicit handling for that case:

var result = blockTypes[key];
if (result != null) return result;
// Handle the null case here, e.g. throw with explanation.

Why is the generic type on my List/Map nullable?

It is typically a code smell to end up with nullable code like this:

List<Foo?> fooList; // fooList can contain null values

This implies fooList might contain null values. This might happen if you are initializing the list with length and filling it in via a loop.

If you are simply initializing the list with the same value, you should instead use the filled constructor.

_jellyCounts = List<int?>(jellyMax + 1);
for (var i = 0; i <= jellyMax; i++) {
  _jellyCounts[i] = 0; // List initialized with the same value
}

_jellyCounts = List<int>.filled(jellyMax + 1, 0); // List initialized with filled constructor

If you are setting the elements of the list via an index, or you are populating each element of the list with a distinct value, you should instead use the list literal syntax to build the list.

_jellyPoints = List<Vec2D?>(jellyMax + 1);
for (var i = 0; i <= jellyMax; i++) {
  _jellyPoints[i] = Vec2D(); // Each list element is a distinct Vec2D
}

_jellyPoints = [
  for (var i = 0; i <= jellyMax; i++)
    Vec2D() // Each list element is a distinct Vec2D
];

To generate a fixed-length list, use the List.generate constructor with the growable parameter set to false:

_jellyPoints = List.generate(jellyMax, (_) => Vec2D(), growable: false);

What happened to the default List constructor?

You may encounter this error:

The default 'List' constructor isn't available when null safety is enabled. #default_list_constructor

The default list constructor fills the list with null, which is a problem.

Change it to List.filled(length, default) instead.
I‚Äôm using package:ffi and get a failure with Dart_CObject_kUnsupported when I migrate. What happened?

Lists sent via ffi can only be List<dynamic>, not List<Object> or List<Object?>. If you didn‚Äôt change a list type explicitly in your migration, a type might still have changed because of changes to type inference that happen when you enable null safety.

The fix is to explicitly create such lists as List<dynamic>.
Why does the migration tool add comments to my code?

The migration tool adds /* == false */ or /* == true */ comments when it sees conditions that will always be false or true while running in sound mode. Comments like these might indicate that the automatic migration is incorrect and needs human intervention. For example:

if (registry.viewFactory(viewDescriptor.id) == null /* == false */)

In these cases, the migration tool can‚Äôt distinguish defensive-coding situations and situations where a null value is really expected. So the tool tells you what it knows (‚Äúit looks like this condition will always be false!‚Äù) and lets you decide what to do.
What should I know about compiling to JavaScript and null safety?

Null safety brings many benefits like reduced code size and improved app performance. Such benefits surface more when compiled to native targets like Flutter and AOT. Previous work on the production web compiler had introduced optimizations similar to what null safety later introduced. This may make resulting gains to production web apps seem less than their native targets.

A few notes that are worth highlighting:

    The production JavaScript compiler generates ! null assertions. You might not notice them when comparing the output of the compiler before and after adding null assertions. That‚Äôs because the compiler already generated null checks in programs that weren‚Äôt null safe.

    The compiler generates these null assertions regardless of the soundness of null safety or optimization level. In fact, the compiler doesn‚Äôt remove ! when using -O3 or --omit-implicit-checks.

    The production JavaScript compiler might remove unnecessary null checks. This happens because the optimizations that the production web compiler made prior to null safety removed those checks when it knew the value was not null.

    By default, the compiler would generate parameter subtype checks. These runtime checks ensure covariant virtual calls have appropriate arguments. The compiler skips these checks with the --omit-implicit-checks option. Using this option can generate apps with unexpected behavior if the code includes invalid types. To avoid any surprises, continue provide strong test coverage for your code. In particular, the compiler optimizes code based on the fact that inputs should comply with the type declaration. If the code provides arguments of an invalid type, those optimizations would be wrong and the program could misbehave. This was true for inconsistent types before, and is true with inconsistent nullabilities now with sound null-safety.

    You may notice that the development JavaScript compiler and the Dart VM have special error messages for null checks, but to keep applications small, the production JavaScript compiler does not.

    You may see errors indicating that .toString is not found on null. This is not a bug. The compiler has always encoded some null checks in this way. That is, the compiler represents some null checks compactly by making an unguarded access of a property of the receiver. So instead of if (a == null) throw, it generates a.toString. The toString method is defined in JavaScript Object and is a fast way to verify that an object is not null.

    If the very first action after a null check is an action that crashes when the value is null, the compiler can remove the null check and let the action cause the error.

    For example, a Dart expression print(a!.foo()); could turn directly into:

      P.print(a.foo$0());

    This is because the call a.foo$() will crash if a is null. If the compiler inlines foo, it will preserve the null check. So for example, if foo was int foo() => 1; the compiler might generate:

      a.toString;
      P.print(1);

    If the inlined method first accessed a field on the receiver, like int foo() => this.x + 1;, then the production compiler can remove the redundant a.toString null check, as non-inlined calls, and generate:

      P.print(a.x + 1);


  Control flow statements. .

 Dart supports the usual control flow statements: .

| if (year >= 2001) {
|   print('21st century');
| } else if (year >= 1901) {
|   print('20th century');
| }

| for (final object in flybyObjects) {
|   print(object);
| }

| for (int month = 1; month <= 12; month++) {
|   print(month);
| }

| while (year < 2016) {
|   year += 1;
| }

  Functions. .
 We recommend specifying the types of each function‚Äôs arguments and return value: .

| int fibonacci(int n) {
|   if (n == 0 || n == 1) return n;
|   return fibonacci(n - 1) + fibonacci(n - 2);
| }

| var result = fibonacci(20);

 A shorthand => (arrow) syntax is handy for functions that contain a single statement. .
 This syntax is especially useful when passing anonymous functions as arguments: .
 
 | flybyObjects.where((name) => name.contains('turn')).forEach(print);

 Besides showing an anonymous function (the argument to where()), this code shows that you can use a function as an argument: .
 the top-level print() function is an argument to forEach(). .

  Loops. .

 This page shows how you can control the flow of your Dart code using loops and supporting statements: .

for loops .
while and do while loops .
break and continue .

 You can also manipulate control flow in Dart using: .

Branching, like if and switch .
Exceptions, like try, catch, and throw. .

  For loops. .

 You can iterate with the standard for loop. For example: .

| var message = StringBuffer('Dart is fun');
| for (var i = 0; i < 5; i++) {
|  message.write('!');
| }

 Closures inside of Dart‚Äôs for loops capture the value of the index. This avoids a common pitfall .
 found in JavaScript. For example, consider: .

| var callbacks = [];
| for (var i = 0; i < 2; i++) {
|   callbacks.add(() => print(i));
| }

| for (final c in callbacks) {
|   c();
| }

 The output is 0 and then 1, as expected. In contrast, the example would print 2 and then 2 in JavaScript. .

 Sometimes you might not need to know the current iteration counter when iterating over an Iterable type, .
 like List or Set. In that case, use the for-in loop for cleaner code: .

| for (final candidate in candidates) {
|   candidate.interview();
| }

 To process the values obtained from the iterable, you can also use a pattern in a for-in loop: .

| for (final Candidate(:name, :yearsExperience) in candidates) {
|   print('$name has $yearsExperience of experience.');
| }

 Tip: To practice using for-in, follow the Iterable collections codelab. .

 Iterable classes also have a forEach() method as another option: .

| var collection = [1, 2, 3];
| collection.forEach(print); // 1 2 3

  While and do-while. .

 A while loop evaluates the condition before the loop: .

| while (!isDone()) {
|   doSomething();
| }

 A do-while loop evaluates the condition after the loop: .

| do {
|   printLine();
| } while (!atEndOfPage());

 Break and continue. .

 Use break to stop looping: .

| while (true) {
|   if (shutDownRequested()) break;
|   processIncomingRequests();
| }

 Use continue to skip to the next loop iteration: .

| for (int i = 0; i < candidates.length; i++) {
|   var candidate = candidates[i];
|   if (candidate.yearsExperience < 5) {
|     continue;
|   }
|   candidate.interview();
| }

 If you‚Äôre using an Iterable such as a list or set, how you write the previous example might differ: .

| candidates
|     .where((c) => c.yearsExperience >= 5)
|     .forEach((c) => c.interview());

  Branches. .

 This page shows how you can control the flow of your Dart code using branches: .

if statements and elements .
if-case statements and elements .
switch statements and expressions .

 You can also manipulate control flow in Dart using: .

Loops, like for and while .
Exceptions, like try, catch, and throw .

  If. .

 Dart supports if statements with optional else clauses. The condition in parentheses after .
 if must be an expression that evaluates to a boolean: .

| if (isRaining()) {
|   you.bringRainCoat();
| } else if (isSnowing()) {
|   you.wearJacket();
| } else {
|   car.putTopDown();
| }

 To learn how to use if in an expression context, check out Conditional expressions. .

  If-case. .

 Dart if statements support case clauses followed by a pattern: .

| if (pair case [int x, int y]) return Point(x, y);

 If the pattern matches the value, then the branch executes with any variables the pattern defines in scope. .

 In the previous example, the list pattern [int x, int y] matches the value pair, .
 so the branch return Point(x, y) executes with the variables that the pattern defined, x and y. .

 Otherwise, control flow progresses to the else branch to execute, if there is one: .

| if (pair case [int x, int y]) {
|   print('Was coordinate array $x,$y');
| } else {
|   throw FormatException('Invalid coordinates.');
| }

 The if-case statement provides a way to match and destructure against a single pattern. .
 To test a value against multiple patterns, use switch. .

 Version note: Case clauses in if statements require a language version of at least 3.0. .

  Switch statements. .

 A switch statement evaluates a value expression against a series of cases. .
 Each case clause is a pattern for the value to match against. You can use any kind of pattern for a case. .

 When the value matches a case‚Äôs pattern, the case body executes. .Non-empty case clauses jump to the end .
 of the switch after completion. They do not require a break statement. Other valid ways to end .
 a non-empty case clause are a continue, throw, or return statement. .
 
 Use a default or wildcard _ clause to execute code when no case clause matches: .

| var command = 'OPEN';
| switch (command) {
|   case 'CLOSED':
|     executeClosed();
|   case 'PENDING':
|     executePending();
|   case 'APPROVED':
|     executeApproved();
|   case 'DENIED':
|     executeDenied();
|   case 'OPEN':
|     executeOpen();
|   default:
|     executeUnknown();
| }

 Empty cases fall through to the next case. For an empty case that does not fall through, .
 use break for its body. For non-sequential fall-through, you can use a continue statement and a label: .

| switch (command) {
|   case 'OPEN':
|     executeOpen();
|     continue newCase; // Continues executing at the newCase label.
| 
|   case 'DENIED': // Empty case falls through.
|   case 'CLOSED':
|     executeClosed(); // Runs for both DENIED and CLOSED,
| 
|   newCase:
|   case 'PENDING':
|     executeNowClosed(); // Runs for both OPEN and PENDING.
| }

 You can use logical-or patterns to allow cases to share a body or a guard. To learn more about patterns .
 and case clauses, check out the patterns documentation on Switch statements and expressions. .

  Switch expressions. .

 A switch expression produces a value based on the expression body of whichever case matches. .
 You can use a switch expression wherever Dart allows expressions, except at the start of an .
 expression statement. For example: .

| var x = switch (y) { ... };
| 
| print(switch (x) { ... });
| 
| return switch (x) { ... };

 If you want to use a switch at the start of an expression statement, use a switch statement. .

 Switch expressions allow you to rewrite a switch statement like this: .

| // Where slash, star, comma, semicolon, etc., are constant variables...
| switch (charCode) {
|   case slash || star || plus || minus: // Logical-or pattern
|     token = operator(charCode);
|   case comma || semicolon: // Logical-or pattern
|     token = punctuation(charCode);
|   case >= digit0 && <= digit9: // Relational and logical-and patterns
|     token = number();
|   default:
|     throw FormatException('Invalid');
| }

 Into an expression, like this: .

| token = switch (charCode) {
|   slash || star || plus || minus => operator(charCode),
|   comma || semicolon => punctuation(charCode),
|   >= digit0 && <= digit9 => number(),
|   _ => throw FormatException('Invalid')
| };

 The syntax of a switch expression differs from switch statement syntax: .

Cases do not start with the case keyword. .
A case body is a single expression instead of a series of statements. .
Each case must have a body; there is no implicit fallthrough for empty cases. .
Case patterns are separated from their bodies using => instead of :. .
Cases are separated by , (and an optional trailing , is allowed). .
Default cases can only use _, instead of allowing both default and _. .

 Version note: Switch expressions require a language version of at least 3.0. .

  Exhaustiveness checking. .

 Exhaustiveness checking is a feature that reports a compile-time error if it‚Äôs possible .
 for a value to enter a switch but not match any of the cases. .

| // Non-exhaustive switch on bool?, missing case to match null possibility:
| switch (nullableBool) {
|   case true:
|     print('yes');
|   case false:
|     print('no');
| }

 A default case (default or _) covers all possible values that can flow through a switch. .
 This makes a switch on any type exhaustive. .

 Enums and sealed types are particularly useful for switches because, even without a default case, .
 their possible values are known and fully enumerable. Use the sealed modifier on a class to enable .
 exhaustiveness checking when switching over subtypes of that class: .

| sealed class Shape {}

| class Square implements Shape {
|   final double length;
|   Square(this.length);
| }

| class Circle implements Shape {
|   final double radius;
|   Circle(this.radius);
| }

| double calculateArea(Shape shape) => switch (shape) {
|       Square(length: var l) => l * l,
|       Circle(radius: var r) => math.pi * r * r
|     };

 If anyone were to add a new subclass of Shape, this switch expression would be incomplete. .
 Exhaustiveness checking would inform you of the missing subtype. This allows you to use Dart .
 in a somewhat functional algebraic datatype style. .

  Guard clause. .

 To set an optional guard clause after a case clause, use the keyword when. A guard clause can follow if case, .
 and both switch statements and expressions. .

| switch (pair) {
|   case (int a, int b) when a > b:
|     print('First element greater');
|   case (int a, int b):
|     print('First element not greater');
| }

 Guards evaluate an arbitrary boolean expression after matching. This allows you to add further constraints .
 on whether a case body should execute. When the guard clause evaluates to false, execution proceeds .
 to the next case rather than exiting the entire switch. .

  Comments. .

 Dart comments usually start with //. .

| // This is a normal, one-line comment.

| /// This is a documentation comment, used to document libraries,
| /// classes, and their members. Tools like IDEs and dartdoc treat
| /// doc comments specially.

| /* Comments like these are also supported. */

  Imports. .

 To access APIs defined in other libraries, use import. .

| // Importing core libraries
| import 'dart:math';

| // Importing libraries from external packages
| import 'package:test/test.dart';

| // Importing files
| import 'path/to/my_other_file.dart';

  Classes. .

 Here‚Äôs an example of a class with three properties, two constructors, and a method. .
 One of the properties can‚Äôt be set directly, so it‚Äôs defined using a getter method (instead of a variable). .
 The method uses string interpolation to print variables‚Äô string equivalents inside of string literals. .

| class Spacecraft {
|   String name;
|   DateTime? launchDate;

|   // Read-only non-final property
|   int? get launchYear => launchDate?.year;
| 
|   // Constructor, with syntactic sugar for assignment to members.
|   Spacecraft(this.name, this.launchDate) {
|   // Initialization code goes here.
|   }

|   // Named constructor that forwards to the default one.
|   Spacecraft.unlaunched(String name) : this(name, null);

|   // Method.
|   void describe() {
|     print('Spacecraft: $name');
|     // Type promotion doesn't work on getters.
|     var launchDate = this.launchDate;
|     if (launchDate != null) {
|       int years = DateTime.now().difference(launchDate).inDays ~/ 365;
|       print('Launched: $launchYear ($years years ago)');
|     } else {
|       print('Unlaunched');
|     }
|   }
| }

 You might use the Spacecraft class like this: .

| var voyager = Spacecraft('Voyager I', DateTime(1977, 9, 5));
| voyager.describe();

| var voyager3 = Spacecraft.unlaunched('Voyager III');
| voyager3.describe();

  Enums. .

 Enums are a way of enumerating a predefined set of values or instances in a way which ensures .
 that there cannot be any other instances of that type. .

 Here is an example of a simple enum that defines a simple list of predefined planet types: .

| enum PlanetType { terrestrial, gas, ice }

 Here is an example of an enhanced enum declaration of a class describing planets, .
 with a defined set of constant instances, namely the planets of our own solar system. .

| /// Enum that enumerates the different planets in our solar system
| /// and some of their properties.
| enum Planet {
|   mercury(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   venus(planetType: PlanetType.terrestrial, moons: 0, hasRings: false),
|   // ¬∑¬∑¬∑
|   uranus(planetType: PlanetType.ice, moons: 27, hasRings: true),
|   neptune(planetType: PlanetType.ice, moons: 14, hasRings: true);

|   /// A constant generating constructor
|   const Planet(
|       {required this.planetType, required this.moons, required this.hasRings});

|   /// All instance variables are final
|   final PlanetType planetType;
|   final int moons;
|   final bool hasRings;

|   /// Enhanced enums support getters and other methods
|   bool get isGiant =>
|       planetType == PlanetType.gas || planetType == PlanetType.ice;
| }

 You might use the Planet enum like this: .

| final yourPlanet = Planet.earth;

| if (!yourPlanet.isGiant) {
|   print('Your planet is not a "giant planet".');
| }

..
  Inheritance. .

 Dart has single inheritance. .

| class Orbiter extends Spacecraft {
|   double altitude;

|   Orbiter(super.name, DateTime super.launchDate, this.altitude);
| }


Read more about extending classes, the optional @override annotation, and more.

  Mixins. .

 Mixins are a way of reusing code in multiple class hierarchies. The following is a mixin declaration: .

| mixin Piloted {
|   int astronauts = 1;

|   void describeCrew() {
|     print('Number of astronauts: $astronauts');
|   }
| }

 To add a mixin‚Äôs capabilities to a class, just extend the class with the mixin. .

| class PilotedCraft extends Spacecraft with Piloted {
|   // ¬∑¬∑¬∑
| }

 PilotedCraft now has the astronauts field as well as the describeCrew() method. .

.....Read more about mixins.

  Interfaces and abstract classes. .

 All classes implicitly define an interface. Therefore, you can implement any class. .

| class MockSpaceship implements Spacecraft {
|   // ¬∑¬∑¬∑
| }

....Read more about implicit interfaces, or about the explicit interface keyword.

 You can create an abstract class to be extended (or implemented) by a concrete class. .
 Abstract classes can contain abstract methods (with empty bodies). .

| abstract class Describable {
|   void describe();

|   void describeWithEmphasis() {
|     print('=========');
|     describe();
|     print('=========');
|   }
| }

 Any class extending Describable has the describeWithEmphasis() method, .
 which calls the extender‚Äôs implementation of describe(). .

.....Read more about abstract classes and methods.
  
  Async. .

 Avoid callback hell and make your code much more readable by using async and await. .

| const oneSecond = Duration(seconds: 1);
| // ¬∑¬∑¬∑
| Future<void> printWithDelay(String message) async {
|   await Future.delayed(oneSecond);
|   print(message);
| }

 The method above is equivalent to: .

| Future<void> printWithDelay(String message) {
|   return Future.delayed(oneSecond).then((_) {
|     print(message);
|   });
| }

 As the next example shows, async and await help make asynchronous code easy to read. .

| Future<void> createDescriptions(Iterable<String> objects) async {
|   for (final object in objects) {
|     try {
|       var file = File('$object.txt');
|       if (await file.exists()) {
|         var modified = await file.lastModified();
|         print(
|             'File for $object already exists. It was modified on $modified.');
|         continue;
|       }
|       await file.create();
|       await file.writeAsString('Start describing $object in this file.');
|     } on IOException catch (e) {
|       print('Cannot create description for $object: $e');
|     }
|   }
| }

 You can also use async*, which gives you a nice, readable way to build streams. .

| Stream<String> report(Spacecraft craft, Iterable<String> objects) async* {
|   for (final object in objects) {
|     await Future.delayed(oneSecond);
|     yield '${craft.name} flies by $object';
|   }
| }

....Read more about asynchrony support, including async functions, Future, Stream, and the asynchronous loop (await for).

  Exceptions. .

 To raise an exception, use throw: .

| if (astronauts == 0) {
|   throw StateError('No astronauts.');
| }

 To catch an exception, use a try statement with on or catch (or both): .

| Future<void> describeFlybyObjects(List<String> flybyObjects) async {
|   try {
|     for (final object in flybyObjects) {
|       var description = await File('$object.txt').readAsString();
|       print(description);
|     }
|   } on IOException catch (e) {
|     print('Could not describe object: $e');
|   } finally {
|     flybyObjects.clear();
|   }
| }

 Note that the code above is asynchronous; try works for both synchronous code and code in an async function. .

...Read more about exceptions, including stack traces, rethrow, and the difference between Error and Exception.
  Important concepts. .

As you continue to learn about the Dart language, keep these facts and concepts in mind: .

    Everything you can place in a variable is an object, and every object is an instance of a class. .
    Even numbers, functions, and null are objects. With the exception of null (if you enable sound null safety), .
    all objects inherit from the Object class. .

    Version note: Null safety was introduced in Dart 2.12. Using null safety requires a language version of at least 2.12. .
    Although Dart is strongly typed, type annotations are optional because Dart can infer types. In var number = 101, number is inferred to be of type int. .
    If you enable null safety, variables can‚Äôt contain null unless you say they can. You can make a variable nullable by putting a question mark (?) at the end of its type. For example, a variable of type int? might be an integer, or it might be null. .
    If you know that an expression never evaluates to null but Dart disagrees, you can add ! to assert that it isn‚Äôt null (and to throw an exception if it is). An example: int x = nullableButNotNullInt! .
    When you want to explicitly say that any type is allowed, use the type Object? (if you‚Äôve enabled null safety), .
    Object, or‚Äîif you must defer type checking until runtime‚Äîthe special type dynamic. .
    Dart supports generic types, like List<int> (a list of integers) or List<Object> (a list of objects of any type). .
    Dart supports top-level functions (such as main()), as well as functions tied to a class or object .
    (static and instance methods, respectively). You can also create functions within functions (nested or local functions). .
    Similarly, Dart supports top-level variables, as well as variables tied to a class or object (static and instance variables). .
    Instance variables are sometimes known as fields or properties. .
    Unlike Java, Dart doesn‚Äôt have the keywords public, protected, and private. If an identifier starts with an underscore (_), .
    it‚Äôs private to its library. For details, see Libraries and imports. .
    Identifiers can start with a letter or underscore (_), followed by any combination of those characters plus digits. .
    Dart has both expressions (which have runtime values) and statements (which don‚Äôt). For example, .
    the conditional expression condition ? expr1 : expr2 has a value of expr1 or expr2. Compare that to an if-else statement, .
    which has no value. A statement often contains one or more expressions, but an expression can‚Äôt directly contain a statement. .

    Dart tools can report two kinds of problems: warnings and errors. Warnings are just indications that your code might not work, .
    but they don‚Äôt prevent your program from executing. Errors can be either compile-time or run-time. A compile-time error .
    prevents the code from executing at all; a run-time error results in an exception being raised while the code executes. .

...Additional resources

...More code samples are in the the library tour and the Dart API reference,. This site‚Äôs code follows the conventions in
...the Dart style guide.
2023-09-26 00:09:28.992617
2023-09-26 00:10:13.177233
